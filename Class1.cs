using System.Runtime.InteropServices;
using System.Reflection;
using Nancy.Diagnostics;
using System.Runtime.CompilerServices;
// <autogenerated />
using System;
using System.Reflection;
#if !DNX
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Reflection;

    /// <summary>
    /// Default implementation of the <see cref="IAssemblyCatalog"/> interface, based on
    /// retrieving <see cref="Assembly"/> information from <see cref="AppDomain.CurrentDomain"/>.
    /// </summary>
    public class AppDomainAssemblyCatalog : IAssemblyCatalog
    {
        private static readonly AssemblyName NancyAssemblyName = typeof(INancyEngine).GetTypeInfo().Assembly.GetName();
        private readonly Lazy<IReadOnlyCollection<Assembly>> assemblies = new Lazy<IReadOnlyCollection<Assembly>>(GetAvailableAssemblies);

        /// <summary>
        /// Gets all <see cref="Assembly"/> instances in the catalog.
        /// </summary>
        /// <returns>An <see cref="IReadOnlyCollection{T}"/> of <see cref="Assembly"/> instances.</returns>
        public IReadOnlyCollection<Assembly> GetAssemblies()
        {
            return this.assemblies.Value;
        }

        private static IReadOnlyCollection<Assembly> GetAvailableAssemblies()
        {
            var assemblies = GetLoadedNancyReferencingAssemblies();

            var loaded = LoadNancyReferencingAssemblies(assemblies);

            return assemblies.Union(loaded).ToArray();
        }

        private static List<Assembly> GetLoadedNancyReferencingAssemblies()
        {
            var assemblies = new List<Assembly>();

            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                if (!assembly.IsDynamic && !assembly.ReflectionOnly && IsNancyReferencing(assembly))
                {
                    assemblies.Add(assembly);
                }
            }

            return assemblies;
        }

        private static IEnumerable<Assembly> LoadNancyReferencingAssemblies(IEnumerable<Assembly> loadedAssemblies)
        {
            var assemblies = new HashSet<Assembly>();
            var inspectionAppDomain = AppDomain.CreateDomain("AppDomainAssemblyCatalog");
            var loadedNancyReferencingAssemblyNames = loadedAssemblies.Select(assembly => assembly.GetName()).ToArray();

            foreach (var directory in GetAssemblyDirectories())
            {
                foreach (var assemblyPath in Directory.EnumerateFiles(directory, "*.dll"))
                {
                    var unloadedAssemblyName = SafeGetAssemblyName(assemblyPath);

                    if (unloadedAssemblyName == null)
                    {
                        continue;
                    }

                    if (!loadedNancyReferencingAssemblyNames.Any(loadedNancyReferencingAssemblyName => AssemblyName.ReferenceMatchesDefinition(loadedNancyReferencingAssemblyName, unloadedAssemblyName)))
                    {
                        var inspectionAssembly = inspectionAppDomain.Load(unloadedAssemblyName);

                        if (IsNancyReferencing(inspectionAssembly))
                        {
                            var assembly = SafeLoadAssembly(unloadedAssemblyName);

                            if (assembly != null)
                            {
                                assemblies.Add(assembly);
                            }
                        }
                    }
                }
            }

            AppDomain.Unload(inspectionAppDomain);

            return assemblies.ToArray();
        }

        private static bool IsNancyReferencing(Assembly assembly)
        {
            if (AssemblyName.ReferenceMatchesDefinition(assembly.GetName(), NancyAssemblyName))
            {
                return true;
            }

            foreach (var referencedAssemblyName in assembly.GetReferencedAssemblies())
            {
                if (AssemblyName.ReferenceMatchesDefinition(referencedAssemblyName, NancyAssemblyName))
                {
                    return true;
                }
            }

            return false;
        }

        private static IEnumerable<string> GetAssemblyDirectories()
        {
            var directories = AppDomain.CurrentDomain.SetupInformation.PrivateBinPath != null
                ? AppDomain.CurrentDomain.SetupInformation.PrivateBinPath.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries)
                : new string[] { };

            foreach (var directory in directories.Where(directory => !string.IsNullOrWhiteSpace(directory)))
            {
                yield return directory;
            }

            if (AppDomain.CurrentDomain.SetupInformation.PrivateBinPathProbe == null)
            {
                yield return AppDomain.CurrentDomain.SetupInformation.ApplicationBase;
            }
        }

        private static AssemblyName SafeGetAssemblyName(string assemblyPath)
        {
            try
            {
                return AssemblyName.GetAssemblyName(assemblyPath);
            }
            catch
            {
                return null;
            }
        }

        private static Assembly SafeLoadAssembly(AssemblyName assemblyName)
        {
            try
            {
                return AppDomain.CurrentDomain.Load(assemblyName);
            }
            catch
            {
                return null;
            }
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public abstract class AsyncNamedPipelineBase<TAsyncDelegate, TSyncDelegate>
    {
        /// <summary>
        /// Pipeline items to execute
        /// </summary>
        protected readonly List<PipelineItem<TAsyncDelegate>> pipelineItems;

        protected AsyncNamedPipelineBase()
        {
            this.pipelineItems = new List<PipelineItem<TAsyncDelegate>>();
        }

        protected AsyncNamedPipelineBase(int capacity)
        {
            this.pipelineItems = new List<PipelineItem<TAsyncDelegate>>(capacity);
        }

        /// <summary>
        /// Gets the current pipeline items
        /// </summary>
        public IEnumerable<PipelineItem<TAsyncDelegate>> PipelineItems
        {
            get { return this.pipelineItems.AsReadOnly(); }
        }

        /// <summary>
        /// Gets the current pipeline item delegates
        /// </summary>
        public IEnumerable<TAsyncDelegate> PipelineDelegates
        {
            get { return this.pipelineItems.Select(pipelineItem => pipelineItem.Delegate); }
        }

        /// <summary>
        /// Add an item to the start of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        public virtual void AddItemToStartOfPipeline(TAsyncDelegate item)
        {
            this.AddItemToStartOfPipeline((PipelineItem<TAsyncDelegate>)item);
        }

        /// <summary>
        /// Add an item to the start of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        public virtual void AddItemToStartOfPipeline(TSyncDelegate item)
        {
            this.AddItemToStartOfPipeline(this.Wrap(item));
        }

        /// <summary>
        /// Add an item to the start of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        /// <param name="replaceInPlace">
        /// Whether to replace an existing item with the same name in its current place,
        /// rather than at the position requested. Defaults to false.
        /// </param>
        public virtual void AddItemToStartOfPipeline(PipelineItem<TAsyncDelegate> item, bool replaceInPlace = false)
        {
            this.InsertItemAtPipelineIndex(0, item, replaceInPlace);
        }

        /// <summary>
        /// Add an item to the start of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        /// <param name="replaceInPlace">
        /// Whether to replace an existing item with the same name in its current place,
        /// rather than at the position requested. Defaults to false.
        /// </param>
        public virtual void AddItemToStartOfPipeline(PipelineItem<TSyncDelegate> item, bool replaceInPlace = false)
        {
            this.AddItemToStartOfPipeline(this.Wrap(item), replaceInPlace);
        }

        /// <summary>
        /// Add an item to the end of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        public virtual void AddItemToEndOfPipeline(TAsyncDelegate item)
        {
            this.AddItemToEndOfPipeline((PipelineItem<TAsyncDelegate>)item);
        }

        /// <summary>
        /// Add an item to the end of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        public virtual void AddItemToEndOfPipeline(TSyncDelegate item)
        {
            this.AddItemToEndOfPipeline(this.Wrap(item));
        }

        /// <summary>
        /// Add an item to the end of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        /// <param name="replaceInPlace">
        /// Whether to replace an existing item with the same name in its current place,
        /// rather than at the position requested. Defaults to false.
        /// </param>
        public virtual void AddItemToEndOfPipeline(PipelineItem<TAsyncDelegate> item, bool replaceInPlace = false)
        {
            var existingIndex = this.RemoveByName(item.Name);

            if (replaceInPlace && existingIndex != -1)
            {
                this.InsertItemAtPipelineIndex(existingIndex, item);
            }
            else
            {
                this.pipelineItems.Add(item);
            }
        }

        /// <summary>
        /// Add an item to the end of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        /// <param name="replaceInPlace">
        /// Whether to replace an existing item with the same name in its current place,
        /// rather than at the position requested. Defaults to false.
        /// </param>
        public virtual void AddItemToEndOfPipeline(PipelineItem<TSyncDelegate> item, bool replaceInPlace = false)
        {
            this.AddItemToEndOfPipeline(this.Wrap(item), replaceInPlace);
        }

        /// <summary>
        /// Add an item to a specific place in the pipeline.
        /// </summary>
        /// <param name="index">Index to add at</param>
        /// <param name="item">Item to add</param>
        public virtual void InsertItemAtPipelineIndex(int index, TAsyncDelegate item)
        {
            this.InsertItemAtPipelineIndex(index, (PipelineItem<TAsyncDelegate>)item);
        }

        /// <summary>
        /// Add an item to a specific place in the pipeline.
        /// </summary>
        /// <param name="index">Index to add at</param>
        /// <param name="item">Item to add</param>
        public virtual void InsertItemAtPipelineIndex(int index, TSyncDelegate item)
        {
            this.InsertItemAtPipelineIndex(index, this.Wrap(item));
        }

        /// <summary>
        /// Add an item to a specific place in the pipeline.
        /// </summary>
        /// <param name="index">Index to add at</param>
        /// <param name="item">Item to add</param>
        /// <param name="replaceInPlace">
        /// Whether to replace an existing item with the same name in its current place,
        /// rather than at the position requested. Defaults to false.
        /// </param>
        public virtual void InsertItemAtPipelineIndex(int index, PipelineItem<TAsyncDelegate> item, bool replaceInPlace = false)
        {
            var existingIndex = this.RemoveByName(item.Name);

            var newIndex = (replaceInPlace && existingIndex != -1) ? existingIndex : index;

            this.pipelineItems.Insert(newIndex, item);
        }

        /// <summary>
        /// Add an item to a specific place in the pipeline.
        /// </summary>
        /// <param name="index">Index to add at</param>
        /// <param name="item">Item to add</param>
        /// <param name="replaceInPlace">
        /// Whether to replace an existing item with the same name in its current place,
        /// rather than at the position requested. Defaults to false.
        /// </param>
        public virtual void InsertItemAtPipelineIndex(int index, PipelineItem<TSyncDelegate> item, bool replaceInPlace = false)
        {
            this.InsertItemAtPipelineIndex(index, this.Wrap(item), replaceInPlace);
        }

        /// <summary>
        /// Insert an item before a named item.
        /// If the named item does not exist the item is inserted at the start of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert before</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertBefore(string name, TAsyncDelegate item)
        {
            this.InsertBefore(name, (PipelineItem<TAsyncDelegate>)item);
        }

        /// <summary>
        /// Insert an item before a named item.
        /// If the named item does not exist the item is inserted at the start of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert before</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertBefore(string name, TSyncDelegate item)
        {
            this.InsertBefore(name, this.Wrap(item));
        }

        /// <summary>
        /// Insert an item before a named item.
        /// If the named item does not exist the item is inserted at the start of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert before</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertBefore(string name, PipelineItem<TAsyncDelegate> item)
        {
            var existingIndex =
                this.pipelineItems.FindIndex(i => String.Equals(name, i.Name, StringComparison.Ordinal));

            if (existingIndex == -1)
            {
                existingIndex = 0;
            }

            this.InsertItemAtPipelineIndex(existingIndex, item);
        }

        /// <summary>
        /// Insert an item before a named item.
        /// If the named item does not exist the item is inserted at the start of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert before</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertBefore(string name, PipelineItem<TSyncDelegate> item)
        {
            this.InsertBefore(name, this.Wrap(item));
        }

        /// <summary>
        /// Insert an item after a named item.
        /// If the named item does not exist the item is inserted at the end of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert after</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertAfter(string name, TAsyncDelegate item)
        {
            this.InsertAfter(name, (PipelineItem<TAsyncDelegate>)item);
        }

        /// <summary>
        /// Insert an item after a named item.
        /// If the named item does not exist the item is inserted at the end of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert after</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertAfter(string name, TSyncDelegate item)
        {
            this.InsertAfter(name, this.Wrap(item));
        }

        /// <summary>
        /// Insert an item after a named item.
        /// If the named item does not exist the item is inserted at the end of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert after</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertAfter(string name, PipelineItem<TAsyncDelegate> item)
        {
            var existingIndex =
                this.pipelineItems.FindIndex(i => String.Equals(name, i.Name, StringComparison.Ordinal));

            if (existingIndex == -1)
            {
                existingIndex = this.pipelineItems.Count;
            }

            existingIndex++;

            if (existingIndex > this.pipelineItems.Count)
            {
                this.AddItemToEndOfPipeline(item);
            }
            else
            {
                this.InsertItemAtPipelineIndex(existingIndex, item);
            }
        }

        /// <summary>
        /// Insert an item after a named item.
        /// If the named item does not exist the item is inserted at the end of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert after</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertAfter(string name, PipelineItem<TSyncDelegate> item)
        {
            this.InsertAfter(name, this.Wrap(item));
        }

        /// <summary>
        /// Remove a named pipeline item
        /// </summary>
        /// <param name="name">Name</param>
        /// <returns>Index of item that was removed or -1 if nothing removed</returns>
        public virtual int RemoveByName(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                return -1;
            }

            var existingIndex =
                this.pipelineItems.FindIndex(i => String.Equals(name, i.Name, StringComparison.Ordinal));

            if (existingIndex != -1)
            {
                this.pipelineItems.RemoveAt(existingIndex);
            }

            return existingIndex;
        }

        /// <summary>
        /// Wraps a sync delegate into it's async form
        /// </summary>
        /// <param name="syncDelegate">Sync pipeline instance</param>
        /// <returns>Async pipeline instance</returns>
        protected abstract PipelineItem<TAsyncDelegate> Wrap(PipelineItem<TSyncDelegate> syncDelegate);
    }
}
namespace Nancy.Bootstrapper
{
    /// <summary>
    /// Provides a hook to execute code during request startup.
    /// </summary>
    public interface IRequestStartup
    {
        /// <summary>
        /// Perform any initialisation tasks
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        /// <param name="context">The current context</param>
        void Initialize(IPipelines pipelines, NancyContext context);
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Helper class for providing application registrations
    /// </summary>
    public abstract class Registrations : IRegistrations
    {
        private readonly ITypeCatalog typeCatalog;
        private readonly IList<CollectionTypeRegistration> collectionRegistrations = new List<CollectionTypeRegistration>();
        private readonly IList<InstanceRegistration> instanceRegistrations = new List<InstanceRegistration>();
        private readonly IList<TypeRegistration> typeRegistrations = new List<TypeRegistration>();

        /// <summary>
        /// Initializes a new instance of the <see cref="Registrations"/> class.
        /// </summary>
        /// <param name="typeCatalog">An <see cref="ITypeCatalog"/> instance.</param>
        protected Registrations(ITypeCatalog typeCatalog)
        {
            this.typeCatalog = typeCatalog;
        }

        /// <summary>
        /// Gets the collection registrations to register for this startup task
        /// </summary>
        public IEnumerable<CollectionTypeRegistration> CollectionTypeRegistrations
        {
            get { return this.collectionRegistrations; }
        }

        /// <summary>
        /// Gets the instance registrations to register for this startup task
        /// </summary>
        public IEnumerable<InstanceRegistration> InstanceRegistrations
        {
            get { return this.instanceRegistrations; }
        }

        /// <summary>
        /// Gets the type registrations to register for this startup task
        /// </summary>
        public IEnumerable<TypeRegistration> TypeRegistrations
        {
            get { return this.typeRegistrations; }
        }

        /// <summary>
        /// Scans for the implementation of <typeparamref name="TRegistration"/> and registers it.
        /// </summary>
        /// <param name="lifetime">Lifetime of the registration, defaults to singleton</param>
        /// <typeparam name="TRegistration">The <see cref="Type"/> to scan for and register as.</typeparam>
        public void Register<TRegistration>(Lifetime lifetime = Lifetime.Singleton)
        {
            var implementation = this.typeCatalog
                .GetTypesAssignableTo<TRegistration>()
                .Single();

            this.typeRegistrations.Add(new TypeRegistration(typeof(TRegistration), implementation, lifetime));
        }

        /// <summary>
        /// Scans for all implementations of <typeparamref name="TRegistration"/> and registers them.
        /// </summary>
        /// <param name="lifetime">Lifetime of the registration, defaults to singleton</param>
        /// <typeparam name="TRegistration">The <see cref="Type"/> to scan for and register as.</typeparam>
        public void RegisterAll<TRegistration>(Lifetime lifetime = Lifetime.Singleton)
        {
            var implementations = this.typeCatalog
                .GetTypesAssignableTo<TRegistration>();

            var registration =
                new CollectionTypeRegistration(typeof(TRegistration), implementations, lifetime);

            this.collectionRegistrations.Add(registration);
        }

        /// <summary>
        /// Registers the types provided by the <paramref name="defaultImplementations"/> parameters
        /// as <typeparamref name="TRegistration"/>.
        /// </summary>
        /// <typeparam name="TRegistration">The <see cref="Type"/> to register as.</typeparam>
        /// <param name="defaultImplementations">The types to register.</param>
        /// <param name="lifetime">Lifetime of the registration, defaults to singleton</param>
        public void Register<TRegistration>(IEnumerable<Type> defaultImplementations, Lifetime lifetime = Lifetime.Singleton)
        {
            this.collectionRegistrations.Add(new CollectionTypeRegistration(typeof(TRegistration), defaultImplementations, lifetime));
        }

        /// <summary>
        /// Registers the type provided by the <paramref name="implementation"/> parameter
        /// as <typeparamref name="TRegistration"/>.
        /// </summary>
        /// <param name="lifetime">Lifetime of the registration, defaults to singleton</param>
        /// <typeparam name="TRegistration">The <see cref="Type"/> to register as.</typeparam>
        /// <param name="implementation">The <see cref="Type"/> to register as <typeparamref name="TRegistration"/>.</param>
        public void Register<TRegistration>(Type implementation, Lifetime lifetime = Lifetime.Singleton)
        {
            this.typeRegistrations.Add(new TypeRegistration(typeof(TRegistration), implementation, lifetime));
        }

        /// <summary>
        /// Registers an instance as <typeparamref name="TRegistration"/>.
        /// </summary>
        /// <typeparam name="TRegistration">The <see cref="Type"/> to register as.</typeparam>
        /// <param name="instance">The instance to register.</param>
        public void Register<TRegistration>(TRegistration instance)
        {
            this.instanceRegistrations.Add(new InstanceRegistration(typeof(TRegistration), instance));
        }

        /// <summary>
        /// Scans for a <see cref="Type"/> that implements <typeparamref name="TRegistration"/>. If found, then it
        /// will be used for the registration, else it will use <paramref name="defaultImplementation"/>.
        /// </summary>
        /// <param name="lifetime">Lifetime of the registration, defaults to singleton</param>
        /// <typeparam name="TRegistration">The <see cref="Type"/> to register as.</typeparam>
        /// <param name="defaultImplementation">The implementation of <typeparamref name="TRegistration"/> that will be use if no other implementation can be found.</param>
        /// <remarks>
        /// When scanning, it will exclude the assembly that the <see cref="Registrations"/> instance is defined in and it will also ignore
        /// the type specified by <paramref name="defaultImplementation"/>.
        /// </remarks>
        public void RegisterWithDefault<TRegistration>(Type defaultImplementation, Lifetime lifetime = Lifetime.Singleton)
        {
            var implementation = this.typeCatalog
                .GetTypesAssignableTo<TRegistration>()
                .Where(type => type.Assembly != this.GetType().Assembly)
                .SingleOrDefault(type => type != defaultImplementation);

            this.typeRegistrations.Add(new TypeRegistration(typeof(TRegistration), implementation ?? defaultImplementation, lifetime));
        }

        /// <summary>
        /// Scans for an implementation of <typeparamref name="TRegistration"/> and registers it if found. If no implementation could
        /// be found, it will retrieve an instance of <typeparamref name="TRegistration"/> using the provided <paramref name="defaultImplementationFactory"/>,
        /// which will be used in the registration.
        /// </summary>
        /// <typeparam name="TRegistration">The <see cref="Type"/> to register as.</typeparam>
        /// <param name="defaultImplementationFactory">Factory that provides an instance of <typeparamref name="TRegistration"/>.</param>
        /// <remarks>When scanning, it will exclude the assembly that the <see cref="Registrations"/> instance is defined in</remarks>
        public void RegisterWithDefault<TRegistration>(Func<TRegistration> defaultImplementationFactory)
        {
            var implementation = this.typeCatalog
                .GetTypesAssignableTo<TRegistration>()
                .SingleOrDefault(type => type.Assembly != this.GetType().Assembly);

            if (implementation != null)
            {
                this.typeRegistrations.Add(new TypeRegistration(typeof(TRegistration), implementation));
            }
            else
            {
                this.instanceRegistrations.Add(new InstanceRegistration(typeof(TRegistration), defaultImplementationFactory.Invoke()));
            }
        }

        /// <summary>
        /// Scans for all implementations of <typeparamref name="TRegistration"/>. If no implementations could be found, then it
        /// will register the types specified by <paramref name="defaultImplementations"/>.
        /// </summary>
        /// <param name="lifetime">Lifetime of the registration, defaults to singleton</param>
        /// <typeparam name="TRegistration">The <see cref="Type"/> to register as.</typeparam>
        /// <param name="defaultImplementations">The types to register if non could be located while scanning.</param>
        /// <remarks>
        /// When scanning, it will exclude the assembly that the <see cref="Registrations"/> instance is defined in and it will also ignore
        /// the types specified by <paramref name="defaultImplementations"/>.
        /// </remarks>
        public void RegisterWithDefault<TRegistration>(IEnumerable<Type> defaultImplementations, Lifetime lifetime = Lifetime.Singleton)
        {
            var implementations = this.typeCatalog
                .GetTypesAssignableTo<TRegistration>()
                .Where(type => type.Assembly != this.GetType().Assembly)
                .Where(type => !defaultImplementations.Contains(type))
                .ToList();

            if (!implementations.Any())
            {
                implementations = defaultImplementations.ToList();
            }

            this.collectionRegistrations.Add(new CollectionTypeRegistration(typeof(TRegistration), implementations, lifetime));
        }

        /// <summary>
        /// Scans for all implementations of <typeparamref name="TRegistration"/> and registers them, followed by the
        /// types defined by the <paramref name="defaultImplementations"/> parameter.
        /// </summary>
        /// <typeparam name="TRegistration">The <see cref="Type"/> to register as.</typeparam>
        /// <param name="defaultImplementations">The types to register last.</param>
        /// <param name="lifetime">Lifetime of the registration, defaults to singleton</param>
        /// <remarks>
        /// When scanning, it will exclude the assembly that the <see cref="Registrations"/> instance is defined in and it will also ignore
        /// the types specified by <paramref name="defaultImplementations"/>.
        /// </remarks>
        public void RegisterWithUserThenDefault<TRegistration>(IEnumerable<Type> defaultImplementations, Lifetime lifetime = Lifetime.Singleton)
        {
            var implementations = this.typeCatalog
                .GetTypesAssignableTo<TRegistration>()
                .Where(type => type.Assembly != this.GetType().Assembly)
                .Where(type => !defaultImplementations.Contains(type))
                .ToList();

            this.collectionRegistrations.Add(new CollectionTypeRegistration(typeof(TRegistration), implementations.Union(defaultImplementations), lifetime));
        }
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Exception that is raised from inside the <see cref="NancyBootstrapperBase{T}"/> type or one of
    /// the inheriting types.
    /// </summary>
    public class BootstrapperException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="BootstrapperException"/> class, with
        /// the provided <paramref name="message"/>.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public BootstrapperException(string message) : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BootstrapperException"/> class, with
        /// the provided <paramref name="message"/> and <paramref name="innerException"/>.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        public BootstrapperException(string message, Exception innerException) : base(message, innerException)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleRootPathProvidersLocatedException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        protected BootstrapperException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Represents a type to be registered multiple times into the
    /// container to later be resolved using an IEnumerable{RegistrationType}
    /// constructor dependency.
    /// </summary>
    public class CollectionTypeRegistration : ContainerRegistration
    {
        /// <summary>
        /// Represents a type to be registered multiple times into the
        /// container to later be resolved using an IEnumerable{RegistrationType}
        /// constructor dependency.
        /// </summary>
        /// <param name="registrationType">Registration type i.e. IMyInterface</param>
        /// <param name="implementationTypes">Collection of implementation type i.e. MyClassThatImplementsIMyInterface</param>
        /// <param name="lifetime">Lifetime to register the type as</param>
        public CollectionTypeRegistration(Type registrationType, IEnumerable<Type> implementationTypes, Lifetime lifetime = Lifetime.Singleton)
        {
            if (registrationType == null)
            {
                throw new ArgumentNullException("registrationType");
            }

            if (implementationTypes == null)
            {
                throw new ArgumentNullException("implementationTypes");
            }

            this.RegistrationType = registrationType;
            this.ImplementationTypes = implementationTypes;
            this.Lifetime = lifetime;

            this.ValidateTypeCompatibility(implementationTypes.ToArray());
        }

        /// <summary>
        /// Collection of implementation type i.e. MyClassThatImplementsIMyInterface
        /// </summary>
        public IEnumerable<Type> ImplementationTypes { get; private set; }
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using System.Linq;

    using Nancy.Extensions;

    /// <summary>
    /// Base class for container registrations
    /// </summary>
    public abstract class ContainerRegistration
    {
        /// <summary>
        /// Gets the lifetime of the registration
        /// </summary>
        public Lifetime Lifetime { get; protected set; }

        /// <summary>
        /// Registration type i.e. IMyInterface
        /// </summary>
        public Type RegistrationType { get; protected set; }

        /// <summary>
        /// Checks if all implementation types are assignable from the registration type, otherwise throws an exception.
        /// </summary>
        /// <param name="types">The implementation types.</param>
        /// <exception cref="ArgumentException">One or more of the implementation types is not assignable from the registration type.</exception>
        /// <exception cref="InvalidOperationException">The <see cref="RegistrationType"/> property must be assigned before the method is invoked.</exception>
        protected void ValidateTypeCompatibility(params Type[] types)
        {
            if (this.RegistrationType == null)
            {
                throw new InvalidOperationException("The RegistrationType must be set first.");
            }

            var incompatibleTypes =
                types.Where(type => !this.RegistrationType.IsAssignableFrom(type) && !type.IsAssignableToGenericType(this.RegistrationType)).ToArray();

            if (incompatibleTypes.Any())
            {
                var incompatibleTypeNames =
                    string.Join(", ", incompatibleTypes.Select(type => type.FullName));

                var errorMessage =
                    string.Format("{0} must implement {1} inorder to be registered by {2}", incompatibleTypeNames, this.RegistrationType.FullName, this.GetType().Name);

                throw new ArgumentException(errorMessage);
            }
        }
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using Nancy.Configuration;

    /// <summary>
    /// Application startup task that attempts to locate a favicon. The startup will first scan all
    /// folders in the path defined by the provided <see cref="IRootPathProvider"/> and if it cannot
    /// find one, it will fall back and use the default favicon that is embedded in the Nancy.dll file.
    /// </summary>
    public class FavIconApplicationStartup : IApplicationStartup
    {
        private static TraceConfiguration traceConfiguration;
        private static IRootPathProvider rootPathProvider;
        private static byte[] favIcon;

        /// <summary>
        /// Initializes a new instance of the <see cref="FavIconApplicationStartup"/> class, with the
        /// provided <see cref="IRootPathProvider"/> instance.
        /// </summary>
        /// <param name="rootPathProvider">The <see cref="IRootPathProvider"/> that should be used to scan for a favicon.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public FavIconApplicationStartup(IRootPathProvider rootPathProvider, INancyEnvironment environment)
        {
            FavIconApplicationStartup.rootPathProvider = rootPathProvider;
            FavIconApplicationStartup.traceConfiguration = environment.GetValue<TraceConfiguration>();
        }

        /// <summary>
        /// Gets the default favicon
        /// </summary>
        /// <value>A byte array, containing a favicon.ico file.</value>
        public static byte[] FavIcon
        {
            get { return favIcon ?? (favIcon = ScanForFavIcon()); }
        }

        /// <summary>
        /// Perform any initialisation tasks
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        public void Initialize(IPipelines pipelines)
        {
        }

        private static byte[] ExtractDefaultIcon()
        {
            var resourceStream =
                typeof(INancyEngine).Assembly.GetManifestResourceStream("Nancy.favicon.ico");

            if (resourceStream == null)
            {
                return null;
            }

            var result =
                new byte[resourceStream.Length];

            resourceStream.Read(result, 0, (int)resourceStream.Length);

            return result;
        }

        private static byte[] LocateIconOnFileSystem()
        {
            if (rootPathProvider == null)
            {
                return null;
            }

            var extensions = new[] { "ico", "png" };

            var locatedFavIcon = extensions.SelectMany(EnumerateFiles).FirstOrDefault();
            if (locatedFavIcon == null)
            {
                return null;
            }

            try
            {
                return File.ReadAllBytes(locatedFavIcon);
            }
            catch (Exception e)
            {
                if (!traceConfiguration.Enabled)
                {
                    throw new InvalidDataException("Unable to load favicon", e);
                }

                return null;
            }
        }

        private static IEnumerable<string> EnumerateFiles(string extension)
        {
            var rootPath = rootPathProvider.GetRootPath();
            var fileName = string.Concat("favicon.", extension);

            return Directory.EnumerateFiles(rootPath, fileName, SearchOption.AllDirectories);
        }

        private static byte[] ScanForFavIcon()
        {
            byte[] locatedIcon = null;

            try
            {
                locatedIcon = LocateIconOnFileSystem();
            }
            catch (Exception)
            {
            }

            return locatedIcon ?? ExtractDefaultIcon();
        }
    }
}
namespace Nancy.Bootstrapper
{
    using System.Collections.Generic;

    /// <summary>
    /// Provides a hook to perform registrations during application startup.
    /// </summary>
    public interface IRegistrations
    {
        /// <summary>
        /// Gets the type registrations to register for this startup task
        /// </summary>
        IEnumerable<TypeRegistration> TypeRegistrations { get; }

        /// <summary>
        /// Gets the collection registrations to register for this startup task
        /// </summary>
        IEnumerable<CollectionTypeRegistration> CollectionTypeRegistrations { get; }

        /// <summary>
        /// Gets the instance registrations to register for this startup task
        /// </summary>
        IEnumerable<InstanceRegistration> InstanceRegistrations { get; }
    }
}
namespace Nancy.Bootstrapper
{
    public interface IPipelines
    {
        /// <summary>
        /// <para>
        /// The pre-request hook
        /// </para>
        /// <para>
        /// The PreRequest hook is called prior to processing a request. If a hook returns
        /// a non-null response then processing is aborted and the response provided is
        /// returned.
        /// </para>
        /// </summary>
        BeforePipeline BeforeRequest { get; set; }

        /// <summary>
        /// <para>
        /// The post-request hook
        /// </para>
        /// <para>
        /// The post-request hook is called after the response is created. It can be used
        /// to rewrite the response or add/remove items from the context.
        /// </para>
        /// </summary>
        AfterPipeline AfterRequest { get; set; }

        /// <summary>
        /// <para>
        /// The error hook
        /// </para>
        /// <para>
        /// The error hook is called if an exception is thrown at any time during the pipeline.
        /// If no error hook exists a standard InternalServerError response is returned
        /// </para>
        /// </summary>
        ErrorPipeline OnError { get; set; }
    }
}
namespace Nancy.Bootstrapper
{
    using System;

    /// <summary>
    /// Represents an instance to be registered into the container
    /// </summary>
    public class InstanceRegistration : ContainerRegistration
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InstanceRegistration"/> class.
        /// </summary>
        /// <param name="registrationType">The registration type.</param>
        /// <param name="implementation">The implementation.</param>
        public InstanceRegistration(Type registrationType, object implementation)
        {
            if (registrationType == null)
            {
                throw new ArgumentNullException("registrationType");
            }

            if (implementation == null)
            {
                throw new ArgumentNullException("implementation");
            }

            this.RegistrationType = registrationType;
            this.Implementation = implementation;
            this.Lifetime = Lifetime.Singleton;

            this.ValidateTypeCompatibility(implementation.GetType());
        }

        /// <summary>
        /// Implementation object instance i.e. instance of MyClassThatImplementsIMyInterface
        /// </summary>
        public object Implementation { get; private set; }
    }
}
namespace Nancy.Bootstrapper
{
    /// <summary>
    /// Provides a hook to execute code during application startup.
    /// </summary>
    public interface IApplicationStartup
    {
        /// <summary>
        /// Perform any initialisation tasks
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        void Initialize(IPipelines pipelines);
    }
}
namespace Nancy.Bootstrapper
{
    /// <summary>
    /// Represents the lifetime of a container registration
    /// </summary>
    public enum Lifetime
    {
        /// <summary>
        /// Transient lifetime - each request to the container for
        /// the type will result in a new version being returned.
        /// </summary>
        Transient,

        /// <summary>
        /// Singleton - each request to the container for the type
        /// will result in the same instance being returned.
        /// </summary>
        Singleton,

        /// <summary>
        /// PerRequest - within the context of each request each request
        /// for the type will result in the same instance being returned.
        /// Different requests will have different versions.
        /// </summary>
        PerRequest
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.Serialization;
    using System.Text;

    /// <summary>
    /// Exception raised when the <see cref="NancyBootstrapperBase{T}"/> discovers more than one
    /// <see cref="IRootPathProvider"/> implementation in the loaded assemblies.
    /// </summary>
    public class MultipleRootPathProvidersLocatedException : BootstrapperException
    {
        private const string DefaultMessageIntroduction = @"More than one IRootPathProvider was found";
        private const string DefaultMessageConclusion = @"and since we do not know which one you want to use, you need to override the RootPathProvider property on your bootstrapper and specify which one to use. Sorry for the inconvenience.";
        private const string DefaultMessage = DefaultMessageIntroduction + ", " + DefaultMessageConclusion;
        private string errorMessage;

        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleRootPathProvidersLocatedException"/> class.
        /// </summary>
        public MultipleRootPathProvidersLocatedException()
            : base(DefaultMessage)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleRootPathProvidersLocatedException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public MultipleRootPathProvidersLocatedException(string message) : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleRootPathProvidersLocatedException"/> class.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        public MultipleRootPathProvidersLocatedException(string message, Exception innerException) : base(message, innerException)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleRootPathProvidersLocatedException"/> class.
        /// </summary>
        /// <param name="providerTypes">The provider types.</param>
        public MultipleRootPathProvidersLocatedException(IEnumerable<Type> providerTypes)
            : base(DefaultMessage)
        {
            this.StoreProviderTypes(providerTypes);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleRootPathProvidersLocatedException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        protected MultipleRootPathProvidersLocatedException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }

        /// <summary>
        /// Gets the provider types.
        /// </summary>
        /// <value>
        /// The provider types.
        /// </value>
        public IEnumerable<Type> ProviderTypes { get; internal set; }

        /// <summary>
        /// Stores the provider types.
        /// </summary>
        /// <param name="providerTypes">The provider types.</param>
        private void StoreProviderTypes(IEnumerable<Type> providerTypes)
        {
            this.ProviderTypes =
                providerTypes.ToList().AsReadOnly();

            this.Data.Add("ProviderTypes", this.ProviderTypes);
        }

        /// <summary>
        /// Returns a more friendly and informative message if the list of providers is available.
        /// </summary>
        /// <remarks>
        /// Message generated will be of the format:
        /// <example>
        /// More than one IRootPathProvider was found:
        ///    Nancy.Tests.Functional.Tests.CustomRootPathProvider2
        ///    Nancy.Tests.Functional.Tests.CustomRootPathProvider
        /// and since we do not know which one you want to use, you need to override the RootPathProvider property on your bootstrapper and specify which one to use. Sorry for the inconvenience.
        /// </example>
        /// </remarks>
        public override string Message
        {
            get
            {
                return (this.errorMessage ?? (this.errorMessage = this.GetErrorMessage()));
            }
        }

        private string GetErrorMessage()
        {
            if ((this.ProviderTypes == null) || (!this.ProviderTypes.Any()))
            {
                return base.Message;
            }

            var builder =
                new StringBuilder(DefaultMessageIntroduction);

            foreach (var providerType in this.ProviderTypes)
            {
                builder.AppendFormat("\n    {0}", providerType.FullName);
            }

            builder.AppendFormat("\n {0}", DefaultMessageConclusion);

            return builder.ToString();
        }
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Nancy.Configuration;
    using Nancy.Culture;
    using Nancy.Diagnostics;
    using Nancy.ErrorHandling;
    using Nancy.Localization;
    using Nancy.ModelBinding;
    using Nancy.Responses;
    using Nancy.Responses.Negotiation;
    using Nancy.Routing;
    using Nancy.Routing.Constraints;
    using Nancy.Routing.Trie;
    using Nancy.Security;
    using Nancy.Validation;
    using Nancy.ViewEngines;

    /// <summary>
    /// Configuration class for Nancy's internals.
    /// Contains implementation types/configuration for Nancy that usually
    /// do not require overriding in "general use".
    /// </summary>
    public sealed class NancyInternalConfiguration
    {
        /// <summary>
        /// Gets the Nancy default configuration
        /// </summary>
        public static Func<ITypeCatalog, NancyInternalConfiguration> Default
        {
            get
            {
                return typeCatalog => new NancyInternalConfiguration
                {
                    Binder = typeof(DefaultBinder),
                    BindingDefaults = typeof(BindingDefaults),
                    ContextFactory = typeof(DefaultNancyContextFactory),
                    CsrfTokenValidator = typeof(DefaultCsrfTokenValidator),
                    CultureService = typeof(DefaultCultureService),
                    DefaultConfigurationProviders = typeCatalog.GetTypesAssignableTo<INancyDefaultConfigurationProvider>().ToList(),
                    Diagnostics = typeof(DefaultDiagnostics),
                    EnvironmentFactory = typeof(DefaultNancyEnvironmentFactory),
                    EnvironmentConfigurator = typeof(DefaultNancyEnvironmentConfigurator),
                    FieldNameConverter = typeof(DefaultFieldNameConverter),
                    InteractiveDiagnosticProviders = new List<Type>(typeCatalog.GetTypesAssignableTo<IDiagnosticsProvider>()),
                    ModelBinderLocator = typeof(DefaultModelBinderLocator),
                    ModelValidatorLocator = typeof(DefaultValidatorLocator),
                    NancyEngine = typeof(NancyEngine),
                    NancyModuleBuilder = typeof(DefaultNancyModuleBuilder),
                    ObjectSerializer = typeof(DefaultObjectSerializer),
                    RenderContextFactory = typeof(DefaultRenderContextFactory),
                    RequestDispatcher = typeof(DefaultRequestDispatcher),
                    RequestTraceFactory = typeof(DefaultRequestTraceFactory),
                    RequestTracing = typeof(DefaultRequestTracing),
                    ResourceAssemblyProvider = typeof(ResourceAssemblyProvider),
                    ResourceReader = typeof(DefaultResourceReader),
                    ResponseFormatterFactory = typeof(DefaultResponseFormatterFactory),
                    ResponseNegotiator = typeof(DefaultResponseNegotiator),
                    ResponseProcessors = typeCatalog.GetTypesAssignableTo<IResponseProcessor>().ToList(),
                    RouteCache = typeof(RouteCache),
                    RouteCacheProvider = typeof(DefaultRouteCacheProvider),
                    RouteInvoker = typeof(DefaultRouteInvoker),
                    RoutePatternMatcher = typeof(DefaultRoutePatternMatcher),
                    RouteResolver = typeof(DefaultRouteResolver),
                    RouteResolverTrie = typeof(RouteResolverTrie),
                    RouteSegmentConstraints = typeCatalog.GetTypesAssignableTo<IRouteSegmentConstraint>().ToList(),
                    RouteSegmentExtractor = typeof(DefaultRouteSegmentExtractor),
                    RouteMetadataProviders = typeCatalog.GetTypesAssignableTo<IRouteMetadataProvider>().ToList(),
                    RouteDescriptionProvider = typeof(DefaultRouteDescriptionProvider),
                    RuntimeEnvironmentInformation = typeof(DefaultRuntimeEnvironmentInformation),
                    SerializerFactory = typeof(DefaultSerializerFactory),
                    Serializers = typeCatalog.GetTypesAssignableTo<ISerializer>(TypeResolveStrategies.ExcludeNancy).Union(new List<Type>(new[] { typeof(DefaultJsonSerializer), typeof(DefaultXmlSerializer) })).ToList(),
                    StaticContentProvider = typeof(DefaultStaticContentProvider),
                    StatusCodeHandlers = new List<Type>(typeCatalog.GetTypesAssignableTo<IStatusCodeHandler>(TypeResolveStrategies.ExcludeNancy).Concat(new[] { typeof(DefaultStatusCodeHandler) })),
                    TextResource = typeof(ResourceBasedTextResource),
                    TrieNodeFactory = typeof(TrieNodeFactory),
                    ViewLocator = typeof(DefaultViewLocator),
                    ViewFactory = typeof(DefaultViewFactory),
                    ViewResolver = typeof(DefaultViewResolver),
                    ViewCache = typeof(DefaultViewCache),
                    ViewLocationProvider = typeof(FileSystemViewLocationProvider),
                };
            }
        }

        public Type RuntimeEnvironmentInformation { get; set; }

        public Type SerializerFactory { get; set; }

        public IList<Type> DefaultConfigurationProviders { get; set; }

        public Type EnvironmentConfigurator { get; set; }

        public Type EnvironmentFactory { get; set; }

        public IList<Type> RouteMetadataProviders { get; set; }

        public Type RouteResolver { get; set; }

        public Type RoutePatternMatcher { get; set; }

        public Type ContextFactory { get; set; }

        public Type NancyEngine { get; set; }

        public Type RouteCache { get; set; }

        public Type RouteCacheProvider { get; set; }

        public Type ViewLocator { get; set; }

        public Type ViewFactory { get; set; }

        public Type NancyModuleBuilder { get; set; }

        public Type ResponseFormatterFactory { get; set; }

        public Type ModelBinderLocator { get; set; }

        public Type Binder { get; set; }

        public Type BindingDefaults { get; set; }

        public Type FieldNameConverter { get; set; }

        public Type ModelValidatorLocator { get; set; }

        public Type ViewResolver { get; set; }

        public Type ViewCache { get; set; }

        public Type RenderContextFactory { get; set; }

        public Type ViewLocationProvider { get; set; }

        public IList<Type> StatusCodeHandlers { get; set; }

        public Type CsrfTokenValidator { get; set; }

        public Type ObjectSerializer { get; set; }

        public IList<Type> Serializers { get; set; }

        public IList<Type> InteractiveDiagnosticProviders { get; set; }

        public Type RequestTracing { get; set; }

        public Type RouteInvoker { get; set; }

        public IList<Type> ResponseProcessors { get; set; }

        public Type RequestDispatcher { get; set; }

        public Type Diagnostics { get; set; }

        public Type RouteSegmentExtractor { get; set; }

        public Type RouteDescriptionProvider { get; set; }

        public Type CultureService { get; set; }

        public Type TextResource { get; set; }

        public Type ResourceAssemblyProvider { get; set; }

        public Type ResourceReader { get; set; }

        public Type StaticContentProvider { get; set; }

        public Type RouteResolverTrie { get; set; }

        public Type TrieNodeFactory { get; set; }

        public IList<Type> RouteSegmentConstraints { get; set; }

        public Type RequestTraceFactory { get; set; }

        public Type ResponseNegotiator { get; set; }

        /// <summary>
        /// Gets a value indicating whether the configuration is valid.
        /// </summary>
        public bool IsValid
        {
            get
            {
                try
                {
                    return this.GetTypeRegistrations().All(tr => tr.RegistrationType != null);
                }
                catch (ArgumentNullException)
                {
                    return false;
                }
            }
        }

        public static Func<ITypeCatalog, NancyInternalConfiguration> WithOverrides(Action<NancyInternalConfiguration> builder)
        {
            return catalog =>
            {
                var configuration =
                    Default.Invoke(catalog);

                builder.Invoke(configuration);

                return configuration;
            };
        }

        /// <summary>
        /// Returns the configuration types as a TypeRegistration collection
        /// </summary>
        /// <returns>TypeRegistration collection representing the configuration types</returns>
        public IEnumerable<TypeRegistration> GetTypeRegistrations()
        {
            return new[]
            {
                new TypeRegistration(typeof(IRouteResolver), this.RouteResolver),
                new TypeRegistration(typeof(INancyEngine), this.NancyEngine),
                new TypeRegistration(typeof(IRouteCache), this.RouteCache),
                new TypeRegistration(typeof(IRouteCacheProvider), this.RouteCacheProvider),
                new TypeRegistration(typeof(IRoutePatternMatcher), this.RoutePatternMatcher),
                new TypeRegistration(typeof(IViewLocator), this.ViewLocator),
                new TypeRegistration(typeof(IViewFactory), this.ViewFactory),
                new TypeRegistration(typeof(INancyContextFactory), this.ContextFactory),
                new TypeRegistration(typeof(INancyModuleBuilder), this.NancyModuleBuilder),
                new TypeRegistration(typeof(IResponseFormatterFactory), this.ResponseFormatterFactory),
                new TypeRegistration(typeof(IModelBinderLocator), this.ModelBinderLocator),
                new TypeRegistration(typeof(IBinder), this.Binder),
                new TypeRegistration(typeof(BindingDefaults), this.BindingDefaults),
                new TypeRegistration(typeof(IFieldNameConverter), this.FieldNameConverter),
                new TypeRegistration(typeof(IViewResolver), this.ViewResolver),
                new TypeRegistration(typeof(IViewCache), this.ViewCache),
                new TypeRegistration(typeof(IRenderContextFactory), this.RenderContextFactory),
                new TypeRegistration(typeof(IViewLocationProvider), this.ViewLocationProvider),
                new TypeRegistration(typeof(ICsrfTokenValidator), this.CsrfTokenValidator),
                new TypeRegistration(typeof(IObjectSerializer), this.ObjectSerializer),
                new TypeRegistration(typeof(IModelValidatorLocator), this.ModelValidatorLocator),
                new TypeRegistration(typeof(IRequestTracing), this.RequestTracing),
                new TypeRegistration(typeof(IRouteInvoker), this.RouteInvoker),
                new TypeRegistration(typeof(IRequestDispatcher), this.RequestDispatcher),
                new TypeRegistration(typeof(IDiagnostics), this.Diagnostics),
                new TypeRegistration(typeof(IRouteSegmentExtractor), this.RouteSegmentExtractor),
                new TypeRegistration(typeof(IRouteDescriptionProvider), this.RouteDescriptionProvider),
                new TypeRegistration(typeof(ICultureService), this.CultureService),
                new TypeRegistration(typeof(ITextResource), this.TextResource),
                new TypeRegistration(typeof(IResourceAssemblyProvider), this.ResourceAssemblyProvider),
                new TypeRegistration(typeof(IResourceReader), this.ResourceReader),
                new TypeRegistration(typeof(IStaticContentProvider), this.StaticContentProvider),
                new TypeRegistration(typeof(IRouteResolverTrie), this.RouteResolverTrie),
                new TypeRegistration(typeof(ITrieNodeFactory), this.TrieNodeFactory),
                new TypeRegistration(typeof(IRequestTraceFactory), this.RequestTraceFactory),
                new TypeRegistration(typeof(IResponseNegotiator), this.ResponseNegotiator),
                new TypeRegistration(typeof(INancyEnvironmentConfigurator), this.EnvironmentConfigurator),
                new TypeRegistration(typeof(INancyEnvironmentFactory), this.EnvironmentFactory),
                new TypeRegistration(typeof(ISerializerFactory), this.SerializerFactory),
                new TypeRegistration(typeof(IRuntimeEnvironmentInformation), this.RuntimeEnvironmentInformation)
            };
        }

        /// <summary>
        /// Returns the collection configuration types as a CollectionTypeRegistration collection
        /// </summary>
        /// <returns>CollectionTypeRegistration collection representing the configuration types</returns>
        public IEnumerable<CollectionTypeRegistration> GetCollectionTypeRegistrations()
        {
            return new[]
            {
                new CollectionTypeRegistration(typeof(IResponseProcessor), this.ResponseProcessors),
                new CollectionTypeRegistration(typeof(ISerializer), this.Serializers),
                new CollectionTypeRegistration(typeof(IStatusCodeHandler), this.StatusCodeHandlers),
                new CollectionTypeRegistration(typeof(IDiagnosticsProvider), this.InteractiveDiagnosticProviders),
                new CollectionTypeRegistration(typeof(IRouteSegmentConstraint), this.RouteSegmentConstraints),
                new CollectionTypeRegistration(typeof(IRouteMetadataProvider), this.RouteMetadataProviders),
                new CollectionTypeRegistration(typeof(INancyDefaultConfigurationProvider), this.DefaultConfigurationProviders),
            };
        }
    }
}
namespace Nancy.Bootstrapper
{
    using System.Linq;

    /// <summary>
    /// Default implementation of the Nancy pipelines
    /// </summary>
    public class Pipelines : IPipelines
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Pipelines"/> class.
        /// </summary>
        public Pipelines()
        {
            this.AfterRequest = new AfterPipeline();
            this.BeforeRequest = new BeforePipeline();
            this.OnError = new ErrorPipeline();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Pipelines"/> class and clones the hooks from
        /// the provided <see cref="IPipelines"/> instance.
        /// </summary>
        public Pipelines(IPipelines pipelines)
        {
            this.AfterRequest =
                new AfterPipeline(pipelines.AfterRequest.PipelineItems.Count());

            foreach (var pipelineItem in pipelines.AfterRequest.PipelineItems)
            {
                this.AfterRequest.AddItemToEndOfPipeline(pipelineItem);
            }

            this.BeforeRequest =
                new BeforePipeline(pipelines.BeforeRequest.PipelineItems.Count());

            foreach (var pipelineItem in pipelines.BeforeRequest.PipelineItems)
            {
                this.BeforeRequest.AddItemToEndOfPipeline(pipelineItem);
            }

            this.OnError =
                new ErrorPipeline(pipelines.OnError.PipelineItems.Count());

            foreach (var pipelineItem in pipelines.OnError.PipelineItems)
            {
                this.OnError.AddItemToEndOfPipeline(pipelineItem);
            }
        }

        /// <summary>
        /// <para>
        /// The pre-request hook
        /// </para>
        /// <para>
        /// The PreRequest hook is called prior to processing a request. If a hook returns
        /// a non-null response then processing is aborted and the response provided is
        /// returned.
        /// </para>
        /// </summary>
        public BeforePipeline BeforeRequest { get; set; }

        /// <summary>
        /// <para>
        /// The post-request hook
        /// </para>
        /// <para>
        /// The post-request hook is called after the response is created. It can be used
        /// to rewrite the response or add/remove items from the context.
        /// </para>
        /// </summary>
        public AfterPipeline AfterRequest { get; set; }

        /// <summary>
        /// <para>
        /// The error hook
        /// </para>
        /// <para>
        /// The error hook is called if an exception is thrown at any time during the pipeline.
        /// If no error hook exists a standard InternalServerError response is returned
        /// </para>
        /// </summary>
        public ErrorPipeline OnError { get; set; }
    }
}
namespace Nancy.Configuration
{
    using System;
    using System.Collections;
    using System.Collections.Generic;

    /// <summary>
    /// Default implementation of the <see cref="INancyEnvironment"/> interface.
    /// </summary>
    public class DefaultNancyEnvironment : INancyEnvironment
    {
        private readonly IDictionary<string, object> values = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// Returns an enumerator that iterates through the environment.
        /// </summary>
        /// <returns>A <see cref="Dictionary{TKey,TValue}.Enumerator"/> that can be used to iterate through the environment.</returns>
        public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
        {
            return this.values.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the environment.
        /// </summary>
        /// <returns> An <see cref="IEnumerator"/> object that can be used to iterate through the environment.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        /// <summary>
        /// Gets the number of elements in the environment.
        /// </summary>
        /// <returns>The number of elements in the environment.</returns>
        public int Count
        {
            get { return this.values.Count; }
        }

        /// <summary>
        /// Determines whether the environment contains an element that has the specified key.
        /// </summary>
        /// <returns><see langword="true"/> if the environment contains an element that has the specified key; otherwise, <see langword="false"/>.
        /// </returns>
        /// <param name="key">The key to retrieve.</param>
        public bool ContainsKey(string key)
        {
            return this.values.ContainsKey(key);
        }

        /// <summary>
        /// Gets the value that is associated with the specified key.
        /// </summary>
        /// <returns><see langword="true"/> if the environment contains an element that has the specified key; otherwise, <see langword="false"/>.</returns>
        /// <param name="key">The key to locate.</param>
        /// <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
        bool IReadOnlyDictionary<string, object>.TryGetValue(string key, out object value)
        {
            return this.values.TryGetValue(key, out value);
        }

        /// <summary>
        /// Gets the element that has the specified key in the environment.
        /// </summary>
        /// <returns>The element that has the specified key in the environment.</returns>
        /// <param name="key">The key to locate.</param>
        object IReadOnlyDictionary<string, object>.this[string key]
        {
            get { return this.values[key]; }
        }

        /// <summary>
        /// Gets an enumerable collection that contains the keys in the environment.
        /// </summary>
        /// <returns>An enumerable collection that contains the keys in the environment.</returns>
        public IEnumerable<string> Keys
        {
            get { return this.values.Keys; }
        }

        /// <summary>
        /// Gets an enumerable collection that contains the values in the environment.
        /// </summary>
        /// <returns>An enumerable collection that contains the values in the environment.</returns>
        public IEnumerable<object> Values
        {
            get { return this.values.Values; }
        }

        /// <summary>
        /// Adds a <paramref name="value"/>, using a provided <paramref name="key"/>, to the environment.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of the value to add.</typeparam>
        /// <param name="key">The key to store the value as.</param>
        /// <param name="value">The value to store in the environment.</param>
        public void AddValue<T>(string key, T value)
        {
            this.values.Add(key, value);
        }

        /// <summary>
        /// Gets the value that is associated with the specified key.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of the value to retrieve.</typeparam>
        /// <param name="key">The key to get the value for.</param>
        /// <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
        /// <returns><see langword="true" /> if the value could be retrieved, otherwise <see langword="false" />.</returns>
        public bool TryGetValue<T>(string key, out T value)
        {
            object objectValue;

            if (this.values.TryGetValue(key, out objectValue))
            {
                value = (T)objectValue;
                return true;
            }

            value = default(T);
            return false;
        }
    }
}
namespace Nancy.Configuration
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Default implementation of the <see cref="INancyEnvironmentConfigurator"/> interface.
    /// </summary>
    public class DefaultNancyEnvironmentConfigurator : INancyEnvironmentConfigurator
    {
        private readonly INancyEnvironmentFactory factory;
        private readonly IEnumerable<INancyDefaultConfigurationProvider> defaultConfigurationProviders;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultNancyEnvironmentConfigurator"/> class.
        /// </summary>
        /// <param name="factory">The <see cref="INancyEnvironmentFactory"/> instance to use when configuring an environment.</param>
        /// <param name="defaultConfigurationProviders"><see cref="INancyDefaultConfigurationProvider"/> instances that should be used during the configuration of the environment.</param>
        public DefaultNancyEnvironmentConfigurator(INancyEnvironmentFactory factory, IEnumerable<INancyDefaultConfigurationProvider> defaultConfigurationProviders)
        {
            this.factory = factory;
            this.defaultConfigurationProviders = defaultConfigurationProviders;
        }

        /// <summary>
        /// Configures an <see cref="INancyEnvironment"/> instance.
        /// </summary>
        /// <param name="configuration">The configuration to apply to the environment.</param>
        /// <returns>An <see cref="INancyEnvironment"/> instance.</returns>
        public INancyEnvironment ConfigureEnvironment(Action<INancyEnvironment> configuration)
        {
            var environment =
                this.factory.CreateEnvironment();

            configuration.Invoke(environment);

            foreach (var configurationProvider in this.defaultConfigurationProviders)
            {
                var defaultConfiguration =
                    SafeGetDefaultConfiguration(configurationProvider);

                if (defaultConfiguration == null)
                {
                    continue;
                }

                var configurationKey =
                    configurationProvider.Key;

                if (environment.ContainsKey(configurationKey))
                {
                    continue;
                }

                environment.AddValue(configurationKey, defaultConfiguration);
            }

            return environment;
        }

        private static object SafeGetDefaultConfiguration(INancyDefaultConfigurationProvider configurationProvider)
        {
            try
            {
                return configurationProvider.GetDefaultConfiguration();
            }
            catch (ConfigurationException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConfigurationException(string.Format("Error loading default confguration for {0}", configurationProvider.Key), ex);
            }
        }
    }
}
namespace Nancy.Configuration
{
    /// <summary>
    /// Default implementation of the <see cref="INancyEnvironmentFactory"/> interface.
    /// </summary>
    /// <remarks>Creates instances of the <see cref="DefaultNancyEnvironment"/> type.</remarks>
    public class DefaultNancyEnvironmentFactory : INancyEnvironmentFactory
    {
        /// <summary>
        /// Creates a new <see cref="INancyEnvironment"/> instance.
        /// </summary>
        /// <returns>A <see cref="INancyEnvironment"/> instance.</returns>
        public INancyEnvironment CreateEnvironment()
        {
            return new DefaultNancyEnvironment();
        }
    }
}
namespace Nancy.Configuration
{
    /// <summary>
    /// Defines the functionality for providing default configuration values to the <see cref="INancyEnvironment"/>.
    /// </summary>
    public interface INancyDefaultConfigurationProvider : IHideObjectMembers
    {
        /// <summary>
        /// Gets the default configuration instance to register in the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <returns>The configuration instance</returns>
        object GetDefaultConfiguration();

        /// <summary>
        /// Gets the key that will be used to store the configuration object in the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <returns>A <see cref="string"/> containing the key.</returns>
        string Key { get; }
    }
}
namespace Nancy.Configuration
{
    using System;

    /// <summary>
    /// Defines the functionality for applying configuration to an <see cref="INancyEnvironment"/> instance.
    /// </summary>
    public interface INancyEnvironmentConfigurator : IHideObjectMembers
    {
        /// <summary>
        /// Configures an <see cref="INancyEnvironment"/> instance.
        /// </summary>
        /// <param name="configuration">The configuration to apply to the environment.</param>
        /// <returns>An <see cref="INancyEnvironment"/> instance.</returns>
        INancyEnvironment ConfigureEnvironment(Action<INancyEnvironment> configuration);
    }
}
namespace Nancy.Configuration
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Defines the functionality of a Nancy environment.
    /// </summary>
    public interface INancyEnvironment : IReadOnlyDictionary<string, object>, IHideObjectMembers
    {
        /// <summary>
        /// Adds a <paramref name="value"/>, using a provided <paramref name="key"/>, to the environment.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of the value to add.</typeparam>
        /// <param name="key">The key to store the value as.</param>
        /// <param name="value">The value to store in the environment.</param>
        void AddValue<T>(string key, T value);

        /// <summary>
        /// Gets the value that is associated with the specified key.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of the value to retrieve.</typeparam>
        /// <param name="key">The key to get the value for.</param>
        /// <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
        /// <returns><see langword="true" /> if the value could be retrieved, otherwise <see langword="false" />.</returns>
        bool TryGetValue<T>(string key, out T value);
    }
}
namespace Nancy.Configuration
{
    /// <summary>
    /// Defines the functionality for creating a <see cref="INancyEnvironment"/> instance.
    /// </summary>
    public interface INancyEnvironmentFactory : IHideObjectMembers
    {
        /// <summary>
        /// Creates a new <see cref="INancyEnvironment"/> instance.
        /// </summary>
        /// <returns>A <see cref="INancyEnvironment"/> instance.</returns>
        INancyEnvironment CreateEnvironment();
    }
}
namespace Nancy.Configuration
{
    using System;

    /// <summary>
    /// Contains extensions for the <see cref="INancyEnvironment"/> type.
    /// </summary>
    public static class INancyEnvironmentExtensions
    {
        /// <summary>
        /// Adds a value to the environment, using the full name of the type defined by <typeparamref name="T"/> as the key.
        /// </summary>
        /// <param name="environment">The <see cref="INancyEnvironment"/> instance.</param>
        /// <param name="value">The value to store in the environment.</param>
        /// <typeparam name="T">The <see cref="Type"/> of the value to store in the environment.</typeparam>
        public static void AddValue<T>(this INancyEnvironment environment, T value)
        {
            environment.AddValue(typeof(T).FullName, value);
        }

        /// <summary>
        /// Gets a value from the environment, using the full name of the type defined by <typeparamref name="T"/> as the key.
        /// </summary>
        /// <param name="environment">The <see cref="INancyEnvironment"/> instance.</param>
        /// <typeparam name="T">The <see cref="Type"/> of the value to retreive from the environment.</typeparam>
        /// <returns></returns>
        public static T GetValue<T>(this INancyEnvironment environment)
        {
            return environment.GetValue<T>(typeof(T).FullName);
        }

        /// <summary>
        /// Gets a value from the environment, using the provided <paramref name="key"/>.
        /// </summary>
        /// <param name="environment">The <see cref="INancyEnvironment"/> instance.</param>
        /// <param name="key">The key to retrieve the value for.</param>
        /// <typeparam name="T">The <see cref="Type"/> of the value to retreive from the environment.</typeparam>
        /// <returns>The stored value.</returns>
        public static T GetValue<T>(this INancyEnvironment environment, string key)
        {
            return (T)environment[key];
        }

        /// <summary>
        /// Gets a value from the environment, using the full name of the type defined by <typeparamref name="T"/> as the key. If
        /// the value could not be found, then a provided default value is returned.
        /// </summary>
        /// <param name="environment">The <see cref="INancyEnvironment"/> instance.</param>
        /// <param name="defaultValue">The value to return if no stored value could be found.</param>
        /// <typeparam name="T">The <see cref="Type"/> of the value to retreive from the environment.</typeparam>
        /// <returns>The stored value.</returns>
        public static T GetValueWithDefault<T>(this INancyEnvironment environment, T defaultValue)
        {
            T value;
            return environment.TryGetValue(typeof(T).FullName, out value) ? value : defaultValue;
        }

        /// <summary>
        /// Gets a value from the environment, using the provided <paramref name="key"/>. If the value could not be found, then
        /// a provided default value is returned.
        /// </summary>
        /// <param name="environment">The <see cref="INancyEnvironment"/> instance.</param>
        /// <param name="key">The key to retrieve the value for.</param>
        /// <param name="defaultValue">The value to return if no stored value could be found.</param>
        /// <typeparam name="T">The <see cref="Type"/> of the value to retreive from the environment.</typeparam>
        /// <returns>The stored value.</returns>
        public static T GetValueWithDefault<T>(this INancyEnvironment environment, string key, T defaultValue)
        {
            T value;
            return environment.TryGetValue(key, out value) ? value : defaultValue;
        }
    }
}
namespace Nancy.Configuration
{
    /// <summary>
    /// Default (abstract) implementation of <see cref="INancyDefaultConfigurationProvider" /> interface.
    /// </summary>
    /// <typeparam name="T">The type of the configuration object.</typeparam>
    public abstract class NancyDefaultConfigurationProvider<T> : INancyDefaultConfigurationProvider
    {
        /// <summary>
        /// Gets the default configuration instance to register in the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <returns>The configuration instance</returns>
        public abstract T GetDefaultConfiguration();

        /// <summary>
        /// Gets the default configuration instance to register in the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <returns>The configuration instance</returns>
        object INancyDefaultConfigurationProvider.GetDefaultConfiguration()
        {
            return this.GetDefaultConfiguration();
        }

        /// <summary>
        /// Gets the full type name of <typeparamref name="T"/>.
        /// </summary>
        /// <returns>A <see cref="string"/> containing the key.</returns>
        public virtual string Key
        {
            get { return typeof(T).FullName; }
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections;
    using System.Collections.Generic;

    /// <summary>
    /// Collection of accept header coercions
    /// </summary>
    public class AcceptHeaderCoercionConventions : IEnumerable<Func<IEnumerable<Tuple<string, decimal>>, NancyContext, IEnumerable<Tuple<string, decimal>>>>
    {
        private readonly IList<Func<IEnumerable<Tuple<string, decimal>>, NancyContext, IEnumerable<Tuple<string, decimal>>>> conventions;

        public AcceptHeaderCoercionConventions(IList<Func<IEnumerable<Tuple<string, decimal>>, NancyContext, IEnumerable<Tuple<string, decimal>>>> conventions)
        {
            this.conventions = conventions;
        }

        public IEnumerator<Func<IEnumerable<Tuple<string, decimal>>, NancyContext, IEnumerable<Tuple<string, decimal>>>> GetEnumerator()
        {
            return this.conventions.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Built in functions for coercing accept headers.
    /// <seealso cref="DefaultAcceptHeaderCoercionConventions"/>
    /// </summary>
    public static class BuiltInAcceptHeaderCoercions
    {
        private const string HtmlContentType = "text/html";

        private static readonly IEnumerable<Tuple<string, decimal>> DefaultAccept = new[] { Tuple.Create(HtmlContentType, 1.0m), Tuple.Create("*/*", 0.9m) };

        private static readonly string[] BrokenBrowsers = new[] { "MSIE 8", "MSIE 7", "MSIE 6", "AppleWebKit" };

        /// <summary>
        /// Adds a default accept header if there isn't one.
        /// </summary>
        /// <param name="currentAcceptHeaders">Current headers</param>
        /// <param name="context">Context</param>
        /// <returns>Modified headers or original if no modification required</returns>
        public static IEnumerable<Tuple<string, decimal>> CoerceBlankAcceptHeader(IEnumerable<Tuple<string, decimal>> currentAcceptHeaders, NancyContext context)
        {
            var current = currentAcceptHeaders as Tuple<string, decimal>[] ?? currentAcceptHeaders.ToArray();

            return !current.Any() ? DefaultAccept : current;
        }

        /// <summary>
        /// Replaces the accept header of stupid browsers that request XML instead
        /// of HTML.
        /// </summary>
        /// <param name="currentAcceptHeaders">Current headers</param>
        /// <param name="context">Context</param>
        /// <returns>Modified headers or original if no modification required</returns>
        public static IEnumerable<Tuple<string, decimal>> CoerceStupidBrowsers(IEnumerable<Tuple<string, decimal>> currentAcceptHeaders, NancyContext context)
        {
            var current = currentAcceptHeaders as Tuple<string, decimal>[] ?? currentAcceptHeaders.ToArray();

            return IsStupidBrowser(current, context) ? DefaultAccept : current;
        }

        /// <summary>
        /// Boosts the priority of HTML for browsers that ask for xml and html with the
        /// same priority.
        /// </summary>
        /// <param name="currentAcceptHeaders">Current headers</param>
        /// <param name="context">Context</param>
        /// <returns>Modified headers or original if no modification required</returns>
        public static IEnumerable<Tuple<string, decimal>> BoostHtml(IEnumerable<Tuple<string, decimal>> currentAcceptHeaders, NancyContext context)
        {
            var current = currentAcceptHeaders as Tuple<string, decimal>[] ?? currentAcceptHeaders.ToArray();

            var html = current.FirstOrDefault(h => string.Equals(h.Item1, HtmlContentType, StringComparison.OrdinalIgnoreCase) && h.Item2 < 1.0m);

            if (html == null)
            {
                return current;
            }

            var index = Array.IndexOf(current, html);
            if (index == -1)
            {
                return current;
            }

            current[index] = Tuple.Create(HtmlContentType, html.Item2 + 0.2m);

            return current.OrderByDescending(x => x.Item2).ToArray();
        }

        private static bool IsStupidBrowser(Tuple<string, decimal>[] current, NancyContext context)
        {
            // If there's one or less accept headers then we can't be a stupid
            // browser so just bail out early
            if (current.Length <= 1)
            {
                return false;
            }

            var maxScore = current.First().Item2;

            if (IsPotentiallyBrokenBrowser(context.Request.Headers.UserAgent)
                && !current.Any(h => h.Item2 == maxScore && string.Equals(HtmlContentType, h.Item1, StringComparison.OrdinalIgnoreCase)))
            {
                return true;
            }

            return false;
        }

        private static bool IsPotentiallyBrokenBrowser(string userAgent)
        {
            return BrokenBrowsers.Any(userAgent.Contains);
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;
    using System.Threading;
    using Nancy.Configuration;
    using Nancy.Session;

    /// <summary>
    /// Built in functions for determining current culture
    /// <seealso cref="DefaultCultureConventions"/>
    /// </summary>
    public static class BuiltInCultureConventions
    {
        /// <summary>
        /// Checks to see if the Form has a CurrentCulture key.
        /// </summary>
        /// <param name="context">NancyContext</param>
        /// <param name="configuration">Culture configuration that contains allowed cultures</param>
        /// <returns>CultureInfo if found in Form otherwise null</returns>
        public static CultureInfo FormCulture(NancyContext context, GlobalizationConfiguration configuration)
        {
            if (context.Request.Form["CurrentCulture"] != null)
            {
                string cultureLetters = context.Request.Form["CurrentCulture"];

                if (!IsValidCultureInfoName(cultureLetters, configuration))
                {
                    return null;
                }

                return new CultureInfo(cultureLetters);
            }

            return null;
        }

        /// <summary>
        /// Checks to see if the first argument in the Path can be used to make a CultureInfo.
        /// </summary>
        /// <param name="context">NancyContext</param>
        /// <param name="configuration">Culture configuration that contains allowed cultures</param>
        /// <returns>CultureInfo if found in Path otherwise null</returns>
        public static CultureInfo PathCulture(NancyContext context, GlobalizationConfiguration configuration)
        {
            var segments =
                context.Request.Url.Path.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries);

            var firstSegment =
                segments.FirstOrDefault();

            if (firstSegment != null && IsValidCultureInfoName(firstSegment, configuration))
            {
                context.Request.Url.Path =
                    string.Concat("/", string.Join("/", segments.Skip(1)));

                return new CultureInfo(firstSegment);
            }

            return null;
        }

        /// <summary>
        /// Checks to see if the AcceptLanguage in the Headers can be used to make a CultureInfo. Uses highest weighted if multiple defined.
        /// </summary>
        /// <param name="context">NancyContext</param>
        /// <param name="configuration">Culture configuration that contains allowed cultures</param>
        /// <returns>CultureInfo if found in Headers otherwise null</returns>
        public static CultureInfo HeaderCulture(NancyContext context, GlobalizationConfiguration configuration)
        {
            if (context.Request.Headers.AcceptLanguage.Any())
            {
                var cultureLetters = context.Request.Headers.AcceptLanguage.First().Item1;

                if (!IsValidCultureInfoName(cultureLetters, configuration))
                {
                    return null;
                }

                return new CultureInfo(cultureLetters);
            }

            return null;
        }

        /// <summary>
        /// Checks to see if the Session has a CurrentCulture key
        /// </summary>
        /// <param name="context">NancyContext</param>
        /// <param name="configuration">Culture configuration that contains allowed cultures</param>
        /// <returns>CultureInfo if found in Session otherwise null</returns>
        public static CultureInfo SessionCulture(NancyContext context, GlobalizationConfiguration configuration)
        {
            var sessionType = context.Request.Session as NullSessionProvider;
            if (sessionType == null && context.Request.Session["CurrentCulture"] != null)
            {
                return (CultureInfo)context.Request.Session["CurrentCulture"];
            }

            return null;
        }

        /// <summary>
        /// Checks to see if the Cookies has a CurrentCulture key
        /// </summary>
        /// <param name="context">NancyContext</param>
        /// <param name="configuration">Culture configuration that contains allowed cultures</param>
        /// <returns>CultureInfo if found in Cookies otherwise null</returns>
        public static CultureInfo CookieCulture(NancyContext context, GlobalizationConfiguration configuration)
        {
            string cookieCulture = null;

            if (context.Request.Cookies.TryGetValue("CurrentCulture", out cookieCulture))
            {
                if (!IsValidCultureInfoName(cookieCulture, configuration))
                {
                    return null;
                }

                return new CultureInfo(cookieCulture);
            }

            return null;
        }
        /// <summary>
        /// Checks to see if a default culture has been set on <see cref="GlobalizationConfiguration"/>
        /// </summary>
        /// <param name="context">NancyContext</param>
        /// <param name="configuration">Culture configuration that contains allowed cultures</param>
        /// <returns>CultureInfo if found in <see cref="GlobalizationConfiguration"/> Default Culture else null</returns>
        public static CultureInfo GlobalizationConfigurationCulture(NancyContext context, GlobalizationConfiguration configuration)
        {
            if (configuration.DefaultCulture != null)
            {
                if (!IsValidCultureInfoName(configuration.DefaultCulture, configuration))
                {
                    return null;
                }

                return new CultureInfo(configuration.DefaultCulture);
            }

            return null;
        }

        /// <summary>
        /// Validates culture name
        /// </summary>
        /// <param name="name">Culture name eg\en-GB</param>
        /// <param name="configuration">Culture configuration that contains allowed cultures</param>
        /// <returns>True/False if valid culture</returns>
        public static bool IsValidCultureInfoName(string name, GlobalizationConfiguration configuration)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                return false;
            }

            return configuration.SupportedCultureNames.Contains(name);
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Globalization;

    /// <summary>
    /// Collection class for static culture conventions
    /// </summary>
    public class CultureConventions : IEnumerable<Func<NancyContext, GlobalizationConfiguration, CultureInfo>>
    {
        private readonly IEnumerable<Func<NancyContext, GlobalizationConfiguration, CultureInfo>> conventions;

        /// <summary>
        /// Creates a new instance of CultureConventions
        /// </summary>
        /// <param name="conventions"></param>
        public CultureConventions(IEnumerable<Func<NancyContext, GlobalizationConfiguration, CultureInfo>> conventions)
        {
            this.conventions = conventions;
        }

        public IEnumerator<Func<NancyContext, GlobalizationConfiguration, CultureInfo>> GetEnumerator()
        {
            return conventions.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Wires up the default conventions for the accept header coercion
    /// </summary>
    public class DefaultAcceptHeaderCoercionConventions : IConvention
    {
        public void Initialise(NancyConventions conventions)
        {
            this.ConfigureDefaultConventions(conventions);
        }

        public Tuple<bool, string> Validate(NancyConventions conventions)
        {
            if (conventions.AcceptHeaderCoercionConventions == null)
            {
                return Tuple.Create(false, "The accept header coercion conventions cannot be null.");
            }

            return Tuple.Create(true, string.Empty);
        }

        private void ConfigureDefaultConventions(NancyConventions conventions)
        {
            conventions.AcceptHeaderCoercionConventions = new List<Func<IEnumerable<Tuple<string, decimal>>, NancyContext, IEnumerable<Tuple<string, decimal>>>>(2)
                                                              {
                                                                  BuiltInAcceptHeaderCoercions.BoostHtml,
                                                                  BuiltInAcceptHeaderCoercions.CoerceBlankAcceptHeader,
                                                              };
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;

    /// <summary>
    /// Default implementation of <see cref="IConvention"/>
    /// </summary>
    public class DefaultCultureConventions : IConvention
    {
        /// <summary>
        /// Initialise culture conventions
        /// </summary>
        /// <param name="conventions"></param>
        public void Initialise(NancyConventions conventions)
        {
            ConfigureDefaultConventions(conventions);
        }

        /// <summary>
        /// Determine if culture conventions are valid
        /// </summary>
        /// <param name="conventions"></param>
        /// <returns></returns>
        public Tuple<bool, string> Validate(NancyConventions conventions)
        {
            if (conventions.CultureConventions == null)
            {
                return Tuple.Create(false, "The culture conventions cannot be null.");
            }

            return (conventions.CultureConventions.Count > 0) ?
               Tuple.Create(true, string.Empty) :
               Tuple.Create(false, "The culture conventions cannot be empty.");
        }

        /// <summary>
        /// Setup default conventions
        /// </summary>
        /// <param name="conventions"></param>
        private static void ConfigureDefaultConventions(NancyConventions conventions)
        {
            conventions.CultureConventions = new List<Func<NancyContext, GlobalizationConfiguration, CultureInfo>>
            {
                BuiltInCultureConventions.FormCulture,
                BuiltInCultureConventions.HeaderCulture,
                BuiltInCultureConventions.SessionCulture,
                BuiltInCultureConventions.CookieCulture,
                BuiltInCultureConventions.GlobalizationConfigurationCulture,
            };
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Defines the default static contents conventions.
    /// </summary>
    public class DefaultStaticContentsConventions : IConvention
    {
        /// <summary>
        /// Initialise any conventions this class "owns".
        /// </summary>
        /// <param name="conventions">Convention object instance.</param>
        public void Initialise(NancyConventions conventions)
        {
            conventions.StaticContentsConventions = new List<Func<NancyContext, string, Response>>
            {
                StaticContentConventionBuilder.AddDirectory("Content")
            };
        }

        /// <summary>
        /// Asserts that the conventions that this class "owns" are valid
        /// </summary>
        /// <param name="conventions">Conventions object instance.</param>
        /// <returns>Tuple containing true/false for valid/invalid, and any error messages.</returns>
        public Tuple<bool, string> Validate(NancyConventions conventions)
        {
            if (conventions.StaticContentsConventions == null)
            {
                return Tuple.Create(false, "The static contents conventions cannot be null.");
            }

            return (conventions.StaticContentsConventions.Count > 0) ?
                Tuple.Create(true, string.Empty) :
                Tuple.Create(false, "The static contents conventions cannot be empty.");
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections.Generic;

    using Nancy.ViewEngines;

    /// <summary>
    /// Defines the default static contents conventions.
    /// </summary>
    public class DefaultViewLocationConventions : IConvention
    {
        /// <summary>
        /// Initialise any conventions this class "owns".
        /// </summary>
        /// <param name="conventions">Convention object instance.</param>
        public void Initialise(NancyConventions conventions)
        {
            ConfigureViewLocationConventions(conventions);
        }

        /// <summary>
        /// Asserts that the conventions that this class "owns" are valid.
        /// </summary>
        /// <param name="conventions">Conventions object instance.</param>
        /// <returns>Tuple containing true/false for valid/invalid, and any error messages.</returns>
        public Tuple<bool, string> Validate(NancyConventions conventions)
        {
            if (conventions.ViewLocationConventions == null)
            {
                return Tuple.Create(false, "The view conventions cannot be null.");
            }

            return (conventions.ViewLocationConventions.Count > 0) ?
                Tuple.Create(true, string.Empty) :
                Tuple.Create(false, "The view conventions cannot be empty.");
        }

        private static void ConfigureViewLocationConventions(NancyConventions conventions)
        {
            conventions.ViewLocationConventions = new List<Func<string, object, ViewLocationContext, string>>
            {
                (viewName, model, viewLocationContext) =>{
                    if (string.IsNullOrEmpty(viewLocationContext.ModulePath))
                    {
                        return string.Empty;
                    }

                    var path = viewLocationContext.ModulePath.TrimStart(new[] { '/' });

                    return string.Concat("views/", path, "/", viewLocationContext.ModuleName, "/", viewName, "-", viewLocationContext.Context.Culture);
                },

                // 0 Handles: views / *modulepath* / *modulename* / *viewname*
                (viewName, model, viewLocationContext) =>{
                    if (string.IsNullOrEmpty(viewLocationContext.ModulePath))
                    {
                        return string.Empty;
                    }

                    var path = viewLocationContext.ModulePath.TrimStart(new[] { '/' });

                    return  string.Concat("views/", path, "/", viewLocationContext.ModuleName, "/", viewName);
                },

                (viewName, model, viewLocationContext) =>{
                    if (string.IsNullOrEmpty(viewLocationContext.ModulePath))
                    {
                        return string.Empty;
                    }

                    var path = viewLocationContext.ModulePath.TrimStart(new[] { '/' });

                    return string.Concat(path, "/", viewLocationContext.ModuleName, "/", viewName, "-", viewLocationContext.Context.Culture);
                },

                // 1 Handles: *modulepath* / *modulename* / *viewname*
                (viewName, model, viewLocationContext) =>{
                    if (string.IsNullOrEmpty(viewLocationContext.ModulePath))
                    {
                        return string.Empty;
                    }

                    var path = viewLocationContext.ModulePath.TrimStart(new[] { '/' });

                    return  string.Concat(path, "/", viewLocationContext.ModuleName, "/", viewName);
                },

                (viewName, model, viewLocationContext) =>{
                    return string.IsNullOrEmpty(viewLocationContext.ModulePath) ? string.Empty : string.Concat("views/", viewLocationContext.ModulePath.TrimStart(new[] { '/' }), "/", viewName, "-", viewLocationContext.Context.Culture);
                },

                // 2 Handles: views / *modulepath* / *viewname*
                (viewName, model, viewLocationContext) =>{
                    return string.IsNullOrEmpty(viewLocationContext.ModulePath) ? string.Empty : string.Concat("views/", viewLocationContext.ModulePath.TrimStart(new[] {'/'}), "/", viewName);
                },

                (viewName, model, viewLocationContext) =>{
                    return string.IsNullOrEmpty(viewLocationContext.ModulePath) ? string.Empty : string.Concat(viewLocationContext.ModulePath.TrimStart(new[] { '/' }), "/", viewName, "-", viewLocationContext.Context.Culture);
                },

                // 3 Handles: *modulepath* / *viewname*
                (viewName, model, viewLocationContext) =>{
                    return string.IsNullOrEmpty(viewLocationContext.ModulePath) ? string.Empty : string.Concat(viewLocationContext.ModulePath.TrimStart(new[] { '/' }), "/", viewName);
                },

                (viewName, model, viewLocationContext) => {
                    return string.Concat("views/", viewLocationContext.ModuleName, "/", viewName, "-", viewLocationContext.Context.Culture);
                },

                // 4 Handles: views / *modulename* / *viewname*
                (viewName, model, viewLocationContext) => {
                    return string.Concat("views/", viewLocationContext.ModuleName, "/", viewName);
                },

                (viewName, model, viewLocationContext) => {
                    return string.Concat(viewLocationContext.ModuleName, "/", viewName, "-", viewLocationContext.Context.Culture);
                },

                // 5 Handles: *modulename* / *viewname*
                (viewName, model, viewLocationContext) => {
                    return string.Concat(viewLocationContext.ModuleName, "/", viewName);
                },

                (viewName, model, viewLocationContext) => {
                    return string.Concat("views/", viewName, "-", viewLocationContext.Context.Culture);
                },

                // 6 Handles: views / *viewname*
                (viewName, model, viewLocationContext) => {
                    return string.Concat("views/", viewName);
                },

                (viewName, model, viewLocationContext) => {
                    return string.Concat(viewName, "-", viewLocationContext.Context.Culture);
                },

                // 7 Handles: *viewname*
                (viewName, model, viewLocationContext) => {
                    return viewName;
                }
            };
        }
    }
}
namespace Nancy.Conventions
{
    using System;

    /// <summary>
    /// Provides Nancy convention defaults and validation
    /// </summary>
    public interface IConvention
    {
        /// <summary>
        /// Initialise any conventions this class "owns"
        /// </summary>
        /// <param name="conventions">Convention object instance</param>
        void Initialise(NancyConventions conventions);

        /// <summary>
        /// Asserts that the conventions that this class "owns" are valid
        /// </summary>
        /// <param name="conventions">Conventions object instance</param>
        /// <returns>Tuple containing true/false for valid/invalid, and any error messages</returns>
        Tuple<bool, string> Validate(NancyConventions conventions);
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;
    using System.Text;

    using Nancy.Bootstrapper;
    using Nancy.ViewEngines;

    /// <summary>
    /// Nancy configurable conventions
    /// </summary>
    public class NancyConventions
    {
        private readonly ITypeCatalog typeCatalog;
        private IEnumerable<IConvention> conventions;

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyConventions"/> class.
        /// </summary>
        public NancyConventions(ITypeCatalog typeCatalog)
        {
            this.typeCatalog = typeCatalog;
            this.BuildDefaultConventions();
        }

        /// <summary>
        /// Gets or sets the conventions for locating view templates
        /// </summary>
        public IList<Func<string, dynamic, ViewLocationContext, string>> ViewLocationConventions { get; set; }

        /// <summary>
        /// Gets or sets the conventions for locating and serving static content
        /// </summary>
        public IList<Func<NancyContext, string, Response>> StaticContentsConventions { get; set; }

        /// <summary>
        /// Gets or sets the conventions for coercing accept headers from their source
        /// values to the real values for content negotiation
        /// <seealso cref="BuiltInAcceptHeaderCoercions"/>
        /// </summary>
        public IList<Func<IEnumerable<Tuple<string, decimal>>, NancyContext, IEnumerable<Tuple<string, decimal>>>> AcceptHeaderCoercionConventions { get; set; }

        /// <summary>
        /// Gets or sets the conventions for determining request culture
        /// </summary>
        public IList<Func<NancyContext, GlobalizationConfiguration, CultureInfo>> CultureConventions { get; set; }

        /// <summary>
        /// Validates the conventions
        /// </summary>
        /// <returns>A tuple containing a flag indicating validity, and any error messages</returns>
        public Tuple<bool, string> Validate()
        {
            var isValid = true;
            var errorMessageBuilder = new StringBuilder();

            foreach (var result in this.conventions.Select(convention => convention.Validate(this)).Where(result => !result.Item1))
            {
                isValid = false;
                errorMessageBuilder.AppendLine(result.Item2);
            }

            return new Tuple<bool, string>(isValid, errorMessageBuilder.ToString());
        }

        /// <summary>
        /// Gets the instance registrations for registering into the container
        /// </summary>
        /// <returns>Enumeration of InstanceRegistration types</returns>
        public IEnumerable<InstanceRegistration> GetInstanceRegistrations()
        {
            return new[]
            {
                new InstanceRegistration(typeof(ViewLocationConventions), new ViewLocationConventions(this.ViewLocationConventions)),
                new InstanceRegistration(typeof(StaticContentsConventions), new StaticContentsConventions(this.StaticContentsConventions)),
                new InstanceRegistration(typeof(AcceptHeaderCoercionConventions), new AcceptHeaderCoercionConventions(this.AcceptHeaderCoercionConventions)),
                new InstanceRegistration(typeof(CultureConventions), new CultureConventions(this.CultureConventions))
            };
        }

        /// <summary>
        /// Locates all the default conventions and calls them in
        /// turn to build up the default conventions.
        /// </summary>
        private void BuildDefaultConventions()
        {
            var defaultConventions =
                this.typeCatalog.GetTypesAssignableTo<IConvention>(TypeResolveStrategies.OnlyNancy);

            this.conventions = defaultConventions
                .Union(this.typeCatalog.GetTypesAssignableTo<IConvention>(TypeResolveStrategies.ExcludeNancy))
                .Select(t => (IConvention)Activator.CreateInstance(t));

            foreach (var convention in this.conventions)
            {
                convention.Initialise(this);
            }
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections.Concurrent;
    using System.IO;
    using System.Linq;
    using System.Text.RegularExpressions;

    using Nancy.Helpers;
    using Nancy.Responses;

    /// <summary>
    /// Helper class for defining directory-based conventions for static contents.
    /// </summary>
    public class StaticContentConventionBuilder
    {
        private static readonly ConcurrentDictionary<ResponseFactoryCacheKey, Func<NancyContext, Response>> ResponseFactoryCache;
        private static readonly Regex PathReplaceRegex = new Regex(@"[/\\]", RegexOptions.Compiled);

        static StaticContentConventionBuilder()
        {
            ResponseFactoryCache = new ConcurrentDictionary<ResponseFactoryCacheKey, Func<NancyContext, Response>>();
        }

        /// <summary>
        /// Adds a directory-based convention for static convention.
        /// </summary>
        /// <param name="requestedPath">The path that should be matched with the request.</param>
        /// <param name="contentPath">The path to where the content is stored in your application, relative to the root. If this is <see langword="null" /> then it will be the same as <paramref name="requestedPath"/>.</param>
        /// <param name="allowedExtensions">A list of extensions that is valid for the conventions. If not supplied, all extensions are valid.</param>
        /// <returns>A <see cref="GenericFileResponse"/> instance for the requested static contents if it was found, otherwise <see langword="null"/>.</returns>
        public static Func<NancyContext, string, Response> AddDirectory(string requestedPath, string contentPath = null, params string[] allowedExtensions)
        {
            if (!requestedPath.StartsWith("/"))
            {
                requestedPath = string.Concat("/", requestedPath);
            }

            return (ctx, root) =>
            {
                var path =
                    HttpUtility.UrlDecode(ctx.Request.Path);

                var fileName = GetSafeFileName(path);

                if (string.IsNullOrEmpty(fileName))
                {
                    return null;
                }

                var pathWithoutFilename =
                    GetPathWithoutFilename(fileName, path);

                if (!pathWithoutFilename.StartsWith(requestedPath, StringComparison.OrdinalIgnoreCase))
                {
                    (ctx.Trace.TraceLog ?? new NullLog()).WriteLog(x => x.AppendLine(string.Concat("[StaticContentConventionBuilder] The requested resource '", path, "' does not match convention mapped to '", requestedPath, "'")));
                    return null;
                }

                contentPath =
                    GetContentPath(requestedPath, contentPath);

                if (contentPath.Equals("/"))
                {
                    throw new ArgumentException("This is not the security vulnerability you are looking for. Mapping static content to the root of your application is not a good idea.");
                }

                var responseFactory =
                    ResponseFactoryCache.GetOrAdd(new ResponseFactoryCacheKey(path, root), BuildContentDelegate(ctx, root, requestedPath, contentPath, allowedExtensions));

                return responseFactory.Invoke(ctx);
            };
        }

        /// <summary>
        /// Adds a file-based convention for static convention.
        /// </summary>
        /// <param name="requestedFile">The file that should be matched with the request.</param>
        /// <param name="contentFile">The file that should be served when the requested path is matched.</param>
        public static Func<NancyContext, string, Response> AddFile(string requestedFile, string contentFile)
        {
            return (ctx, root) =>
            {

                var path =
                    ctx.Request.Path;

                if (!path.Equals(requestedFile, StringComparison.OrdinalIgnoreCase))
                {
                    ctx.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[StaticContentConventionBuilder] The requested resource '", path, "' does not match convention mapped to '", requestedFile, "'")));
                    return null;
                }

                var responseFactory =
                    ResponseFactoryCache.GetOrAdd(new ResponseFactoryCacheKey(path, root), BuildContentDelegate(ctx, root, requestedFile, contentFile, ArrayCache.Empty<string>()));

                return responseFactory.Invoke(ctx);
            };
        }

        private static string GetSafeFileName(string path)
        {
            try
            {
                return Path.GetFileName(path);
            }
            catch (Exception)
            {
            }

            return null;
        }

        private static string GetContentPath(string requestedPath, string contentPath)
        {
            contentPath =
                contentPath ?? requestedPath;

            if (!contentPath.StartsWith("/"))
            {
                contentPath = string.Concat("/", contentPath);
            }

            return contentPath;
        }

        private static Func<ResponseFactoryCacheKey, Func<NancyContext, Response>> BuildContentDelegate(NancyContext context, string applicationRootPath, string requestedPath, string contentPath, string[] allowedExtensions)
        {
            return pathAndRootPair =>
            {
                context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[StaticContentConventionBuilder] Attempting to resolve static content '", pathAndRootPair, "'")));

                var extension =
                    Path.GetExtension(pathAndRootPair.Path);

                if (!string.IsNullOrEmpty(extension))
                {
                    extension = extension.Substring(1);
                }

                if (allowedExtensions.Length != 0 && !allowedExtensions.Any(e => string.Equals(e.TrimStart(new[] { '.' }), extension, StringComparison.OrdinalIgnoreCase)))
                {
                    context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[StaticContentConventionBuilder] The requested extension '", extension, "' does not match any of the valid extensions for the convention '", string.Join(",", allowedExtensions), "'")));
                    return ctx => null;
                }

                var transformedRequestPath =
                    GetSafeRequestPath(pathAndRootPair.Path, requestedPath, contentPath);

                transformedRequestPath =
                    GetEncodedPath(transformedRequestPath);

                var fileName =
                    Path.GetFullPath(Path.Combine(applicationRootPath, transformedRequestPath));

                var contentRootPath =
                    Path.GetFullPath(Path.Combine(applicationRootPath, GetEncodedPath(contentPath)));

                if (!IsWithinContentFolder(contentRootPath, fileName))
                {
                    context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[StaticContentConventionBuilder] The request '", fileName, "' is trying to access a path outside the content folder '", contentPath, "'")));
                    return ctx => null;
                }

                if (!File.Exists(fileName))
                {
                    context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[StaticContentConventionBuilder] The requested file '", fileName, "' does not exist")));
                    return ctx => null;
                }

                context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[StaticContentConventionBuilder] Returning file '", fileName, "'")));
                return ctx => new GenericFileResponse(fileName, ctx);
            };
        }

        private static string GetEncodedPath(string path)
        {
            return PathReplaceRegex.Replace(path.TrimStart(new[] { '/' }), Path.DirectorySeparatorChar.ToString());
        }

        private static string GetPathWithoutFilename(string fileName, string path)
        {
            var pathWithoutFileName =
                path.Replace(fileName, string.Empty);

            return (pathWithoutFileName.Equals("/")) ?
                pathWithoutFileName :
                pathWithoutFileName.TrimEnd(new[] { '/' });
        }

        private static string GetSafeRequestPath(string requestPath, string requestedPath, string contentPath)
        {
            var actualContentPath =
                (contentPath.Equals("/") ? string.Empty : contentPath);

            if (requestedPath.Equals("/"))
            {
                return string.Concat(actualContentPath, requestPath);
            }

            var expression =
                new Regex(Regex.Escape(requestedPath), RegexOptions.IgnoreCase);

            return expression.Replace(requestPath, actualContentPath, 1);
        }

        /// <summary>
        /// Returns whether the given filename is contained within the content folder
        /// </summary>
        /// <param name="contentRootPath">Content root path</param>
        /// <param name="fileName">Filename requested</param>
        /// <returns>True if contained within the content root, false otherwise</returns>
        private static bool IsWithinContentFolder(string contentRootPath, string fileName)
        {
            return fileName.StartsWith(contentRootPath, StringComparison.Ordinal);
        }

        /// <summary>
        /// Used to uniquely identify a request. Needed for when two Nancy applications want to serve up static content of the same
        /// name from within the same AppDomain.
        /// </summary>
        private class ResponseFactoryCacheKey : IEquatable<ResponseFactoryCacheKey>
        {
            private readonly string path;
            private readonly string rootPath;

            public ResponseFactoryCacheKey(string path, string rootPath)
            {
                this.path = path;
                this.rootPath = rootPath;
            }

            /// <summary>
            /// The path of the static content for which this response is being issued
            /// </summary>
            public string Path
            {
                get { return this.path; }
            }

            /// <summary>
            /// The root folder path of the Nancy application for which this response will be issued
            /// </summary>
            public string RootPath
            {
                get { return this.rootPath; }
            }

            public bool Equals(ResponseFactoryCacheKey other)
            {
                if (ReferenceEquals(null, other))
                {
                    return false;
                }

                if (ReferenceEquals(this, other))
                {
                    return true;
                }

                return string.Equals(this.path, other.path) && string.Equals(this.rootPath, other.rootPath);
            }

            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj))
                {
                    return false;
                }

                if (ReferenceEquals(this, obj))
                {
                    return true;
                }

                if (obj.GetType() != this.GetType())
                {
                    return false;
                }

                return Equals((ResponseFactoryCacheKey)obj);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    return ((this.path != null ? this.path.GetHashCode() : 0) * 397) ^ (this.rootPath != null ? this.rootPath.GetHashCode() : 0);
                }
            }
        }
    }
}
namespace Nancy.Conventions
{
    using System;

    /// <summary>
    /// Nancy static convention helper
    /// </summary>
    public static class StaticContentHelper
    {
        /// <summary>
        /// Extension method for NancyConventions
        /// <code>
        /// conventions.MapStaticContent((File, Directory) =>
        /// {
        ///     File["/page.js"] = "page.js";
        ///     Directory["/images"] = "images";
        /// });
        /// </code>
        /// </summary>
        /// <param name="conventions">The conventions to add to.</param>
        /// <param name="staticConventions">The callback method allows you to describe the static content</param>
        public static void MapStaticContent(this NancyConventions conventions, Action<StaticFileContent, StaticDirectoryContent> staticConventions)
        {
            staticConventions(new StaticFileContent(conventions), new StaticDirectoryContent(conventions));
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections;
    using System.Collections.Generic;

    /// <summary>
    /// Collection class for static content conventions
    /// </summary>
    public class StaticContentsConventions : IEnumerable<Func<NancyContext, string, Response>>
    {
        private readonly IEnumerable<Func<NancyContext, string, Response>> conventions;

        public StaticContentsConventions(IEnumerable<Func<NancyContext, string, Response>> conventions)
        {
            this.conventions = conventions;
        }

        public IEnumerator<Func<NancyContext, string, Response>> GetEnumerator()
        {
            return conventions.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Extension methods to adding static content conventions.
    /// </summary>
    public static class StaticContentsConventionsExtensions
    {
        /// <summary>
        /// Adds a directory-based convention for static convention.
        /// </summary>
        /// <param name="conventions">The conventions to add to.</param>
        /// <param name="requestedPath">The path that should be matched with the request.</param>
        /// <param name="contentPath">The path to where the content is stored in your application, relative to the root. If this is <see langword="null" /> then it will be the same as <paramref name="requestedPath"/>.</param>
        /// <param name="allowedExtensions">A list of extensions that is valid for the conventions. If not supplied, all extensions are valid.</param>
        public static void AddDirectory(this IList<Func<NancyContext, string, Response>> conventions, string requestedPath, string contentPath = null, params string[] allowedExtensions)
        {
            conventions.Add(StaticContentConventionBuilder.AddDirectory(requestedPath, contentPath, allowedExtensions));
        }

        /// <summary>
        /// Adds a directory-based convention for static convention.
        /// </summary>
        /// <param name="conventions">The conventions to add to.</param>
        /// <param name="requestedFile">The file that should be matched with the request.</param>
        /// <param name="contentFile">The file that should be served when the requested path is matched.</param>
        public static void AddFile(this IList<Func<NancyContext, string, Response>> conventions, string requestedFile, string contentFile)
        {
            conventions.Add(StaticContentConventionBuilder.AddFile(requestedFile, contentFile));
        }
    }
}
namespace Nancy.Conventions
{
    /// <summary>
    /// Nancy static directory convention helper
    /// </summary>
    public class StaticDirectoryContent
    {
        private readonly NancyConventions conventions;

        /// <summary>
        /// Creates a new instance of StaticDirectoryContent
        /// </summary>
        /// <param name="conventions">NancyConventions, to which static directories get added</param>
        public StaticDirectoryContent(NancyConventions conventions)
        {
            this.conventions = conventions;
        }

        /// <summary>
        /// Adds a new static directory to the nancy conventions
        /// </summary>
        /// <param name="requestDirectory">The route of the file</param>
        /// <param name="allowedExtensions">A list of extensions that is valid for the conventions. If not supplied, all extensions are valid</param>
        public string this[string requestDirectory, params string[] allowedExtensions]
        {
            set
            {
                this.conventions.StaticContentsConventions.Add(StaticContentConventionBuilder.AddDirectory(requestDirectory, value, allowedExtensions));
            }
        }
    }
}
namespace Nancy.Conventions
{
    /// <summary>
    /// Nancy static file convention helper
    /// </summary>
    public class StaticFileContent
    {
        private readonly NancyConventions conventions;

        /// <summary>
        /// Creates a new instance of StaticFileContent
        /// </summary>
        /// <param name="conventions">NancyConventions, to which static files get added</param>
        public StaticFileContent(NancyConventions conventions)
        {
            this.conventions = conventions;
        }

        /// <summary>
        /// Adds a new static file to the nancy conventions
        /// </summary>
        /// <param name="requestFile">The route of the file</param>
        public string this[string requestFile]
        {
            set
            {
                this.conventions.StaticContentsConventions.Add(StaticContentConventionBuilder.AddFile(requestFile, value));
            }
        }
    }
}
namespace Nancy.Culture
{
    using System.Globalization;
    using Nancy.Configuration;
    using Nancy.Conventions;

    /// <summary>
    /// Determines current culture for context
    /// </summary>
    public class DefaultCultureService : ICultureService
    {
        private readonly CultureConventions cultureConventions;
        private readonly GlobalizationConfiguration configuration;

        /// <summary>
        /// Creates a new instance of DefaultCultureService
        /// </summary>
        /// <param name="cultureConventions">CultureConventions to use for determining culture</param>
        /// <param name="environment">An instance of <see cref="INancyEnvironment"/> to retrieve <see cref="GlobalizationConfiguration"/> from.</param>
        public DefaultCultureService(CultureConventions cultureConventions, INancyEnvironment environment)
        {
            this.cultureConventions = cultureConventions;
            this.configuration = environment.GetValue<GlobalizationConfiguration>();
        }

        /// <summary>
        /// Determine current culture for NancyContext
        /// </summary>
        /// <param name="context">NancyContext</param>
        /// <returns>CultureInfo</returns>
        public CultureInfo DetermineCurrentCulture(NancyContext context)
        {
            CultureInfo culture = null;

            foreach (var convention in this.cultureConventions)
            {
                culture = convention(context, this.configuration);
                if (culture != null)
                {
                    break;
                }
            }

            return culture;
        }
    }
}
namespace Nancy.Culture
{
    using System.Globalization;

    /// <summary>
    /// Provides current culture for Nancy context
    /// </summary>
    public interface ICultureService
    {
        /// <summary>
        /// Determine current culture for NancyContext
        /// </summary>
        /// <param name="context">NancyContext</param>
        /// <returns>CultureInfo</returns>
        CultureInfo DetermineCurrentCulture(NancyContext context);
    }
}
namespace Nancy
{
    using Nancy.Configuration;

    /// <summary>
    /// The default implementation of the <see cref="IResponseFormatterFactory"/> interface.
    /// </summary>
    public class DefaultResponseFormatterFactory : IResponseFormatterFactory
    {
        private readonly IRootPathProvider rootPathProvider;
        private readonly ISerializerFactory serializerFactory;
        private readonly INancyEnvironment environment;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultResponseFormatter"/> class.
        /// </summary>
        /// <param name="rootPathProvider">An <see cref="IRootPathProvider"/> instance.</param>
        /// <param name="serializerFactory">An <see cref="ISerializerFactory"/> instance.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public DefaultResponseFormatterFactory(IRootPathProvider rootPathProvider, ISerializerFactory serializerFactory, INancyEnvironment environment)
        {
            this.rootPathProvider = rootPathProvider;
            this.serializerFactory = serializerFactory;
            this.environment = environment;
        }

        /// <summary>
        /// Creates a new <see cref="IResponseFormatter"/> instance.
        /// </summary>
        /// <param name="context">The <see cref="NancyContext"/> instance that should be used by the response formatter.</param>
        /// <returns>An <see cref="IResponseFormatter"/> instance.</returns>
        public IResponseFormatter Create(NancyContext context)
        {
            return new DefaultResponseFormatter(this.rootPathProvider, context, this.serializerFactory, this.environment);
        }
    }
}
namespace Nancy
{
    using System;

    /// <summary>
    /// Default implementation of <see cref="IRootPathProvider"/>.
    /// </summary>
    public class DefaultRootPathProvider : IRootPathProvider
    {
        /// <summary>
        /// Returns the root folder path of the current Nancy application.
        /// </summary>
        /// <returns>A <see cref="string"/> containing the path of the root folder.</returns>
        public string GetRootPath()
        {
#if DNX
            return Microsoft.Extensions.PlatformAbstractions.PlatformServices.Default.Application.ApplicationBasePath;
#else
            return AppDomain.CurrentDomain.BaseDirectory;
#endif
        }
    }
}
namespace Nancy
{
    /// <summary>
    /// A cache for empty arrays.
    /// </summary>
    public class ArrayCache
    {
        /// <summary>
        /// Gets a cached, empty array of the specified type.
        /// </summary>
        /// <typeparam name="T">the type of array to get.</typeparam>
        public static T[] Empty<T>()
        {
            return EmptyArray<T>.Value;
        }

        private static class EmptyArray<T>
        {
            public static readonly T[] Value = new T[0];
        }
    }
}
namespace Nancy
{
    using Nancy.Configuration;

    /// <summary>
    /// Provides the default configuration for <see cref="RouteConfiguration"/>.
    /// </summary>
    public class DefaultRouteConfigurationProvider : NancyDefaultConfigurationProvider<RouteConfiguration>
    {
        /// <summary>
        /// Gets the default configuration instance to register in the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <remarks>Will return <see cref="ViewConfiguration.Default"/>.</remarks>
        public override RouteConfiguration GetDefaultConfiguration()
        {
            return RouteConfiguration.Default;
        }
    }
}
namespace Nancy
{
    using System;
    using System.Diagnostics;
    using System.Linq;

    /// <summary>
    /// Default implementation of the <see cref="IRuntimeEnvironmentInformation"/> interface.
    /// </summary>
    public class DefaultRuntimeEnvironmentInformation : IRuntimeEnvironmentInformation
    {
        private readonly Lazy<bool> isDebug;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultRuntimeEnvironmentInformation"/> class.
        /// </summary>
        /// <param name="typeCatalog">An <see cref="ITypeCatalog"/> instance.</param>
        public DefaultRuntimeEnvironmentInformation(ITypeCatalog typeCatalog)
        {
            this.isDebug = new Lazy<bool>(() => GetDebugMode(typeCatalog));
        }

        /// <summary>
        /// Gets a value indicating if the application is running in debug mode.
        /// </summary>
        /// <returns><see langword="true"/> if the application is running in debug mode, otherwise <see langword="false"/>.</returns>
        public virtual bool IsDebug
        {
            get { return this.isDebug.Value; }
        }

        private static bool GetDebugMode(ITypeCatalog typeCatalog)
        {
            try
            {
                var assembliesInDebug = typeCatalog
                    .GetTypesAssignableTo<INancyModule>(TypeResolveStrategies.ExcludeNancy)
                    .Select(x => x.Assembly.GetCustomAttributes(typeof(DebuggableAttribute), true))
                    .Where(x => x.Length != 0);

                return assembliesInDebug.Any(d => ((DebuggableAttribute)d[0]).IsJITTrackingEnabled);
            }
            catch
            {
                return false;
            }
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Nancy.Responses.Negotiation;

    /// <summary>
    /// Default implementation of the <see cref="ISerializerFactory"/> interface.
    /// </summary>
    /// <remarks>This implementation will ignore the default implementations (those found in the Nancy assembly) unless no other match could be made.</remarks>
    public class DefaultSerializerFactory : ISerializerFactory
    {
        private readonly IEnumerable<ISerializer> serializers;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultSerializerFactory"/> class,
        /// with the provided <paramref name="serializers"/>.
        /// </summary>
        /// <param name="serializers">The <see cref="ISerializer"/> implementations that should be available to the factory.</param>
        public DefaultSerializerFactory(IEnumerable<ISerializer> serializers)
        {
            this.serializers = serializers;
        }

        /// <summary>
        /// Gets the <see cref="ISerializer"/> implementation that can serialize the provided <paramref name="mediaRange"/>.
        /// </summary>
        /// <param name="mediaRange">The <see cref="MediaRange"/> to get a serializer for.</param>
        /// <returns>An <see cref="ISerializer"/> instance, or <see langword="null" /> if not match was found.</returns>
        /// <exception cref="InvalidOperationException">If more than one <see cref="ISerializer"/> (not counting the default serializers) matched the provided media range.</exception>
        public ISerializer GetSerializer(MediaRange mediaRange)
        {
            var defaultSerializerForMediaRange =
                this.GetDefaultSerializerForMediaRange(mediaRange);

            var matches = this.serializers
                .Where(x => x != defaultSerializerForMediaRange)
                .Where(x => SafeCanSerialize(x, mediaRange)).ToArray();

            if (matches.Length > 1)
            {
                throw new InvalidOperationException(GetErrorMessage(matches, mediaRange));
            }

            return matches
                .Concat(new[] { defaultSerializerForMediaRange })
                .FirstOrDefault();
        }

        private ISerializer GetDefaultSerializerForMediaRange(MediaRange mediaRange)
        {
            try
            {
                return this.serializers
                    .Where(x => x.GetType().Assembly.Equals(typeof(INancyEngine).Assembly))
                    .SingleOrDefault(x => x.CanSerialize(mediaRange));
            }
            catch
            {
                return null;
            }
        }

        private static string GetErrorMessage(IEnumerable<ISerializer> matches, MediaRange mediaRange)
        {
            var details =
                string.Join("\n", matches.Select(x => string.Concat(" - ", x.GetType().FullName)));

            return string.Format("Multiple ISerializer implementations matched the '{0}' media range.\nThe following serializers matched \n\n{1}", mediaRange, details);
        }

        private static bool SafeCanSerialize(ISerializer serializer, MediaRange mediaRange)
        {
            try
            {
                return serializer.CanSerialize(mediaRange);
            }
            catch
            {
                return false;
            }
        }
    }
}
namespace Nancy
{
    using Nancy.Conventions;

    /// <summary>
    /// The default static content provider that uses <see cref="StaticContentsConventions"/>
    /// to determine what static content to serve.
    /// </summary>
    public class DefaultStaticContentProvider : IStaticContentProvider
    {
        private readonly IRootPathProvider rootPathProvider;
        private readonly StaticContentsConventions conventions;
        private string rootPath;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultStaticContentProvider"/> class, using the
        /// provided <paramref name="rootPathProvider"/> and <paramref name="conventions"/>.
        /// </summary>
        /// <param name="rootPathProvider">The current root path provider.</param>
        /// <param name="conventions">The static content conventions.</param>
        public DefaultStaticContentProvider(IRootPathProvider rootPathProvider, StaticContentsConventions conventions)
        {
            this.rootPathProvider = rootPathProvider;
            this.rootPath = this.rootPathProvider.GetRootPath();
            this.conventions = conventions;
        }

        /// <summary>
        /// Gets the static content response, if possible.
        /// </summary>
        /// <param name="context">Current context</param>
        /// <returns>Response if serving content, null otherwise</returns>
        public Response GetContent(NancyContext context)
        {
            foreach (var convention in this.conventions)
            {
                var result = convention.Invoke(context, this.rootPath);

                if (result != null)
                {
                    return result;
                }
            }

            return null;
        }
    }
}
namespace Nancy
{
    using Nancy.Configuration;

    /// <summary>
    /// Provides the default configuration for <see cref="TraceConfiguration"/>.
    /// </summary>
    public class DefaultTraceConfigurationProvider : NancyDefaultConfigurationProvider<TraceConfiguration>
    {
        private readonly IRuntimeEnvironmentInformation runtimeEnvironmentInformation;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultTraceConfigurationProvider"/> class.
        /// </summary>
        public DefaultTraceConfigurationProvider(IRuntimeEnvironmentInformation runtimeEnvironmentInformation)
        {
            this.runtimeEnvironmentInformation = runtimeEnvironmentInformation;
        }

        /// <summary>
        /// Gets the default configuration instance to register in the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <returns>The configuration instance</returns>
        public override TraceConfiguration GetDefaultConfiguration()
        {
            var isDebugMode =
                this.runtimeEnvironmentInformation.IsDebug;

            return new TraceConfiguration(
                enabled: false,
                displayErrorTraces: isDebugMode);
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Linq;
    using Nancy.Extensions;

    /// <summary>
    /// Default implementation of the <see cref="ITypeCatalog"/> interface.
    /// </summary>
    public class DefaultTypeCatalog : ITypeCatalog
    {
        private readonly IAssemblyCatalog assemblyCatalog;
        private readonly ConcurrentDictionary<Type, IReadOnlyCollection<Type>> cache;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultTypeCatalog"/> class.
        /// </summary>
        /// <param name="assemblyCatalog">An <see cref="IAssemblyCatalog"/> instanced, used to get the assemblies that types should be resolved from.</param>
        public DefaultTypeCatalog(IAssemblyCatalog assemblyCatalog)
        {
            this.assemblyCatalog = assemblyCatalog;
            this.cache = new ConcurrentDictionary<Type, IReadOnlyCollection<Type>>();
        }

        /// <summary>
        /// Gets all types that are assignable to the provided <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The <see cref="Type"/> that returned types should be assignable to.</param>
        /// <param name="strategy">A <see cref="TypeResolveStrategy"/> that should be used when retrieving types.</param>
        /// <returns>An <see cref="IReadOnlyCollection{T}"/> of <see cref="Type"/> instances.</returns>
        public IReadOnlyCollection<Type> GetTypesAssignableTo(Type type, TypeResolveStrategy strategy)
        {
            return this.cache.GetOrAdd(type, t => this.GetTypesAssignableTo(type)).Where(strategy.Invoke).ToArray();
        }

        private IReadOnlyCollection<Type> GetTypesAssignableTo(Type type)
        {
            return this.assemblyCatalog
                .GetAssemblies()
                .SelectMany(assembly => assembly.SafeGetExportedTypes())
                .Where(type.IsAssignableFrom)
                .Where(t => !t.IsAbstract)
                .ToArray();
        }
    }
}
namespace Nancy
{
    using Configuration;

    /// <summary>
    /// Provides the default configuration for <see cref="ViewConfiguration"/>.
    /// </summary>
    public class DefaultViewConfigurationProvider : NancyDefaultConfigurationProvider<ViewConfiguration>
    {
        /// <summary>
        /// Gets the default configuration instance to register in the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <returns>The configuration instance</returns>
        /// <remarks>Will return <see cref="ViewConfiguration.Default"/>.</remarks>
        public override ViewConfiguration GetDefaultConfiguration()
        {
            return ViewConfiguration.Default; ;
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Collections.Generic;
    using Nancy.Configuration;

    /// <summary>
    /// Default implementation of the <see cref="IRequestTraceFactory"/> interface.
    /// </summary>
    public class DefaultRequestTraceFactory : IRequestTraceFactory
    {
        private readonly TraceConfiguration configuration;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultRequestTraceFactory"/> class.
        /// </summary>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public DefaultRequestTraceFactory(INancyEnvironment environment)
        {
            this.configuration = environment.GetValue<TraceConfiguration>();
        }

        /// <summary>
        /// Creates an <see cref="IRequestTrace"/> instance.
        /// </summary>
        /// <param name="request">A <see cref="Request"/> instance.</param>
        /// <returns>An <see cref="IRequestTrace"/> instance.</returns>
        public IRequestTrace Create(Request request)
        {
            var requestTrace =
                new DefaultRequestTrace();

            var comparer = (StaticConfiguration.CaseSensitive) ?
                StringComparer.Ordinal :
                StringComparer.OrdinalIgnoreCase;

            requestTrace.Items =
                new Dictionary<string, object>(comparer);

            requestTrace.RequestData = request;

            requestTrace.TraceLog = (this.configuration.DisplayErrorTraces) ?
                (ITraceLog)new DefaultTraceLog() :
                (ITraceLog)new NullLog();

            return requestTrace;
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Text;

    /// <summary>
    /// Default implementation of the <see cref="ITraceLog"/> interface.
    /// </summary>
    public class DefaultTraceLog : ITraceLog
    {
        private readonly StringBuilder log;

        /// <summary>
        /// Creates a new instance of the <see cref="DefaultTraceLog"/> class.
        /// </summary>
        public DefaultTraceLog()
        {
            this.log = new StringBuilder();
        }

        /// <summary>
        /// Write to the log
        /// </summary>
        /// <param name="logDelegate">Log writing delegate</param>
        public void WriteLog(Action<StringBuilder> logDelegate)
        {
            if (this.log != null)
            {
                logDelegate.Invoke(this.log);
            }
        }

        /// <summary>
        /// Returns a string that represents the current object.
        /// </summary>
        /// <returns>
        /// A string that represents the current object.
        /// </returns>
        public override string ToString()
        {
            return this.log != null ? this.log.ToString() : string.Empty;
        }
    }
}
namespace Nancy.Diagnostics
{
    using Nancy.Cryptography;

    /// <summary>
    /// Configuration for the diagnostics dashboard.
    /// </summary>
    public class DiagnosticsConfiguration
    {
        /// <summary>
        /// A default instance of the <see cref="DiagnosticsConfiguration"/> class.
        /// </summary>
        public static readonly DiagnosticsConfiguration Default = new DiagnosticsConfiguration
        {
            Enabled = false,
            CookieName = "__ncd",
            CryptographyConfiguration = CryptographyConfiguration.Default,
            Password = null,
            Path = "/_Nancy",
            SlidingTimeout = 15
        };

        private DiagnosticsConfiguration()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DiagnosticsConfiguration"/> class
        /// </summary>
        /// <param name="enabled"></param>
        /// <param name="password">Password used to secure the dashboard.</param>
        /// <param name="path">Relative path of the dashboard.</param>
        /// <param name="cookieName">Name of the cookie to store diagnostics information.</param>
        /// <param name="slidingTimeout">Number of minutes that expiry of the diagnostics dashboard.</param>
        /// <param name="cryptographyConfiguration">Cryptography config to use for securing the dashboard.</param>
        public DiagnosticsConfiguration(bool enabled, string password, string path, string cookieName, int slidingTimeout, CryptographyConfiguration cryptographyConfiguration)
        {
            this.Password = password ?? Default.Password;
            this.Path = GetNormalizedPath(path ?? Default.Path);
            this.CookieName = cookieName ?? Default.CookieName;
            this.Enabled = enabled;
            this.SlidingTimeout = slidingTimeout;
            this.CryptographyConfiguration = cryptographyConfiguration ?? Default.CryptographyConfiguration;
        }

        /// <summary>
        /// Gets or sets the name of the cookie used by the diagnostics dashboard.
        /// </summary>
        /// <remarks>The default is __ncd</remarks>
        public string CookieName { get; private set; }

        /// <summary>
        /// Gets the cryptography config to use for securing the diagnostics dashboard
        /// </summary>
        /// <remarks>The default is <see cref="CryptographyConfiguration.Default"/></remarks>
        public CryptographyConfiguration CryptographyConfiguration { get; private set; }

        /// <summary>
        /// Gets a value indicating if diagnostics is enabled or not.
        /// </summary>
        public bool Enabled { get; private set; }

        /// <summary>
        /// Gets password for accessing the diagnostics screen.
        /// </summary>
        /// <remarks>The default value is <see langword="null" />.</remarks>
        public string Password { get; private set; }

        /// <summary>
        /// Gets the path that the diagnostics dashboard will be accessible on.
        /// </summary>
        /// <remarks>The default is /_Nancy.</remarks>
        public string Path { get; private set; }

        /// <summary>
        /// The number of minutes that expiry of the diagnostics dashboard. Will be extended each time it is used.
        /// </summary>
        /// <remarks>The default is 15 minutes.</remarks>
        public int SlidingTimeout { get; private set; }

        private static string GetNormalizedPath(string path)
        {
            return (!path.StartsWith("/")) ? string.Concat("/", path) : path;
        }
    }
}
namespace Nancy.Diagnostics
{
    using Nancy.Configuration;
    using Nancy.Cryptography;

    /// <summary>
    /// Contains <see cref="DiagnosticsConfiguration"/> configuration extensions for <see cref="INancyEnvironment"/>.
    /// </summary>
    public static class DiagnosticsConfigurationExtensions
    {
        /// <summary>
        /// Configures diagnostics.
        /// </summary>
        /// <param name="environment"><see cref="INancyEnvironment"/> that should be configured.</param>
        /// <param name="password">Password used to secure the dashboard.</param>
        /// <param name="path">Relative path of the dashboard.</param>
        /// <param name="cookieName">Name of the cookie to store diagnostics information.</param>
        /// <param name="slidingTimeout">Number of minutes that expiry of the diagnostics dashboard.</param>
        /// <param name="cryptographyConfiguration">Cryptography config to use for securing the dashboard.</param>
        /// <remarks>This will implicitly enable diagnostics. If you need control, please explicitly set enabled to either <see langword="true"/> or <see langword="false"/>.</remarks>
        public static void Diagnostics(this INancyEnvironment environment, string password, string path = null, string cookieName = null, int slidingTimeout = 15, CryptographyConfiguration cryptographyConfiguration = null)
        {
            Diagnostics(
                environment,
                enabled: true,
                password: password,
                path: path,
                cookieName: cookieName,
                slidingTimeout: slidingTimeout,
                cryptographyConfiguration: cryptographyConfiguration);
        }

        /// <summary>
        /// Configures diagnostics.
        /// </summary>
        /// <param name="environment"><see cref="INancyEnvironment"/> that should be configured.</param>
        /// <param name="enabled"><see langword="true"/> if diagnostics should be enabled, otherwise <see langword="false"/>.</param>
        /// <param name="password">Password used to secure the dashboard.</param>
        /// <param name="path">Relative path of the dashboard.</param>
        /// <param name="cookieName">Name of the cookie to store diagnostics information.</param>
        /// <param name="slidingTimeout">Number of minutes that expiry of the diagnostics dashboard.</param>
        /// <param name="cryptographyConfiguration">Cryptography config to use for securing the dashboard.</param>
        public static void Diagnostics(this INancyEnvironment environment, bool enabled, string password, string path = null, string cookieName = null, int slidingTimeout = 15, CryptographyConfiguration cryptographyConfiguration = null)
        {
            environment.AddValue(new DiagnosticsConfiguration(
                enabled: enabled,
                password: password,
                path: path,
                cookieName: cookieName,
                slidingTimeout: slidingTimeout,
                cryptographyConfiguration: cryptographyConfiguration));
        }
    }
}
namespace Nancy.Diagnostics
{
    using Nancy.Configuration;

    /// <summary>
    /// Provides the default configuration for <see cref="DiagnosticsConfiguration"/>.
    /// </summary>
    public class DefaultDiagnosticsConfigurationProvider : NancyDefaultConfigurationProvider<DiagnosticsConfiguration>
    {
        /// <summary>
        /// Gets the default configuration instance to register in the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <returns>The configuration instance</returns>
        /// <remarks>Will return <see cref="DiagnosticsConfiguration.Default"/></remarks>
        public override DiagnosticsConfiguration GetDefaultConfiguration()
        {
            return DiagnosticsConfiguration.Default;
        }
    }
}
namespace Nancy.Diagnostics
{
    using Nancy.Configuration;
    using Nancy.Responses;
    using Nancy.Responses.Negotiation;

    internal class DiagnosticsSerializerFactory : ISerializerFactory
    {
        private readonly ISerializer serializer;

        public DiagnosticsSerializerFactory(INancyEnvironment diagnosticsEnvironment)
        {
            this.serializer = new DefaultJsonSerializer(diagnosticsEnvironment);
        }

        /// <summary>
        /// Gets the <see cref="ISerializer"/> implementation that can serialize the provided <paramref name="mediaRange"/>.
        /// </summary>
        /// <param name="mediaRange">The <see cref="MediaRange"/> to get a serializer for.</param>
        /// <returns>An <see cref="ISerializer"/> instance, or <see langword="null" /> if not match was found.</returns>
        public ISerializer GetSerializer(MediaRange mediaRange)
        {
            return this.serializer;
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Security.Cryptography;
    using System.Text;

    [Serializable]
    public class DiagnosticsSession
    {
        public byte[] Hash { get; set; }

        public byte[] Salt { get; set; }

        public DateTime Expiry { get; set; }

        public static byte[] GenerateRandomSalt()
        {
            var provider = new RNGCryptoServiceProvider();

            var buffer = new byte[32];
            provider.GetBytes(buffer);

            return buffer;
        }

        public static byte[] GenerateSaltedHash(byte[] plainText, byte[] salt)
        {
            var algorithm = new SHA256Managed();

            var plainTextWithSaltBytes = new byte[plainText.Length + salt.Length];

            for (var i = 0; i < plainText.Length; i++)
            {
                plainTextWithSaltBytes[i] = plainText[i];
            }

            for (var i = 0; i < salt.Length; i++)
            {
                plainTextWithSaltBytes[plainText.Length + i] = salt[i];
            }

            return algorithm.ComputeHash(plainTextWithSaltBytes);
        }

        public static byte[] GenerateSaltedHash(string plainText, byte[] salt)
        {
            return GenerateSaltedHash(Encoding.UTF8.GetBytes(plainText), salt);
        }
    }
}
namespace Nancy.Diagnostics
{
    using System.Collections;
    using System.Collections.Concurrent;
    using System.Collections.Generic;

    /// <summary>
    /// Provides a thread safe, limited size, collection of objects
    /// If the collection is full the oldest item gets removed.
    /// </summary>
    /// <typeparam name="T">Type to store</typeparam>
    public class ConcurrentLimitedCollection<T> : IEnumerable<T>
    {
        private readonly int maxSize;

        private ConcurrentQueue<T> internalStore;

        public int CurrentSize
        {
            get
            {
                return this.internalStore.Count;
            }
        }

        /// <summary>
        /// Creates a new instance of the ConcurrentLimitedCollection class
        /// </summary>
        /// <param name="maxSize">Maximum size for the collection</param>
        public ConcurrentLimitedCollection(int maxSize)
        {
            this.maxSize = maxSize;
            this.internalStore = new ConcurrentQueue<T>();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>1</filterpriority>
        public IEnumerator<T> GetEnumerator()
        {
            return this.internalStore.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        /// <summary>
        /// Adds an item to the collection.
        /// If the collection is full, the oldest item is removed and the new item
        /// is added to the end of the collection.
        /// </summary>
        /// <param name="item">Item to add</param>
        public void Add(T item)
        {
            if (this.internalStore.Count == this.maxSize)
            {
                T temp;
                this.internalStore.TryDequeue(out temp);
            }

            this.internalStore.Enqueue(item);
        }

        /// <summary>
        /// Clear the collection
        /// </summary>
        public void Clear()
        {
            this.internalStore = new ConcurrentQueue<T>();
        }
    }
}
namespace Nancy.Diagnostics
{
    using Nancy.Bootstrapper;

    /// <summary>
    /// Implementation of the <see cref="IDiagnostics"/> interface that does nothing.
    /// </summary>
    public class DisabledDiagnostics : IDiagnostics
    {
        /// <summary>
        /// Initialise diagnostics
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        public void Initialize(IPipelines pipelines)
        {
            // Do nothing :-)
        }
    }
}
namespace Nancy.Diagnostics
{
    using Nancy.Bootstrapper;

    public interface IDiagnostics
    {
        /// <summary>
        /// Initialise diagnostics
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        void Initialize(IPipelines pipelines);
    }
}
namespace Nancy.Diagnostics
{
    using System.Collections.Generic;

    /// <summary>
    /// Defines the functionality for tracing a request.
    /// </summary>
    public interface IRequestTrace
    {
        /// <summary>
        /// Gets or sets the generic item store.
        /// </summary>
        /// <value>An <see cref="IDictionary{TKey,TValue}"/> instance containing the items.</value>
        IDictionary<string, object> Items { get; set; }

        /// <summary>
        /// Gets or sets the information about the request.
        /// </summary>
        /// <value>An <see cref="RequestData"/> instance.</value>
        RequestData RequestData { get; set; }

        /// <summary>
        /// Gets or sets the information about the response.
        /// </summary>
        /// <value>An <see cref="ResponseData"/> instance.</value>
        ResponseData ResponseData { get; set; }

        /// <summary>
        /// Gets the trace log.
        /// </summary>
        /// <value>A <see cref="ITraceLog"/> instance.</value>
        ITraceLog TraceLog { get; set; }
    }
}
namespace Nancy.Diagnostics
{
    /// <summary>
    /// Defines the functionality for creating an <see cref="IRequestTrace"/> instance.
    /// </summary>
    public interface IRequestTraceFactory
    {
        /// <summary>
        /// Creates an <see cref="IRequestTrace"/> instance.
        /// </summary>
        /// <param name="request">A <see cref="Request"/> instance.</param>
        /// <returns>An <see cref="IRequestTrace"/> instance.</returns>
        IRequestTrace Create(Request request);
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Text;

    /// <summary>
    /// Provides request trace logging.
    /// Uses a delegate to write to the log, rather than creating strings regardless
    /// of whether the log is enabled or not.
    /// </summary>
    public interface ITraceLog
    {
        /// <summary>
        /// Write to the log
        /// </summary>
        /// <param name="logDelegate">Log writing delegate</param>
        void WriteLog(Action<StringBuilder> logDelegate);
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Text;

    /// <summary>
    /// Implementation of <see cref="ITraceLog"/> that does not log anything.
    /// </summary>
    public class NullLog : ITraceLog
    {
        /// <summary>
        /// Write to the log
        /// </summary>
        /// <param name="logDelegate">Log writing delegate</param>
        public void WriteLog(Action<StringBuilder> logDelegate)
        {
        }

        /// <summary>
        /// Returns a string that represents the current object.
        /// </summary>
        /// <returns>
        /// A string that represents the current object.
        /// </returns>
        public override string ToString()
        {
            return string.Empty;
        }
    }
}
namespace Nancy.Diagnostics
{
    /// <summary>
    /// Stores request trace information about the request.
    /// </summary>
    public class RequestData
    {
        /// <summary>
        /// Gets or sets the content type of the request.
        /// </summary>
        /// <value>A <see cref="string"/> containing the content type.</value>
        public string ContentType { get; set; }

        /// <summary>
        /// Gets or sets the headers of the request.
        /// </summary>
        /// <value>A <see cref="RequestHeaders"/> instance containing the headers.</value>
        public RequestHeaders Headers { get; set; }

        /// <summary>
        /// Gets the HTTP verb of the request.
        /// </summary>
        /// <value>A <see cref="string"/> containing the HTTP verb.</value>
        public string Method { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Url"/> that was requested.
        /// </summary>
        public Url Url { get; set; }

        /// <summary>
        /// Implicitly casts a <see cref="Request"/> instance into a <see cref="RequestData"/> instance.
        /// </summary>
        /// <param name="request">A <see cref="Request"/> instance.</param>
        /// <returns>A <see cref="RequestData"/> instance.</returns>
        public static implicit operator RequestData(Request request)
        {
            return new RequestData
            {
                ContentType = request.Headers.ContentType,
                Headers = request.Headers,
                Method = request.Method,
                Url = request.Url
            };
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Stores request trace information about the response.
    /// </summary>
    public class ResponseData
    {
        /// <summary>
        /// Gets or sets the content type of the response.
        /// </summary>
        /// <value>A <see cref="string"/> containing the content type.</value>
        public string ContentType { get; set; }

        /// <summary>
        /// Gets or sets the headers of the response.
        /// </summary>
        /// <value>A <see cref="IDictionary{TKey,TValue}"/> instance containing the headers.</value>
        public IDictionary<string, string> Headers { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="HttpStatusCode"/> of the response.
        /// </summary>
        public HttpStatusCode StatusCode { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Type"/> of the response.
        /// </summary>
        /// <value>A <see cref="Type"/> instance.</value>
        public Type Type { get; set; }

        /// <summary>
        /// Implicitly casts a <see cref="Response"/> instance into a <see cref="ResponseData"/> instance.
        /// </summary>
        /// <param name="response">A <see cref="Response"/> instance.</param>
        /// <returns>A <see cref="ResponseData"/> instance.</returns>
        public static implicit operator ResponseData(Response response)
        {
            return new ResponseData
            {
                ContentType = response.ContentType,
                Headers = response.Headers,
                StatusCode = response.StatusCode,
                Type = response.GetType()
            };
        }
    }
}
namespace Nancy
{
    /// <summary>
    /// A "disabled" static content provider - always returns null
    /// so no content is served.
    /// </summary>
    public class DisabledStaticContentProvider : IStaticContentProvider
    {
        /// <summary>
        /// Gets the static content response, if possible.
        /// </summary>
        /// <param name="context">Current context</param>
        /// <returns>Response if serving content, null otherwise</returns>
        public Response GetContent(NancyContext context)
        {
            return null;
        }
    }
}
namespace Nancy.ErrorHandling
{
    using System;

    /// <summary>
    /// Here Be Dragons - Using an exception for flow control to hotwire route execution.
    /// It can be useful to call a method inside a route definition and have that method
    /// immediately return a response (such as for authentication). This exception is used
    /// to allow that flow.
    /// </summary>
    public class RouteExecutionEarlyExitException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteExecutionEarlyExitException"/> class.
        /// </summary>
        /// <param name="response">
        /// The response.
        /// </param>
        /// <param name="reason">
        /// The reason for the early exit.
        /// </param>
        public RouteExecutionEarlyExitException(Response response, string reason = null)
        {
            this.Response = response;
            this.Reason = reason ?? "(none)";
        }

        /// <summary>
        /// Gets or sets the reason for the early exit
        /// </summary>
        public string Reason { get; set; }

        /// <summary>
        /// Gets or sets the response
        /// </summary>
        public Response Response { get; protected set; }
    }
}
namespace Nancy
{
    using System.Collections.Generic;

    using Nancy.Validation;

    /// <summary>
    /// Containing extensions for the <see cref="ModelValidationResult.Errors"/> property.
    /// </summary>
    public static class ModelValidationResultExtensions
    {
        /// <summary>
        /// Adds a new <see cref="ModelValidationError"/> to the validation results.
        /// </summary>
        /// <param name="errors">A reference to the <see cref="ModelValidationResult.Errors"/> property.</param>
        /// <param name="name">The name of the property.</param>
        /// <param name="errorMessage">The validation error message.</param>
        /// <returns>A reference to the <see cref="ModelValidationResult.Errors"/> property.</returns>
        public static IDictionary<string, IList<ModelValidationError>> Add(this IDictionary<string, IList<ModelValidationError>> errors, string name, string errorMessage)
        {
            if (!errors.ContainsKey(name))
            {
                errors[name] = new List<ModelValidationError>();
            }

            errors[name].Add(new ModelValidationError(name, errorMessage));

            return errors;
        }
    }
}
namespace Nancy.Extensions
{
    using System.IO;
    using System.Text;
    using Nancy.IO;

    /// <summary>
    /// Extensions for RequestStream.
    /// </summary>
    public static class RequestStreamExtensions
    {
        /// <summary>
        /// Gets the request body as a string.
        /// </summary>
        /// <param name="stream">The request body stream.</param>
        /// <param name="encoding">The encoding to use, <see cref="Encoding.UTF8"/> by default.</param>
        /// <returns>The request body as a <see cref="string"/>.</returns>
        public static string AsString(this RequestStream stream, Encoding encoding = null)
        {
            using (var reader = new StreamReader(stream, encoding ?? Encoding.UTF8))
            {
                var initialPosition = stream.Position;

                stream.Position = 0;

                var request = reader.ReadToEnd();

                stream.Position = initialPosition;

                return request;
            }
        }
    }
}
namespace Nancy.Extensions
{
    using System;
    using System.IO;

    /// <summary>
    /// Containing extensions for the <see cref="Stream"/> object.
    /// </summary>
    public static class StreamExtensions
    {
        /// <summary>
        /// Buffer size for copy operations
        /// </summary>
        internal const int BufferSize = 4096;

        /// <summary>
        /// Copies the contents between two <see cref="Stream"/> instances in an async fashion.
        /// </summary>
        /// <param name="source">The source stream to copy from.</param>
        /// <param name="destination">The destination stream to copy to.</param>
        /// <param name="onComplete">Delegate that should be invoked when the operation has completed. Will pass the source, destination and exception (if one was thrown) to the function. Can pass in <see langword="null" />.</param>
        public static void CopyTo(this Stream source, Stream destination, Action<Stream, Stream, Exception> onComplete)
        {
            var buffer =
                new byte[BufferSize];

            Action<Exception> done = e =>
            {
                if (onComplete != null)
                {
                    onComplete.Invoke(source, destination, e);
                }
            };

            AsyncCallback rc = null;

            rc = readResult =>
            {
                try
                {
                    var read =
                        source.EndRead(readResult);

                    if (read <= 0)
                    {
                        done.Invoke(null);
                        return;
                    }

                    destination.BeginWrite(buffer, 0, read, writeResult =>
                    {
                        try
                        {
                            destination.EndWrite(writeResult);
                            source.BeginRead(buffer, 0, buffer.Length, rc, null);
                        }
                        catch (Exception ex)
                        {
                            done.Invoke(ex);
                        }

                    }, null);
                }
                catch (Exception ex)
                {
                    done.Invoke(ex);
                }
            };

            source.BeginRead(buffer, 0, buffer.Length, rc, null);
        }
    }
}
namespace Nancy.Extensions
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Containing extensions for the <see cref="Type"/> object.
    /// </summary>
    public static class TypeExtensions
    {
        /// <summary>
        /// Checks if a type is an array or not
        /// </summary>
        /// <param name="source">The type to check.</param>
        /// <returns><see langword="true" /> if the type is an array, otherwise <see langword="false" />.</returns>
        public static bool IsArray(this Type source)
        {
            return source.BaseType == typeof(Array);
        }

        /// <summary>
        /// Determines whether the <paramref name="genericType"/> is assignable from
        /// <paramref name="givenType"/> taking into account generic definitions
        /// </summary>
        /// <remarks>
        /// Borrowed from: http://tmont.com/blargh/2011/3/determining-if-an-open-generic-type-isassignablefrom-a-type
        /// </remarks>
        public static bool IsAssignableToGenericType(this Type givenType, Type genericType)
        {
            if (givenType == null || genericType == null)
            {
                return false;
            }

            return givenType == genericType
                || givenType.MapsToGenericTypeDefinition(genericType)
                || givenType.HasInterfaceThatMapsToGenericTypeDefinition(genericType)
                || givenType.BaseType.IsAssignableToGenericType(genericType);
        }

        /// <summary>
        /// Checks if a type is an collection or not
        /// </summary>
        /// <param name="source">The type to check.</param>
        /// <returns><see langword="true" /> if the type is an collection, otherwise <see langword="false" />.</returns>
        public static bool IsCollection(this Type source)
        {
            var collectionType = typeof(ICollection<>);

            return source.IsGenericType && source
                .GetInterfaces()
                .Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == collectionType);
        }

        /// <summary>
        /// Checks if a type is enumerable or not
        /// </summary>
        /// <param name="source">The type to check.</param>
        /// <returns><see langword="true" /> if the type is an enumerable, otherwise <see langword="false" />.</returns>
        public static bool IsEnumerable(this Type source)
        {
            var enumerableType = typeof(IEnumerable<>);

            return source.IsGenericType && source.GetGenericTypeDefinition() == enumerableType;
        }

        /// <summary>
        /// Determines if a type is numeric.  Nullable numeric types are considered numeric.
        /// </summary>
        /// <remarks>
        /// Boolean is not considered numeric.
        /// </remarks>
        public static bool IsNumeric(this Type source)
        {
            if (source == null)
            {
                return false;
            }

            var underlyingType = Nullable.GetUnderlyingType(source) ?? source;

            if (underlyingType.IsEnum)
            {
                return false;
            }

            switch (Type.GetTypeCode(underlyingType))
            {
                case TypeCode.Byte:
                case TypeCode.Decimal:
                case TypeCode.Double:
                case TypeCode.Int16:
                case TypeCode.Int32:
                case TypeCode.Int64:
                case TypeCode.SByte:
                case TypeCode.Single:
                case TypeCode.UInt16:
                case TypeCode.UInt32:
                case TypeCode.UInt64:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Filters our all types not assignable to <typeparamref name="TType"/>.
        /// </summary>
        /// <typeparam name="TType">The type that all resulting <see cref="Type"/> should be assignable to.</typeparam>
        /// <param name="types">An <see cref="IEnumerable{T}"/> of <see cref="Type"/> instances that should be filtered.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="Type"/> instances.</returns>
        public static IEnumerable<Type> NotOfType<TType>(this IEnumerable<Type> types)
        {
            return types.Where(t => !typeof(TType).IsAssignableFrom(t));
        }

        private static bool HasInterfaceThatMapsToGenericTypeDefinition(this Type givenType, Type genericType)
        {
            return givenType
                .GetInterfaces()
                .Where(it => it.IsGenericType)
                .Any(it => it.GetGenericTypeDefinition() == genericType);
        }

        private static bool MapsToGenericTypeDefinition(this Type givenType, Type genericType)
        {
            return genericType.IsGenericTypeDefinition
                && givenType.IsGenericType
                && givenType.GetGenericTypeDefinition() == genericType;
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Default implementation of the <see cref="IRequestTracing"/> interface.
    /// </summary>
    public class DefaultRequestTracing : IRequestTracing
    {
        private const int MaxSize = 50;

        private readonly ConcurrentLimitedCollection<RequestTraceSession> sessions = new ConcurrentLimitedCollection<RequestTraceSession>(MaxSize);

        /// <summary>
        /// Adds the <see cref="IRequestTrace"/>, of the provided, <see cref="NancyContext"/> to the trace log.
        /// </summary>
        /// <param name="sessionId">The identifier of the trace.</param>
        /// <param name="context">A <see cref="NancyContext"/> instance.</param>
        public void AddRequestDiagnosticToSession(Guid sessionId, NancyContext context)
        {
            var session = this.sessions.FirstOrDefault(s => s.Id == sessionId);

            if (session == null)
            {
                return;
            }

            session.AddRequestTrace(context.Trace);
        }

        /// <summary>
        /// Clears the trace log.
        /// </summary>
        public void Clear()
        {
            this.sessions.Clear();
        }

        /// <summary>
        /// Creates a new trace session.
        /// </summary>
        /// <returns>A <see cref="Guid"/> which represents the identifier of the new trace session.</returns>
        public Guid CreateSession()
        {
            var id = Guid.NewGuid();

            this.sessions.Add(new RequestTraceSession(id));

            return id;
        }

        // TODO - remove above method and return guid from here?

        /// <summary>
        /// Gets all the available <see cref="RequestTraceSession"/> instances.
        /// </summary>
        /// <returns></returns>
        public IEnumerable<RequestTraceSession> GetSessions()
        {
            return this.sessions;
        }

        /// <summary>
        /// Checks if the provided <paramref name="sessionId"/> is valid or not.
        /// </summary>
        /// <param name="sessionId">A <see cref="Guid"/> representing the session to check.</param>
        /// <returns><see langword="true"/> if the session is valid, otherwise <see langword="false"/>.</returns>
        public bool IsValidSessionId(Guid sessionId)
        {
            return this.sessions.Any(s => s.Id == sessionId);
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;

    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
    public class DescriptionAttribute : Attribute
    {
        public string Description { get; set; }

        public DescriptionAttribute(string description)
        {
            this.Description = description;
        }
    }
}
namespace Nancy.Diagnostics
{
    using Configuration;

    public abstract class DiagnosticModule : NancyModule
    {
        private readonly INancyEnvironment environment;

        protected DiagnosticModule()
            : this(string.Empty)
        {
        }

        protected DiagnosticModule(string basePath)
            : base(basePath)
        {
            this.environment = new DefaultNancyEnvironment();
            this.environment.AddValue(ViewConfiguration.Default);
        }

        public new DiagnosticsViewRenderer View
        {
            get { return new DiagnosticsViewRenderer(this.Context, this.environment); }
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Threading;
    using Nancy.Bootstrapper;
    using Nancy.Configuration;
    using Nancy.Cookies;
    using Nancy.Cryptography;
    using Nancy.Culture;
    using Nancy.Json;
    using Nancy.Localization;
    using Nancy.ModelBinding;
    using Nancy.Responses;
    using Nancy.Responses.Negotiation;
    using Nancy.Routing;
    using Nancy.Routing.Constraints;
    using Nancy.Routing.Trie;

    /// <summary>
    /// Pipeline hook to handle diagnostics dashboard requests.
    /// </summary>
    public static class DiagnosticsHook
    {
        private static readonly CancellationToken CancellationToken = new CancellationToken();
        private const string PipelineKey = "__Diagnostics";
        internal const string ItemsKey = "DIAGS_REQUEST";

        /// <summary>
        /// Enables the diagnostics dashboard and will intercept all requests that are passed to
        /// the condigured paths.
        /// </summary>
        public static void Enable(IPipelines pipelines, IEnumerable<IDiagnosticsProvider> providers, IRootPathProvider rootPathProvider, IRequestTracing requestTracing, NancyInternalConfiguration configuration, IModelBinderLocator modelBinderLocator, IEnumerable<IResponseProcessor> responseProcessors, IEnumerable<IRouteSegmentConstraint> routeSegmentConstraints, ICultureService cultureService, IRequestTraceFactory requestTraceFactory, IEnumerable<IRouteMetadataProvider> routeMetadataProviders, ITextResource textResource, INancyEnvironment environment, ITypeCatalog typeCatalog)
        {
            var diagnosticsConfiguration =
                environment.GetValue<DiagnosticsConfiguration>();

            var diagnosticsEnvironment =
                GetDiagnosticsEnvironment();

            var diagnosticsModuleCatalog = new DiagnosticsModuleCatalog(providers, rootPathProvider, requestTracing, configuration, diagnosticsEnvironment, typeCatalog);

            var diagnosticsRouteCache = new RouteCache(
                diagnosticsModuleCatalog,
                new DefaultNancyContextFactory(cultureService, requestTraceFactory, textResource, environment),
                new DefaultRouteSegmentExtractor(),
                new DefaultRouteDescriptionProvider(),
                cultureService,
                routeMetadataProviders);

            var diagnosticsRouteResolver = new DefaultRouteResolver(
                diagnosticsModuleCatalog,
                new DiagnosticsModuleBuilder(rootPathProvider, modelBinderLocator, diagnosticsEnvironment, environment),
                diagnosticsRouteCache,
                new RouteResolverTrie(new TrieNodeFactory(routeSegmentConstraints)),
                environment);

            var serializer = new DefaultObjectSerializer();

            pipelines.BeforeRequest.AddItemToStartOfPipeline(
                new PipelineItem<Func<NancyContext, Response>>(
                    PipelineKey,
                    ctx =>
                    {
                        if (!ctx.ControlPanelEnabled)
                        {
                            return null;
                        }

                        if (!ctx.Request.Path.StartsWith(diagnosticsConfiguration.Path, StringComparison.OrdinalIgnoreCase))
                        {
                            return null;
                        }

                        if (!diagnosticsConfiguration.Enabled)
                        {
                            return HttpStatusCode.NotFound;
                        }

                        ctx.Items[ItemsKey] = true;

                        var resourcePrefix =
                            string.Concat(diagnosticsConfiguration.Path, "/Resources/");

                        if (ctx.Request.Path.StartsWith(resourcePrefix, StringComparison.OrdinalIgnoreCase))
                        {
                            var resourceNamespace = "Nancy.Diagnostics.Resources";

                            var path = Path.GetDirectoryName(ctx.Request.Url.Path.Replace(resourcePrefix, string.Empty)) ?? string.Empty;
                            if (!string.IsNullOrEmpty(path))
                            {
                                resourceNamespace += string.Format(".{0}", path.Replace(Path.DirectorySeparatorChar, '.'));
                            }

                            return new EmbeddedFileResponse(
                                typeof(DiagnosticsHook).Assembly,
                                resourceNamespace,
                                Path.GetFileName(ctx.Request.Url.Path));
                        }

                        RewriteDiagnosticsUrl(diagnosticsConfiguration, ctx);

                        return ValidateConfiguration(diagnosticsConfiguration)
                                   ? ExecuteDiagnostics(ctx, diagnosticsRouteResolver, diagnosticsConfiguration, serializer, diagnosticsEnvironment)
                                   : new DiagnosticsViewRenderer(ctx, environment)["help"];
                    }));
        }

        /// <summary>
        /// Gets a special <see cref="INancyEnvironment"/> instance that is separate from the
        /// one used by the application.
        /// </summary>
        /// <returns></returns>
        private static INancyEnvironment GetDiagnosticsEnvironment()
        {
            var diagnosticsEnvironment =
                new DefaultNancyEnvironment();

            diagnosticsEnvironment.Json(retainCasing: false);
            diagnosticsEnvironment.AddValue(ViewConfiguration.Default);
            diagnosticsEnvironment.Tracing(
                enabled: true,
                displayErrorTraces: true);

            return diagnosticsEnvironment;
        }

        private static bool ValidateConfiguration(DiagnosticsConfiguration configuration)
        {
            return !string.IsNullOrWhiteSpace(configuration.Password) &&
                !string.IsNullOrWhiteSpace(configuration.CookieName) &&
                !string.IsNullOrWhiteSpace(configuration.Path) &&
                configuration.SlidingTimeout != 0;
        }

        public static void Disable(IPipelines pipelines)
        {
            pipelines.BeforeRequest.RemoveByName(PipelineKey);
        }

        private static Response GetDiagnosticsLoginView(NancyContext ctx, INancyEnvironment environment)
        {
            var renderer = new DiagnosticsViewRenderer(ctx, environment);

            return renderer["login"];
        }

        private static Response ExecuteDiagnostics(NancyContext ctx, IRouteResolver routeResolver, DiagnosticsConfiguration diagnosticsConfiguration, DefaultObjectSerializer serializer, INancyEnvironment environment)
        {
            var session = GetSession(ctx, diagnosticsConfiguration, serializer);

            if (session == null)
            {
                var view = GetDiagnosticsLoginView(ctx, environment);

                view.WithCookie(
                    new NancyCookie(diagnosticsConfiguration.CookieName, string.Empty, true) { Expires = DateTime.Now.AddDays(-1) });

                return view;
            }

            var resolveResult = routeResolver.Resolve(ctx);

            ctx.Parameters = resolveResult.Parameters;
            ExecuteRoutePreReq(ctx, CancellationToken, resolveResult.Before);

            if (ctx.Response == null)
            {
                // Don't care about async here, so just get the result
                var task = resolveResult.Route.Invoke(resolveResult.Parameters, CancellationToken);
                task.Wait();
                ctx.Response = task.Result;
            }

            if (ctx.Request.Method.Equals("HEAD", StringComparison.OrdinalIgnoreCase))
            {
                ctx.Response = new HeadResponse(ctx.Response);
            }

            if (resolveResult.After != null)
            {
                resolveResult.After.Invoke(ctx, CancellationToken);
            }

            AddUpdateSessionCookie(session, ctx, diagnosticsConfiguration, serializer);

            return ctx.Response;
        }

        private static void AddUpdateSessionCookie(DiagnosticsSession session, NancyContext context, DiagnosticsConfiguration diagnosticsConfiguration, DefaultObjectSerializer serializer)
        {
            if (context.Response == null)
            {
                return;
            }

            session.Expiry = DateTime.Now.AddMinutes(diagnosticsConfiguration.SlidingTimeout);
            var serializedSession = serializer.Serialize(session);

            var encryptedSession = diagnosticsConfiguration.CryptographyConfiguration.EncryptionProvider.Encrypt(serializedSession);
            var hmacBytes = diagnosticsConfiguration.CryptographyConfiguration.HmacProvider.GenerateHmac(encryptedSession);
            var hmacString = Convert.ToBase64String(hmacBytes);

            var cookie = new NancyCookie(diagnosticsConfiguration.CookieName, string.Format("{1}{0}", encryptedSession, hmacString), true);

            context.Response.WithCookie(cookie);
        }

        private static DiagnosticsSession GetSession(NancyContext context, DiagnosticsConfiguration diagnosticsConfiguration, DefaultObjectSerializer serializer)
        {
            if (context.Request == null)
            {
                return null;
            }

            if (IsLoginRequest(context, diagnosticsConfiguration))
            {
                return ProcessLogin(context, diagnosticsConfiguration, serializer);
            }

            if (!context.Request.Cookies.ContainsKey(diagnosticsConfiguration.CookieName))
            {
                return null;
            }

            var encryptedValue = context.Request.Cookies[diagnosticsConfiguration.CookieName];
            var hmacStringLength = Base64Helpers.GetBase64Length(diagnosticsConfiguration.CryptographyConfiguration.HmacProvider.HmacLength);
            var encryptedSession = encryptedValue.Substring(hmacStringLength);
            var hmacString = encryptedValue.Substring(0, hmacStringLength);

            var hmacBytes = Convert.FromBase64String(hmacString);
            var newHmac = diagnosticsConfiguration.CryptographyConfiguration.HmacProvider.GenerateHmac(encryptedSession);
            var hmacValid = HmacComparer.Compare(newHmac, hmacBytes, diagnosticsConfiguration.CryptographyConfiguration.HmacProvider.HmacLength);

            if (!hmacValid)
            {
                return null;
            }

            var decryptedValue = diagnosticsConfiguration.CryptographyConfiguration.EncryptionProvider.Decrypt(encryptedSession);
            var session = serializer.Deserialize(decryptedValue) as DiagnosticsSession;

            if (session == null || session.Expiry < DateTime.Now || !SessionPasswordValid(session, diagnosticsConfiguration.Password))
            {
                return null;
            }

            return session;
        }

        private static bool SessionPasswordValid(DiagnosticsSession session, string realPassword)
        {
            var newHash = DiagnosticsSession.GenerateSaltedHash(realPassword, session.Salt);

            return (newHash.Length == session.Hash.Length && newHash.SequenceEqual(session.Hash));
        }

        private static DiagnosticsSession ProcessLogin(NancyContext context, DiagnosticsConfiguration diagnosticsConfiguration, DefaultObjectSerializer serializer)
        {
            string password = context.Request.Form.Password;

            if (!string.Equals(password, diagnosticsConfiguration.Password, StringComparison.Ordinal))
            {
                return null;
            }

            var salt = DiagnosticsSession.GenerateRandomSalt();
            var hash = DiagnosticsSession.GenerateSaltedHash(password, salt);
            var session = new DiagnosticsSession
            {
                Hash = hash,
                Salt = salt,
                Expiry = DateTime.Now.AddMinutes(diagnosticsConfiguration.SlidingTimeout)
            };

            return session;
        }

        private static bool IsLoginRequest(NancyContext context, DiagnosticsConfiguration diagnosticsConfiguration)
        {
            return context.Request.Method.Equals("POST", StringComparison.OrdinalIgnoreCase) &&
                context.Request.Url.BasePath.TrimEnd('/').EndsWith(diagnosticsConfiguration.Path) &&
                context.Request.Url.Path == "/";
        }

        private static void ExecuteRoutePreReq(NancyContext context, CancellationToken cancellationToken, BeforePipeline resolveResultPreReq)
        {
            if (resolveResultPreReq == null)
            {
                return;
            }

            var resolveResultPreReqResponse = resolveResultPreReq.Invoke(context, cancellationToken).Result;

            if (resolveResultPreReqResponse != null)
            {
                context.Response = resolveResultPreReqResponse;
            }
        }

        private static void RewriteDiagnosticsUrl(DiagnosticsConfiguration diagnosticsConfiguration, NancyContext ctx)
        {
            ctx.Request.Url.BasePath =
                string.Concat(ctx.Request.Url.BasePath, diagnosticsConfiguration.Path);

            ctx.Request.Url.Path =
                ctx.Request.Url.Path.Substring(diagnosticsConfiguration.Path.Length);

            if (ctx.Request.Url.Path.Length.Equals(0))
            {
                ctx.Request.Url.Path = "/";
            }
        }
    }
}
namespace Nancy.Diagnostics
{
    using Nancy.Configuration;
    using Nancy.ModelBinding;
    using Nancy.Routing;

    internal class DiagnosticsModuleBuilder : INancyModuleBuilder
    {
        private readonly IRootPathProvider rootPathProvider;
        private readonly ISerializerFactory serializerFactory;
        private readonly IModelBinderLocator modelBinderLocator;
        private readonly INancyEnvironment environment;

        public DiagnosticsModuleBuilder(IRootPathProvider rootPathProvider, IModelBinderLocator modelBinderLocator, INancyEnvironment diagnosticsEnvironment, INancyEnvironment environment)
        {
            this.rootPathProvider = rootPathProvider;
            this.serializerFactory = new DiagnosticsSerializerFactory(diagnosticsEnvironment);
            this.modelBinderLocator = modelBinderLocator;
            this.environment = environment;
        }

        /// <summary>
        /// Builds a fully configured <see cref="INancyModule"/> instance, based upon the provided <paramref name="module"/>.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> that should be configured.</param>
        /// <param name="context">The current request context.</param>
        /// <returns>A fully configured <see cref="INancyModule"/> instance.</returns>
        public INancyModule BuildModule(INancyModule module, NancyContext context)
        {
            module.Context = context;
            module.Response = new DefaultResponseFormatter(rootPathProvider, context, this.serializerFactory, this.environment);
            module.ModelBinderLocator = this.modelBinderLocator;

            module.After = new AfterPipeline();
            module.Before = new BeforePipeline();
            module.OnError = new ErrorPipeline();

            return module;
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Nancy.Bootstrapper;
    using Nancy.Configuration;
    using Nancy.Json;
    using Nancy.ModelBinding;
    using Nancy.Responses;
    using Nancy.TinyIoc;

    internal class DiagnosticsModuleCatalog : INancyModuleCatalog
    {
        private readonly TinyIoCContainer container;

        public DiagnosticsModuleCatalog(IEnumerable<IDiagnosticsProvider> providers, IRootPathProvider rootPathProvider, IRequestTracing requestTracing, NancyInternalConfiguration configuration, INancyEnvironment diagnosticsEnvironment, ITypeCatalog typeCatalog)
        {
            this.container = ConfigureContainer(providers, rootPathProvider, requestTracing, configuration, diagnosticsEnvironment, typeCatalog);
        }

        /// <summary>
        /// Get all NancyModule implementation instances - should be per-request lifetime
        /// </summary>
        /// <param name="context">The current context</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance containing <see cref="INancyModule"/> instances.</returns>
        public IEnumerable<INancyModule> GetAllModules(NancyContext context)
        {
            return this.container.ResolveAll<INancyModule>(false);
        }

        /// <summary>
        /// Retrieves a specific <see cref="INancyModule"/> implementation - should be per-request lifetime
        /// </summary>
        /// <param name="moduleType">Module type</param>
        /// <param name="context">The current context</param>
        /// <returns>The <see cref="INancyModule"/> instance</returns>
        public INancyModule GetModule(Type moduleType, NancyContext context)
        {
            return this.container.Resolve<INancyModule>(moduleType.FullName);
        }

        private static TinyIoCContainer ConfigureContainer(IEnumerable<IDiagnosticsProvider> providers, IRootPathProvider rootPathProvider, IRequestTracing requestTracing, NancyInternalConfiguration configuration, INancyEnvironment diagnosticsEnvironment, ITypeCatalog typeCatalog)
        {
            var diagContainer = new TinyIoCContainer();

            diagContainer.Register<IInteractiveDiagnostics, InteractiveDiagnostics>();
            diagContainer.Register<IRequestTracing>(requestTracing);
            diagContainer.Register<IRootPathProvider>(rootPathProvider);
            diagContainer.Register<NancyInternalConfiguration>(configuration);
            diagContainer.Register<IModelBinderLocator, DefaultModelBinderLocator>();
            diagContainer.Register<IBinder, DefaultBinder>();
            diagContainer.Register<IFieldNameConverter, DefaultFieldNameConverter>();
            diagContainer.Register<BindingDefaults, BindingDefaults>();
            diagContainer.Register<INancyEnvironment>(diagnosticsEnvironment);
            diagContainer.Register<ISerializer>(new DefaultJsonSerializer(diagnosticsEnvironment));
            diagContainer.Register<ITypeCatalog>(typeCatalog);

            foreach (var diagnosticsProvider in providers)
            {
                var key = string.Concat(
                    diagnosticsProvider.GetType().FullName,
                    "_",
                    diagnosticsProvider.DiagnosticObject.GetType().FullName);

                diagContainer.Register<IDiagnosticsProvider>(diagnosticsProvider, key);
            }

            foreach (var moduleType in typeCatalog.GetTypesAssignableTo<DiagnosticModule>())
            {
                diagContainer.Register(typeof(INancyModule), moduleType, moduleType.FullName).AsMultiInstance();
            }

            return diagContainer;
        }
    }
}
namespace Nancy.Diagnostics
{
    using System.Collections.Generic;

    using Nancy.Bootstrapper;
    using Nancy.Configuration;
    using Nancy.Culture;
    using Nancy.Localization;
    using Nancy.ModelBinding;
    using Nancy.Responses.Negotiation;
    using Nancy.Routing;
    using Nancy.Routing.Constraints;

    /// <summary>
    /// Wires up the diagnostics support at application startup.
    /// </summary>
    public class DefaultDiagnostics : IDiagnostics
    {
        private readonly IEnumerable<IDiagnosticsProvider> diagnosticProviders;
        private readonly IRootPathProvider rootPathProvider;
        private readonly IRequestTracing requestTracing;
        private readonly NancyInternalConfiguration configuration;
        private readonly IModelBinderLocator modelBinderLocator;
        private readonly IEnumerable<IResponseProcessor> responseProcessors;
        private readonly IEnumerable<IRouteSegmentConstraint> routeSegmentConstraints;
        private readonly ICultureService cultureService;
        private readonly IRequestTraceFactory requestTraceFactory;
        private readonly IEnumerable<IRouteMetadataProvider> routeMetadataProviders;
        private readonly ITextResource textResource;
        private readonly INancyEnvironment environment;
        private readonly ITypeCatalog typeCatalog;

        /// <summary>
        /// Creates a new instance of the <see cref="DefaultDiagnostics"/> class.
        /// </summary>
        /// <param name="diagnosticProviders"></param>
        /// <param name="rootPathProvider"></param>
        /// <param name="requestTracing"></param>
        /// <param name="configuration"></param>
        /// <param name="modelBinderLocator"></param>
        /// <param name="responseProcessors"></param>
        /// <param name="routeSegmentConstraints"></param>
        /// <param name="cultureService"></param>
        /// <param name="requestTraceFactory"></param>
        /// <param name="routeMetadataProviders"></param>
        /// <param name="textResource"></param>
        /// <param name="environment"></param>
        /// <param name="typeCatalog"></param>
        public DefaultDiagnostics(
            IEnumerable<IDiagnosticsProvider> diagnosticProviders,
            IRootPathProvider rootPathProvider,
            IRequestTracing requestTracing,
            NancyInternalConfiguration configuration,
            IModelBinderLocator modelBinderLocator,
            IEnumerable<IResponseProcessor> responseProcessors,
            IEnumerable<IRouteSegmentConstraint> routeSegmentConstraints,
            ICultureService cultureService,
            IRequestTraceFactory requestTraceFactory,
            IEnumerable<IRouteMetadataProvider> routeMetadataProviders,
            ITextResource textResource,
            INancyEnvironment environment,
            ITypeCatalog typeCatalog)
        {
            this.diagnosticProviders = diagnosticProviders;
            this.rootPathProvider = rootPathProvider;
            this.requestTracing = requestTracing;
            this.configuration = configuration;
            this.modelBinderLocator = modelBinderLocator;
            this.responseProcessors = responseProcessors;
            this.routeSegmentConstraints = routeSegmentConstraints;
            this.cultureService = cultureService;
            this.requestTraceFactory = requestTraceFactory;
            this.routeMetadataProviders = routeMetadataProviders;
            this.textResource = textResource;
            this.environment = environment;
            this.typeCatalog = typeCatalog;
        }

        /// <summary>
        /// Initialize diagnostics
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        public void Initialize(IPipelines pipelines)
        {
            DiagnosticsHook.Enable(
                pipelines,
                this.diagnosticProviders,
                this.rootPathProvider,
                this.requestTracing,
                this.configuration,
                this.modelBinderLocator,
                this.responseProcessors,
                this.routeSegmentConstraints,
                this.cultureService,
                this.requestTraceFactory,
                this.routeMetadataProviders,
                this.textResource,
                this.environment,
                this.typeCatalog);
        }
    }
}
namespace Nancy.Diagnostics
{
    using System.IO;
    using System.Linq;
    using Configuration;
    using Nancy.Localization;
    using Nancy.Responses;
    using Nancy.Security;
    using Nancy.ViewEngines;
    using Nancy.ViewEngines.SuperSimpleViewEngine;

    /// <summary>
    /// Renders diagnostics views from embedded resources.
    /// </summary>
    public class DiagnosticsViewRenderer
    {
        private readonly NancyContext context;
        private readonly INancyEnvironment environment;
        private static readonly IViewResolver ViewResolver = new DiagnosticsViewResolver();
        private static readonly IViewEngine Engine = new SuperSimpleViewEngineWrapper(Enumerable.Empty<ISuperSimpleViewEngineMatcher>());

        /// <summary>
        /// Creates a new instance of the <see cref="DiagnosticsViewRenderer"/> class.
        /// </summary>
        /// <param name="context">A <see cref="NancyContext"/> instance.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public DiagnosticsViewRenderer(NancyContext context, INancyEnvironment environment)
        {
            this.context = context;
            this.environment = environment;
        }

        /// <summary>
        /// Renders the diagnostics view with the provided <paramref name="name"/>.
        /// </summary>
        /// <param name="name">The name of the view to render.</param>
        /// <returns>A <see cref="Response"/> of the rendered view.</returns>
        public Response this[string name]
        {
            get { return this.RenderView(name, null, this.context); }
        }

        /// <summary>
        /// Renders the diagnostics view with the provided <paramref name="name"/> and <paramref name="model"/>.
        /// </summary>
        /// <param name="name">The name of the view to render.</param>
        /// <param name="model">The model that should be passed to the view engine during rendering.</param>
        /// <returns>A <see cref="Response"/> of the rendered view.</returns>
        public Response this[string name, dynamic model]
        {
            get { return RenderView(name, model, this.context); }
        }

        private Response RenderView(string name, dynamic model, NancyContext context)
        {
            var fullName = string.Concat(name, ".sshtml");
            var stream = GetBodyStream(fullName);
            var location = GetViewLocationResult(fullName, stream);
            var cache = new DefaultViewCache(this.environment);

            context.Items.Add(CsrfToken.DEFAULT_CSRF_KEY, "DIAGNOSTICSTOKEN");

            var renderContext =
                new DefaultRenderContext(ViewResolver, cache, new DummyTextResource(), new ViewLocationContext() { Context = context });

            return Engine.RenderView(location, model, renderContext);
        }

        private static Stream GetBodyStream(string name)
        {
            var view = new EmbeddedFileResponse(typeof(DiagnosticsViewRenderer).Assembly, "Nancy.Diagnostics.Views", name);

            var stream = new MemoryStream();

            view.Contents.Invoke(stream);
            stream.Position = 0;
            return stream;
        }

        private static ViewLocationResult GetViewLocationResult(string name, Stream bodyStream)
        {
            return new ViewLocationResult(
                "Nancy/Diagnostics/Views",
                name,
                "sshtml",
                () => new StreamReader(bodyStream));
        }

        internal class DiagnosticsViewResolver : IViewResolver
        {
            /// <summary>
            /// Locates a view based on the provided information.
            /// </summary>
            /// <param name="viewName">The name of the view to locate.</param>
            /// <param name="model">The model that will be used with the view.</param>
            /// <param name="viewLocationContext">A <see cref="ViewLocationContext"/> instance, containing information about the context for which the view is being located.</param>
            /// <returns>A <see cref="ViewLocationResult"/> instance if the view could be found, otherwise <see langword="null"/>.</returns>
            public ViewLocationResult GetViewLocation(string viewName, dynamic model, ViewLocationContext viewLocationContext)
            {
                var fullName = string.Concat(viewName, ".sshtml");

                var stream = GetBodyStream(fullName);

                return GetViewLocationResult(fullName, stream);
            }
        }

        internal class DummyTextResource : ITextResource
        {
            public string this[string key, NancyContext context]
            {
                get { return string.Empty; }
            }
        }
    }
}
namespace Nancy.Helpers
{
    using System;
    using System.Linq;

    /// <summary>
    /// Helper class for caching related functions
    /// </summary>
    public static class CacheHelpers
    {
        /// <summary>
        /// Returns whether to return a not modified response, based on the etag and last modified date
        /// of the resource, and the current nancy context
        /// </summary>
        /// <param name="etag">Current resource etag, or null</param>
        /// <param name="lastModified">Current resource last modified, or null</param>
        /// <param name="context">Current nancy context</param>
        /// <returns>True if not modified should be sent, false otherwise</returns>
        public static bool ReturnNotModified(string etag, DateTime? lastModified, NancyContext context)
        {
            if (context == null || context.Request == null)
            {
                return false;
            }

            var requestEtag = context.Request.Headers.IfNoneMatch.FirstOrDefault();
            var requestDate = context.Request.Headers.IfModifiedSince;

            if (requestEtag != null && !string.IsNullOrEmpty(etag) && requestEtag.Equals(etag, StringComparison.Ordinal))
            {
                return true;
            }

            if (requestDate.HasValue && lastModified.HasValue && ((int)(lastModified.Value - requestDate.Value).TotalSeconds) <= 0)
            {
                return true;
            }

            return false;
        }

    }
}
namespace Nancy.Helpers
{
    using System;

    internal static class ExceptionExtensions
    {
        internal static Exception FlattenInnerExceptions(this Exception exception)
        {
            var aggregateException = exception as AggregateException;
            if (aggregateException != null)
            {
                var flattenedAggregateException = aggregateException.Flatten();

                //If we have more than one exception in the AggregateException
                //we have to send all exceptions back in order not to swallow any exceptions.
                if (flattenedAggregateException.InnerExceptions.Count > 1)
                {
                    return flattenedAggregateException;
                }

                return flattenedAggregateException.InnerException;
            }

            return exception;
        }
    }
}
namespace Nancy
{
    using System.Collections.Generic;
    using System.Reflection;

    /// <summary>
    /// Defines the functionality of an assembly catalog.
    /// </summary>
    public interface IAssemblyCatalog
    {
        /// <summary>
        /// Gets all <see cref="Assembly"/> instances in the catalog.
        /// </summary>
        /// <returns>An <see cref="IReadOnlyCollection{T}"/> of <see cref="Assembly"/> instances.</returns>
        IReadOnlyCollection<Assembly> GetAssemblies();
    }
}
namespace Nancy
{
    using System;

    /// <summary>
    /// Add this attribute to an assembly to make sure
    /// it is included in Nancy's assembly scanning.
    /// </summary>
    /// <example>
    /// Apply the attribute, typically in AssemblyInfo.(cs|fs|vb), as follows:
    /// <code>[assembly: IncludeInNancyAssemblyScanning]</code>
    /// </example>
    [AttributeUsage(AttributeTargets.Assembly)]
    public sealed class IncludeInNancyAssemblyScanningAttribute : Attribute
    {
    }
}
namespace Nancy
{
    /// <summary>
    /// Defines functionality for getting information about the runtime execution environment.
    /// </summary>
    public interface IRuntimeEnvironmentInformation
    {
        /// <summary>
        /// Gets a value indicating if the application is running in debug mode.
        /// </summary>
        /// <returns><see langword="true"/> if the application is running in debug mode, otherwise <see langword="false"/>.</returns>
        bool IsDebug { get; }
    }
}
namespace Nancy
{
    using Nancy.Responses.Negotiation;

    /// <summary>
    /// Defines the functionality of an <see cref="ISerializer"/> factory.
    /// </summary>
    public interface ISerializerFactory
    {
        /// <summary>
        /// Gets the <see cref="ISerializer"/> implementation that can serialize the provided <paramref name="mediaRange"/>.
        /// </summary>
        /// <param name="mediaRange">The <see cref="MediaRange"/> to get a serializer for.</param>
        /// <returns>An <see cref="ISerializer"/> instance, or <see langword="null" /> if not match was found.</returns>
        ISerializer GetSerializer(MediaRange mediaRange);
    }
}
namespace Nancy
{
    /// <summary>
    /// Provides static content delivery
    /// </summary>
    public interface IStaticContentProvider
    {
        /// <summary>
        /// Gets the static content response, if possible.
        /// </summary>
        /// <param name="context">Current context</param>
        /// <returns>Response if serving content, null otherwise</returns>
        Response GetContent(NancyContext context);
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Defines the functionality of a type catalog.
    /// </summary>
    public interface ITypeCatalog
    {
        /// <summary>
        /// Gets all types that are assignable to the provided <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The <see cref="Type"/> that returned types should be assignable to.</param>
        /// <param name="strategy">A <see cref="TypeResolveStrategy"/> that should be used when retrieving types.</param>
        /// <returns>An <see cref="IReadOnlyCollection{T}"/> of <see cref="Type"/> instances.</returns>
        IReadOnlyCollection<Type> GetTypesAssignableTo(Type type, TypeResolveStrategy strategy);
    }
}
namespace Nancy.Json.Simple
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using Nancy.Extensions;

    /// <summary>
    /// Nancy serialization stategy for SimpleJson
    /// </summary>
    public class NancySerializationStrategy : PocoJsonSerializerStrategy
    {
        private readonly bool retainCasing;
        private readonly List<JavaScriptConverter> converters = new List<JavaScriptConverter>();
        private readonly List<JavaScriptPrimitiveConverter> primitiveConverters = new List<JavaScriptPrimitiveConverter>();
        private readonly ConcurrentDictionary<Type, JavaScriptConverter> converterCache = new ConcurrentDictionary<Type, JavaScriptConverter>();
        private readonly ConcurrentDictionary<Type, JavaScriptPrimitiveConverter> primitiveConverterCache = new ConcurrentDictionary<Type, JavaScriptPrimitiveConverter>();

        /// <summary>
        /// Initializes a new instance of the <see cref="NancySerializationStrategy"/> class.
        /// </summary>
        /// <remarks>C# casing of objects will be defaulted to camelCase</remarks>
        public NancySerializationStrategy() : this(false)
        {

        }

        /// <summary>
        ///  Initializes a new instance of the <see cref="NancySerializationStrategy"/> class.
        /// </summary>
        /// <param name="retainCasing">Retain C# casing of objects when serialized</param>
        public NancySerializationStrategy(bool retainCasing)
        {
            this.retainCasing = retainCasing;
        }

        /// <summary>
        /// Register custom <see cref="JavaScriptConverter"/> converters
        /// </summary>
        /// <param name="javaScriptConverters">An array of <see cref="JavaScriptConverter"/></param>
        public void RegisterConverters(IEnumerable<JavaScriptConverter> javaScriptConverters)
        {
            this.converters.AddRange(javaScriptConverters);
        }

        /// <summary>
        /// Register custom <see cref="JavaScriptPrimitiveConverter"/>
        /// </summary>
        /// <param name="javaScriptPrimitiveConverters">An array of <see cref="JavaScriptPrimitiveConverter"/></param>
        public void RegisterConverters(IEnumerable<JavaScriptPrimitiveConverter> javaScriptPrimitiveConverters)
        {
            this.primitiveConverters.AddRange(javaScriptPrimitiveConverters);
        }

        /// <summary>
        /// Formats a property name to a JSON field name
        /// </summary>
        /// <param name="clrPropertyName">The property name to format</param>
        /// <returns>camelCase <paramref name="clrPropertyName"/> if retainCasing is false, otherwise <paramref name="clrPropertyName"/></returns>
        protected override string MapClrMemberNameToJsonFieldName(string clrPropertyName)
        {
            return this.retainCasing
                ? base.MapClrMemberNameToJsonFieldName(clrPropertyName)
                : clrPropertyName.ToCamelCase();
        }

        /// <summary>
        /// Deserialize an object
        /// </summary>
        /// <param name="value">The object to deserialize</param>
        /// <param name="type">The type of object to deserialize</param>
        /// <returns>A instance of <paramref name="type" /> deserialized from <paramref name="value"/></returns>
        public override object DeserializeObject(object value, Type type)
        {
            var typeInfo = type.GetTypeInfo();
            if (typeInfo.IsEnum || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type).GetTypeInfo().IsEnum))
            {
                var typeToParse = ReflectionUtils.IsNullableType(type)
                    ? Nullable.GetUnderlyingType(type)
                    : type;

                return value == null
                    ? null
                    : Enum.Parse(typeToParse, value.ToString(), true);
            }

            var primitiveConverter = this.FindPrimitiveConverter(type);
            if (primitiveConverter != null)
            {
                return primitiveConverter.Deserialize(value, type);
            }

            var valueDictionary = value as IDictionary<string, object>;
            if (valueDictionary == null)
            {
                return base.DeserializeObject(value, type);
            }

            var javascriptConverter = this.FindJavaScriptConverter(type);
            if (javascriptConverter != null)
            {
                return javascriptConverter.Deserialize(valueDictionary, type);
            }

            if (!typeInfo.IsGenericType)
            {
                return base.DeserializeObject(value, type);
            }

            var genericType = typeInfo.GetGenericTypeDefinition();
            var genericTypeConverter = this.FindJavaScriptConverter(genericType);

            if (genericTypeConverter == null)
            {
                return base.DeserializeObject(value, type);
            }

            var values = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
            var genericArguments = typeInfo.GetGenericArguments();

            for (var i = 0; i < genericArguments.Length; i++)
            {
                var deserializedObject = this.DeserializeObject(valueDictionary.Values.ElementAt(i),
                    genericArguments[i]);

                values.Add(valueDictionary.Keys.ElementAt(i), deserializedObject);
            }

            return genericTypeConverter.Deserialize(values, type);
        }

        /// <summary>
        /// Serialize an object
        /// </summary>
        /// <param name="input">The object to serialize</param>
        /// <param name="output">The serialized object</param>
        /// <returns>true if <paramref name="input"/> was converted successfully; otherwise, false</returns>
        protected override bool TrySerializeKnownTypes(object input, out object output)
        {
            var dynamicValue = input as DynamicDictionaryValue;
            if (!ReferenceEquals(dynamicValue, null) && dynamicValue.HasValue)
            {
                output = dynamicValue.Value;
                return true;
            }

            var inputType = input.GetType().GetTypeInfo();
            if (this.TrySerializeJavaScriptConverter(input, out output, inputType))
            {
                return true;
            }

            if (this.TrySerializePrimitiveConverter(input, ref output, inputType))
            {
                return true;
            }

            var type = input as Type;
            if (type != null)
            {
                output = type.GetTypeInfo().FullName;
                return true;
            }

            if (input is DateTime)
            {
                return this.SerializeDateTime((DateTime)input, out output);
            }

            if (input is DateTimeOffset)
            {
                var dto = (DateTimeOffset)input;
                output = dto.ToString("o", CultureInfo.InvariantCulture);
                return true;
            }

            return base.TrySerializeKnownTypes(input, out output);
        }

        private bool SerializeDateTime(DateTime input, out object output)
        {
            var dateTime = input;
            if (dateTime.Kind == DateTimeKind.Unspecified)
            {
                dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Local);
            }

            output = dateTime.ToString("o", CultureInfo.InvariantCulture);

            return true;
        }

        private bool TrySerializePrimitiveConverter(object input, ref object output, Type inputType)
        {
            var primitiveConverter = this.FindPrimitiveConverter(inputType);
            if (primitiveConverter == null)
            {
                return false;
            }

            output = primitiveConverter.Serialize(input);
            return true;
        }

        private JavaScriptPrimitiveConverter FindPrimitiveConverter(Type inputType)
        {
            return this.primitiveConverterCache.GetOrAdd(inputType, typeToConvert => this.primitiveConverters.FirstOrDefault(converter => converter.SupportedTypes.Any(supportedType => supportedType.IsAssignableFrom(typeToConvert))));
        }

        private bool TrySerializeJavaScriptConverter(object input, out object output, Type inputType)
        {
            output = null;
            var converter = this.FindJavaScriptConverter(inputType);
            if (converter == null)
            {
                return false;
            }
            var result = converter.Serialize(input);
            output = result.ToDictionary(kvp => this.MapClrMemberNameToJsonFieldName(kvp.Key), kvp => kvp.Value);
            return true;
        }

        private JavaScriptConverter FindJavaScriptConverter(Type inputType)
        {
            return this.converterCache.GetOrAdd(inputType, typeToConvert => this.converters.FirstOrDefault(converter => converter.SupportedTypes.Any(supportedType => supportedType.IsAssignableFrom(typeToConvert))));
        }
    }
}
//-----------------------------------------------------------------------
// <copyright file="SimpleJson.cs" company="The Outercurve Foundation">
//    Copyright (c) 2011, The Outercurve Foundation.
//
//    Licensed under the MIT License (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//      http://www.opensource.org/licenses/mit-license.php
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
// </copyright>
// <author>Nathan Totten (ntotten.com), Jim Zimmerman (jimzimmerman.com) and Prabir Shrestha (prabir.me)</author>
// <website>https://github.com/facebook-csharp-sdk/simple-json</website>
//-----------------------------------------------------------------------

// VERSION: 0.38.0

// NOTE: uncomment the following line to make SimpleJson class internal.
//#define SIMPLE_JSON_INTERNAL

// NOTE: uncomment the following line to make JsonArray and JsonObject class internal.
//#define SIMPLE_JSON_OBJARRAYINTERNAL

// NOTE: uncomment the following line to enable dynamic support.
#define SIMPLE_JSON_DYNAMIC

// NOTE: uncomment the following line to enable DataContract support.
//#define SIMPLE_JSON_DATACONTRACT

// NOTE: uncomment the following line to enable IReadOnlyCollection<T> and IReadOnlyList<T> support.
//#define SIMPLE_JSON_READONLY_COLLECTIONS

// NOTE: uncomment the following line to disable linq expressions/compiled lambda (better performance) instead of method.invoke().
// define if you are using .net framework <= 3.0 or < WP7.5
//#define SIMPLE_JSON_NO_LINQ_EXPRESSION

// NOTE: uncomment the following line if you are compiling under Window Metro style application/library.
// usually already defined in properties
//#define NETFX_CORE;

// If you are targetting WinStore, WP8 and NET4.5+ PCL make sure to #define SIMPLE_JSON_TYPEINFO;
#define SIMPLE_JSON_TYPEINFO

// original json parsing code from http://techblog.procurios.nl/k/618/news/view/14605/14863/How-do-I-write-my-own-parser-for-JSON.html

#if NETFX_CORE
#define SIMPLE_JSON_TYPEINFO
#endif
namespace Nancy.Json.Simple
{
    using System;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Diagnostics.CodeAnalysis;
    using System.Dynamic;
    using System.Globalization;
    using System.Linq.Expressions;
    using System.Reflection;
    using System.Runtime.Serialization;
    using System.Text;

    // ReSharper disable LoopCanBeConvertedToQuery
    // ReSharper disable RedundantExplicitArrayCreation
    // ReSharper disable SuggestUseVarKeywordEvident
    /// <summary>
    /// Represents the json array.
    /// </summary>
    [GeneratedCode("simple-json", "1.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
#if SIMPLE_JSON_OBJARRAYINTERNAL
    internal
#else
    public
#endif
        class JsonArray : List<object>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="JsonArray"/> class. 
        /// </summary>
        public JsonArray() { }

        /// <summary>
        /// Initializes a new instance of the <see cref="JsonArray"/> class. 
        /// </summary>
        /// <param name="capacity">The capacity of the json array.</param>
        public JsonArray(int capacity) : base(capacity) { }

        /// <summary>
        /// The json representation of the array.
        /// </summary>
        /// <returns>The json representation of the array.</returns>
        public override string ToString()
        {
            return SimpleJson.SerializeObject(this) ?? string.Empty;
        }
    }

    /// <summary>
    /// Represents the json object.
    /// </summary>
    [GeneratedCode("simple-json", "1.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
#if SIMPLE_JSON_OBJARRAYINTERNAL
    internal
#else
    public
#endif
        class JsonObject :
#if SIMPLE_JSON_DYNAMIC
            DynamicObject,
#endif
            IDictionary<string, object>
    {
        /// <summary>
        /// The internal member dictionary.
        /// </summary>
        private readonly Dictionary<string, object> _members;

        /// <summary>
        /// Initializes a new instance of <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject() : this(StringComparer.OrdinalIgnoreCase) { }

        /// <summary>
        /// Initializes a new instance of <see cref="JsonObject"/>.
        /// </summary>
        /// <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for the type of the key.</param>
        public JsonObject(IEqualityComparer<string> comparer)
        {
            this._members = new Dictionary<string, object>(comparer);
        }

        /// <summary>
        /// Gets the <see cref="System.Object"/> at the specified index.
        /// </summary>
        /// <value></value>
        public object this[int index]
        {
            get { return GetAtIndex(this._members, index); }
        }

        internal static object GetAtIndex(IDictionary<string, object> obj, int index)
        {
            if (obj == null)
                throw new ArgumentNullException("obj");
            if (index >= obj.Count)
                throw new ArgumentOutOfRangeException("index");
            int i = 0;
            foreach (KeyValuePair<string, object> o in obj)
                if (i++ == index) return o.Value;
            return null;
        }

        /// <summary>
        /// Adds the specified key.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="value">The value.</param>
        public void Add(string key, object value)
        {
            this._members.Add(key, value);
        }

        /// <summary>
        /// Determines whether the specified key contains key.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <returns>
        ///     <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
        /// </returns>
        public bool ContainsKey(string key)
        {
            return this._members.ContainsKey(key);
        }

        /// <summary>
        /// Gets the keys.
        /// </summary>
        /// <value>The keys.</value>
        public ICollection<string> Keys
        {
            get { return this._members.Keys; }
        }

        /// <summary>
        /// Removes the specified key.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <returns></returns>
        public bool Remove(string key)
        {
            return this._members.Remove(key);
        }

        /// <summary>
        /// Tries the get value.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="value">The value.</param>
        /// <returns></returns>
        public bool TryGetValue(string key, out object value)
        {
            return this._members.TryGetValue(key, out value);
        }

        /// <summary>
        /// Gets the values.
        /// </summary>
        /// <value>The values.</value>
        public ICollection<object> Values
        {
            get { return this._members.Values; }
        }

        /// <summary>
        /// Gets or sets the <see cref="System.Object"/> with the specified key.
        /// </summary>
        /// <value></value>
        public object this[string key]
        {
            get { return this._members[key]; }
            set { this._members[key] = value; }
        }

        /// <summary>
        /// Adds the specified item.
        /// </summary>
        /// <param name="item">The item.</param>
        public void Add(KeyValuePair<string, object> item)
        {
            this._members.Add(item.Key, item.Value);
        }

        /// <summary>
        /// Clears this instance.
        /// </summary>
        public void Clear()
        {
            this._members.Clear();
        }

        /// <summary>
        /// Determines whether [contains] [the specified item].
        /// </summary>
        /// <param name="item">The item.</param>
        /// <returns>
        /// 	<c>true</c> if [contains] [the specified item]; otherwise, <c>false</c>.
        /// </returns>
        public bool Contains(KeyValuePair<string, object> item)
        {
            return this._members.ContainsKey(item.Key) && this._members[item.Key] == item.Value;
        }

        /// <summary>
        /// Copies to.
        /// </summary>
        /// <param name="array">The array.</param>
        /// <param name="arrayIndex">Index of the array.</param>
        public void CopyTo(KeyValuePair<string, object>[] array, int arrayIndex)
        {
            if (array == null) throw new ArgumentNullException("array");
            int num = this.Count;
            foreach (KeyValuePair<string, object> kvp in this)
            {
                array[arrayIndex++] = kvp;
                if (--num <= 0)
                    return;
            }
        }

        /// <summary>
        /// Gets the count.
        /// </summary>
        /// <value>The count.</value>
        public int Count
        {
            get { return this._members.Count; }
        }

        /// <summary>
        /// Gets a value indicating whether this instance is read only.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if this instance is read only; otherwise, <c>false</c>.
        /// </value>
        public bool IsReadOnly
        {
            get { return false; }
        }

        /// <summary>
        /// Removes the specified item.
        /// </summary>
        /// <param name="item">The item.</param>
        /// <returns></returns>
        public bool Remove(KeyValuePair<string, object> item)
        {
            return this._members.Remove(item.Key);
        }

        /// <summary>
        /// Gets the enumerator.
        /// </summary>
        /// <returns></returns>
        public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
        {
            return this._members.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this._members.GetEnumerator();
        }

        /// <summary>
        /// Returns a json <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A json <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return SimpleJson.SerializeObject(this);
        }

#if SIMPLE_JSON_DYNAMIC
        /// <summary>
        /// Provides implementation for type conversion operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations that convert an object from one type to another.
        /// </summary>
        /// <param name="binder">Provides information about the conversion operation. The binder.Type property provides the type to which the object must be converted. For example, for the statement (String)sampleObject in C# (CType(sampleObject, Type) in Visual Basic), where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, binder.Type returns the <see cref="T:System.String"/> type. The binder.Explicit property provides information about the kind of conversion that occurs. It returns true for explicit conversion and false for implicit conversion.</param>
        /// <param name="result">The result of the type conversion operation.</param>
        /// <returns>
        /// Alwasy returns true.
        /// </returns>
        public override bool TryConvert(ConvertBinder binder, out object result)
        {
            // <pex>
            if (binder == null)
                throw new ArgumentNullException("binder");
            // </pex>
            Type targetType = binder.Type;

            if ((targetType == typeof(IEnumerable)) ||
                (targetType == typeof(IEnumerable<KeyValuePair<string, object>>)) ||
                (targetType == typeof(IDictionary<string, object>)) ||
                (targetType == typeof(IDictionary)))
            {
                result = this;
                return true;
            }

            return base.TryConvert(binder, out result);
        }

        /// <summary>
        /// Provides the implementation for operations that delete an object member. This method is not intended for use in C# or Visual Basic.
        /// </summary>
        /// <param name="binder">Provides information about the deletion.</param>
        /// <returns>
        /// Alwasy returns true.
        /// </returns>
        public override bool TryDeleteMember(DeleteMemberBinder binder)
        {
            // <pex>
            if (binder == null)
                throw new ArgumentNullException("binder");
            // </pex>
            return this._members.Remove(binder.Name);
        }

        /// <summary>
        /// Provides the implementation for operations that get a value by index. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for indexing operations.
        /// </summary>
        /// <param name="binder">Provides information about the operation.</param>
        /// <param name="indexes">The indexes that are used in the operation. For example, for the sampleObject[3] operation in C# (sampleObject(3) in Visual Basic), where sampleObject is derived from the DynamicObject class, <paramref name="indexes"/> is equal to 3.</param>
        /// <param name="result">The result of the index operation.</param>
        /// <returns>
        /// Alwasy returns true.
        /// </returns>
        public override bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object result)
        {
            if (indexes == null) throw new ArgumentNullException("indexes");
            if (indexes.Length == 1)
            {
                result = ((IDictionary<string, object>)this)[(string)indexes[0]];
                return true;
            }
            result = null;
            return true;
        }

        /// <summary>
        /// Provides the implementation for operations that get member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations such as getting a value for a property.
        /// </summary>
        /// <param name="binder">Provides information about the object that called the dynamic operation. The binder.Name property provides the name of the member on which the dynamic operation is performed. For example, for the Console.WriteLine(sampleObject.SampleProperty) statement, where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, binder.Name returns "SampleProperty". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param>
        /// <param name="result">The result of the get operation. For example, if the method is called for a property, you can assign the property value to <paramref name="result"/>.</param>
        /// <returns>
        /// Alwasy returns true.
        /// </returns>
        public override bool TryGetMember(GetMemberBinder binder, out object result)
        {
            object value;
            if (this._members.TryGetValue(binder.Name, out value))
            {
                result = value;
                return true;
            }
            result = null;
            return true;
        }

        /// <summary>
        /// Provides the implementation for operations that set a value by index. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations that access objects by a specified index.
        /// </summary>
        /// <param name="binder">Provides information about the operation.</param>
        /// <param name="indexes">The indexes that are used in the operation. For example, for the sampleObject[3] = 10 operation in C# (sampleObject(3) = 10 in Visual Basic), where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, <paramref name="indexes"/> is equal to 3.</param>
        /// <param name="value">The value to set to the object that has the specified index. For example, for the sampleObject[3] = 10 operation in C# (sampleObject(3) = 10 in Visual Basic), where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, <paramref name="value"/> is equal to 10.</param>
        /// <returns>
        /// true if the operation is successful; otherwise, false. If this method returns false, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.
        /// </returns>
        public override bool TrySetIndex(SetIndexBinder binder, object[] indexes, object value)
        {
            if (indexes == null) throw new ArgumentNullException("indexes");
            if (indexes.Length == 1)
            {
                ((IDictionary<string, object>)this)[(string)indexes[0]] = value;
                return true;
            }
            return base.TrySetIndex(binder, indexes, value);
        }

        /// <summary>
        /// Provides the implementation for operations that set member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations such as setting a value for a property.
        /// </summary>
        /// <param name="binder">Provides information about the object that called the dynamic operation. The binder.Name property provides the name of the member to which the value is being assigned. For example, for the statement sampleObject.SampleProperty = "Test", where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, binder.Name returns "SampleProperty". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param>
        /// <param name="value">The value to set to the member. For example, for sampleObject.SampleProperty = "Test", where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, the <paramref name="value"/> is "Test".</param>
        /// <returns>
        /// true if the operation is successful; otherwise, false. If this method returns false, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)
        /// </returns>
        public override bool TrySetMember(SetMemberBinder binder, object value)
        {
            // <pex>
            if (binder == null)
                throw new ArgumentNullException("binder");
            // </pex>
            this._members[binder.Name] = value;
            return true;
        }

        /// <summary>
        /// Returns the enumeration of all dynamic member names.
        /// </summary>
        /// <returns>
        /// A sequence that contains dynamic member names.
        /// </returns>
        public override IEnumerable<string> GetDynamicMemberNames()
        {
            foreach (var key in this.Keys)
                yield return key;
        }
#endif
    }

    /// <summary>
    /// This class encodes and decodes JSON strings.
    /// Spec. details, see http://www.json.org/
    /// 
    /// JSON uses Arrays and Objects. These correspond here to the datatypes JsonArray(IList&lt;object>) and JsonObject(IDictionary&lt;string,object>).
    /// All numbers are parsed to doubles.
    /// </summary>
    [GeneratedCode("simple-json", "1.0.0")]
#if SIMPLE_JSON_INTERNAL
    internal
#else
    public
#endif
        static class SimpleJson
    {
        private const int TOKEN_NONE = 0;
        private const int TOKEN_CURLY_OPEN = 1;
        private const int TOKEN_CURLY_CLOSE = 2;
        private const int TOKEN_SQUARED_OPEN = 3;
        private const int TOKEN_SQUARED_CLOSE = 4;
        private const int TOKEN_COLON = 5;
        private const int TOKEN_COMMA = 6;
        private const int TOKEN_STRING = 7;
        private const int TOKEN_NUMBER = 8;
        private const int TOKEN_TRUE = 9;
        private const int TOKEN_FALSE = 10;
        private const int TOKEN_NULL = 11;
        private const int BUILDER_CAPACITY = 2000;

        private static readonly char[] EscapeTable;
        private static readonly char[] EscapeCharacters = new char[] { '"', '\\', '\b', '\f', '\n', '\r', '\t' };
        private static readonly string EscapeCharactersString = new string(EscapeCharacters);

        static SimpleJson()
        {
            EscapeTable = new char[93];
            EscapeTable['"'] = '"';
            EscapeTable['\\'] = '\\';
            EscapeTable['\b'] = 'b';
            EscapeTable['\f'] = 'f';
            EscapeTable['\n'] = 'n';
            EscapeTable['\r'] = 'r';
            EscapeTable['\t'] = 't';
        }

        /// <summary>
        /// Parses the string json into a value
        /// </summary>
        /// <param name="json">A JSON string.</param>
        /// <returns>An IList&lt;object>, a IDictionary&lt;string,object>, a double, a string, null, true, or false</returns>
        public static object DeserializeObject(string json)
        {
            object obj;
            if (TryDeserializeObject(json, out obj))
                return obj;
            throw new SerializationException("Invalid JSON string");
        }

        /// <summary>
        /// Try parsing the json string into a value.
        /// </summary>
        /// <param name="json">
        /// A JSON string.
        /// </param>
        /// <param name="obj">
        /// The object.
        /// </param>
        /// <returns>
        /// Returns true if successfull otherwise false.
        /// </returns>
        [SuppressMessage("Microsoft.Design", "CA1007:UseGenericsWhereAppropriate", Justification = "Need to support .NET 2")]
        public static bool TryDeserializeObject(string json, out object obj)
        {
            bool success = true;
            if (json != null)
            {
                char[] charArray = json.ToCharArray();
                int index = 0;
                obj = ParseValue(charArray, ref index, ref success);
            }
            else
                obj = null;

            return success;
        }

        public static object DeserializeObject(string json, Type type, IJsonSerializerStrategy jsonSerializerStrategy)
        {
            object jsonObject = DeserializeObject(json);
            return type == null || jsonObject != null && ReflectionUtils.IsAssignableFrom(jsonObject.GetType(), type)
                ? jsonObject
                : (jsonSerializerStrategy ?? CurrentJsonSerializerStrategy).DeserializeObject(jsonObject, type);
        }

        public static object DeserializeObject(string json, Type type)
        {
            return DeserializeObject(json, type, null);
        }

        public static T DeserializeObject<T>(string json, IJsonSerializerStrategy jsonSerializerStrategy)
        {
            return (T)DeserializeObject(json, typeof(T), jsonSerializerStrategy);
        }

        public static T DeserializeObject<T>(string json)
        {
            return (T)DeserializeObject(json, typeof(T), null);
        }

        /// <summary>
        /// Converts a IDictionary&lt;string,object> / IList&lt;object> object into a JSON string
        /// </summary>
        /// <param name="json">A IDictionary&lt;string,object> / IList&lt;object></param>
        /// <param name="jsonSerializerStrategy">Serializer strategy to use</param>
        /// <returns>A JSON encoded string, or null if object 'json' is not serializable</returns>
        public static string SerializeObject(object json, IJsonSerializerStrategy jsonSerializerStrategy)
        {
            StringBuilder builder = new StringBuilder(BUILDER_CAPACITY);
            bool success = SerializeValue(jsonSerializerStrategy, json, builder);
            return (success ? builder.ToString() : null);
        }

        public static string SerializeObject(object json)
        {
            return SerializeObject(json, CurrentJsonSerializerStrategy);
        }

        public static string EscapeToJavascriptString(string jsonString)
        {
            if (string.IsNullOrEmpty(jsonString))
                return jsonString;

            StringBuilder sb = new StringBuilder();
            char c;

            for (int i = 0; i < jsonString.Length;)
            {
                c = jsonString[i++];

                if (c == '\\')
                {
                    int remainingLength = jsonString.Length - i;
                    if (remainingLength >= 2)
                    {
                        char lookahead = jsonString[i];
                        if (lookahead == '\\')
                        {
                            sb.Append('\\');
                            ++i;
                        }
                        else if (lookahead == '"')
                        {
                            sb.Append("\"");
                            ++i;
                        }
                        else if (lookahead == 't')
                        {
                            sb.Append('\t');
                            ++i;
                        }
                        else if (lookahead == 'b')
                        {
                            sb.Append('\b');
                            ++i;
                        }
                        else if (lookahead == 'n')
                        {
                            sb.Append('\n');
                            ++i;
                        }
                        else if (lookahead == 'r')
                        {
                            sb.Append('\r');
                            ++i;
                        }
                    }
                }
                else
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }

        static IDictionary<string, object> ParseObject(char[] json, ref int index, ref bool success)
        {
            IDictionary<string, object> table = new JsonObject();
            int token;

            // {
            NextToken(json, ref index);

            bool done = false;
            while (!done)
            {
                token = LookAhead(json, index);
                if (token == TOKEN_NONE)
                {
                    success = false;
                    return null;
                }
                else if (token == TOKEN_COMMA)
                    NextToken(json, ref index);
                else if (token == TOKEN_CURLY_CLOSE)
                {
                    NextToken(json, ref index);
                    return table;
                }
                else
                {
                    // name
                    string name = ParseString(json, ref index, ref success);
                    if (!success)
                    {
                        success = false;
                        return null;
                    }
                    // :
                    token = NextToken(json, ref index);
                    if (token != TOKEN_COLON)
                    {
                        success = false;
                        return null;
                    }
                    // value
                    object value = ParseValue(json, ref index, ref success);
                    if (!success)
                    {
                        success = false;
                        return null;
                    }
                    table[name] = value;
                }
            }
            return table;
        }

        static JsonArray ParseArray(char[] json, ref int index, ref bool success)
        {
            JsonArray array = new JsonArray();

            // [
            NextToken(json, ref index);

            bool done = false;
            while (!done)
            {
                int token = LookAhead(json, index);
                if (token == TOKEN_NONE)
                {
                    success = false;
                    return null;
                }
                else if (token == TOKEN_COMMA)
                    NextToken(json, ref index);
                else if (token == TOKEN_SQUARED_CLOSE)
                {
                    NextToken(json, ref index);
                    break;
                }
                else
                {
                    object value = ParseValue(json, ref index, ref success);
                    if (!success)
                        return null;
                    array.Add(value);
                }
            }
            return array;
        }

        static object ParseValue(char[] json, ref int index, ref bool success)
        {
            switch (LookAhead(json, index))
            {
                case TOKEN_STRING:
                    return ParseString(json, ref index, ref success);
                case TOKEN_NUMBER:
                    return ParseNumber(json, ref index, ref success);
                case TOKEN_CURLY_OPEN:
                    return ParseObject(json, ref index, ref success);
                case TOKEN_SQUARED_OPEN:
                    return ParseArray(json, ref index, ref success);
                case TOKEN_TRUE:
                    NextToken(json, ref index);
                    return true;
                case TOKEN_FALSE:
                    NextToken(json, ref index);
                    return false;
                case TOKEN_NULL:
                    NextToken(json, ref index);
                    return null;
                case TOKEN_NONE:
                    break;
            }
            success = false;
            return null;
        }

        static string ParseString(char[] json, ref int index, ref bool success)
        {
            StringBuilder s = new StringBuilder(BUILDER_CAPACITY);
            char c;

            EatWhitespace(json, ref index);

            // "
            c = json[index++];
            bool complete = false;
            while (!complete)
            {
                if (index == json.Length)
                    break;

                c = json[index++];
                if (c == '"')
                {
                    complete = true;
                    break;
                }
                else if (c == '\\')
                {
                    if (index == json.Length)
                        break;
                    c = json[index++];
                    if (c == '"')
                        s.Append('"');
                    else if (c == '\\')
                        s.Append('\\');
                    else if (c == '/')
                        s.Append('/');
                    else if (c == 'b')
                        s.Append('\b');
                    else if (c == 'f')
                        s.Append('\f');
                    else if (c == 'n')
                        s.Append('\n');
                    else if (c == 'r')
                        s.Append('\r');
                    else if (c == 't')
                        s.Append('\t');
                    else if (c == 'u')
                    {
                        int remainingLength = json.Length - index;
                        if (remainingLength >= 4)
                        {
                            // parse the 32 bit hex into an integer codepoint
                            uint codePoint;
                            if (!(success = UInt32.TryParse(new string(json, index, 4), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out codePoint)))
                                return "";

                            // convert the integer codepoint to a unicode char and add to string
                            if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate
                            {
                                index += 4; // skip 4 chars
                                remainingLength = json.Length - index;
                                if (remainingLength >= 6)
                                {
                                    uint lowCodePoint;
                                    if (new string(json, index, 2) == "\\u" && UInt32.TryParse(new string(json, index + 2, 4), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out lowCodePoint))
                                    {
                                        if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate
                                        {
                                            s.Append((char)codePoint);
                                            s.Append((char)lowCodePoint);
                                            index += 6; // skip 6 chars
                                            continue;
                                        }
                                    }
                                }
                                success = false;    // invalid surrogate pair
                                return "";
                            }
                            s.Append(ConvertFromUtf32((int)codePoint));
                            // skip 4 chars
                            index += 4;
                        }
                        else
                            break;
                    }
                }
                else
                    s.Append(c);
            }
            if (!complete)
            {
                success = false;
                return null;
            }
            return s.ToString();
        }

        private static string ConvertFromUtf32(int utf32)
        {
            // http://www.java2s.com/Open-Source/CSharp/2.6.4-mono-.net-core/System/System/Char.cs.htm
            if (utf32 < 0 || utf32 > 0x10FFFF)
                throw new ArgumentOutOfRangeException("utf32", "The argument must be from 0 to 0x10FFFF.");
            if (0xD800 <= utf32 && utf32 <= 0xDFFF)
                throw new ArgumentOutOfRangeException("utf32", "The argument must not be in surrogate pair range.");
            if (utf32 < 0x10000)
                return new string((char)utf32, 1);
            utf32 -= 0x10000;
            return new string(new char[] { (char)((utf32 >> 10) + 0xD800), (char)(utf32 % 0x0400 + 0xDC00) });
        }

        static object ParseNumber(char[] json, ref int index, ref bool success)
        {
            EatWhitespace(json, ref index);
            int lastIndex = GetLastIndexOfNumber(json, index);
            int charLength = (lastIndex - index) + 1;
            object returnNumber;
            string str = new string(json, index, charLength);
            if (str.IndexOf(".", StringComparison.OrdinalIgnoreCase) != -1 || str.IndexOf("e", StringComparison.OrdinalIgnoreCase) != -1)
            {
                double number;
                success = double.TryParse(new string(json, index, charLength), NumberStyles.Any, CultureInfo.InvariantCulture, out number);
                returnNumber = number;
            }
            else
            {
                long number;
                success = long.TryParse(new string(json, index, charLength), NumberStyles.Any, CultureInfo.InvariantCulture, out number);
                returnNumber = number;
            }
            index = lastIndex + 1;
            return returnNumber;
        }

        static int GetLastIndexOfNumber(char[] json, int index)
        {
            int lastIndex;
            for (lastIndex = index; lastIndex < json.Length; lastIndex++)
                if ("0123456789+-.eE".IndexOf(json[lastIndex]) == -1) break;
            return lastIndex - 1;
        }

        static void EatWhitespace(char[] json, ref int index)
        {
            for (; index < json.Length; index++)
                if (" \t\n\r\b\f".IndexOf(json[index]) == -1) break;
        }

        static int LookAhead(char[] json, int index)
        {
            int saveIndex = index;
            return NextToken(json, ref saveIndex);
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        static int NextToken(char[] json, ref int index)
        {
            EatWhitespace(json, ref index);
            if (index == json.Length)
                return TOKEN_NONE;
            char c = json[index];
            index++;
            switch (c)
            {
                case '{':
                    return TOKEN_CURLY_OPEN;
                case '}':
                    return TOKEN_CURLY_CLOSE;
                case '[':
                    return TOKEN_SQUARED_OPEN;
                case ']':
                    return TOKEN_SQUARED_CLOSE;
                case ',':
                    return TOKEN_COMMA;
                case '"':
                    return TOKEN_STRING;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case '-':
                    return TOKEN_NUMBER;
                case ':':
                    return TOKEN_COLON;
            }
            index--;
            int remainingLength = json.Length - index;
            // false
            if (remainingLength >= 5)
            {
                if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')
                {
                    index += 5;
                    return TOKEN_FALSE;
                }
            }
            // true
            if (remainingLength >= 4)
            {
                if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')
                {
                    index += 4;
                    return TOKEN_TRUE;
                }
            }
            // null
            if (remainingLength >= 4)
            {
                if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')
                {
                    index += 4;
                    return TOKEN_NULL;
                }
            }
            return TOKEN_NONE;
        }

        static bool SerializeValue(IJsonSerializerStrategy jsonSerializerStrategy, object value, StringBuilder builder)
        {
            bool success = true;
            string stringValue = value as string;
            if (stringValue != null)
                success = SerializeString(stringValue, builder);
            else
            {
                IDictionary<string, object> dict = value as IDictionary<string, object>;
                if (dict != null)
                {
                    success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, builder);
                }
                else
                {
                    IDictionary<string, string> stringDictionary = value as IDictionary<string, string>;
                    if (stringDictionary != null)
                    {
                        success = SerializeObject(jsonSerializerStrategy, stringDictionary.Keys, stringDictionary.Values, builder);
                    }
                    else
                    {
                        IEnumerable enumerableValue = value as IEnumerable;
                        if (enumerableValue != null)
                            success = SerializeArray(jsonSerializerStrategy, enumerableValue, builder);
                        else if (IsNumeric(value))
                            success = SerializeNumber(value, builder);
                        else if (value is bool)
                            builder.Append((bool)value ? "true" : "false");
                        else if (value == null)
                            builder.Append("null");
                        else
                        {
                            object serializedObject;
                            success = jsonSerializerStrategy.TrySerializeNonPrimitiveObject(value, out serializedObject);
                            if (success)
                                SerializeValue(jsonSerializerStrategy, serializedObject, builder);
                        }
                    }
                }
            }
            return success;
        }

        static bool SerializeObject(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable keys, IEnumerable values, StringBuilder builder)
        {
            builder.Append("{");
            IEnumerator ke = keys.GetEnumerator();
            IEnumerator ve = values.GetEnumerator();
            bool first = true;
            while (ke.MoveNext() && ve.MoveNext())
            {
                object key = ke.Current;
                object value = ve.Current;
                if (!first)
                    builder.Append(",");
                string stringKey = key as string;
                if (stringKey != null)
                    SerializeString(jsonSerializerStrategy.MapDictionaryKeyToFieldName(stringKey), builder);
                else
                    if (!SerializeValue(jsonSerializerStrategy, value, builder)) return false;
                builder.Append(":");
                if (!SerializeValue(jsonSerializerStrategy, value, builder))
                    return false;
                first = false;
            }
            builder.Append("}");
            return true;
        }

        static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, StringBuilder builder)
        {
            builder.Append("[");
            bool first = true;
            foreach (object value in anArray)
            {
                if (!first)
                    builder.Append(",");
                if (!SerializeValue(jsonSerializerStrategy, value, builder))
                    return false;
                first = false;
            }
            builder.Append("]");
            return true;
        }

        static bool SerializeString(string aString, StringBuilder builder)
        {
            // Happy path if there's nothing to be escaped. IndexOfAny is highly optimized (and unmanaged)
            if (aString.IndexOfAny(EscapeCharacters) == -1)
            {
                builder.Append('"');
                builder.Append(aString);
                builder.Append('"');

                return true;
            }

            builder.Append('"');
            int safeCharacterCount = 0;
            char[] charArray = aString.ToCharArray();

            for (int i = 0; i < charArray.Length; i++)
            {
                char c = charArray[i];

                // Non ascii characters are fine, buffer them up and send them to the builder
                // in larger chunks if possible. The escape table is a 1:1 translation table
                // with \0 [default(char)] denoting a safe character.
                if (c >= EscapeTable.Length || EscapeTable[c] == default(char))
                {
                    safeCharacterCount++;
                }
                else
                {
                    if (safeCharacterCount > 0)
                    {
                        builder.Append(charArray, i - safeCharacterCount, safeCharacterCount);
                        safeCharacterCount = 0;
                    }

                    builder.Append('\\');
                    builder.Append(EscapeTable[c]);
                }
            }

            if (safeCharacterCount > 0)
            {
                builder.Append(charArray, charArray.Length - safeCharacterCount, safeCharacterCount);
            }

            builder.Append('"');
            return true;
        }

        static bool SerializeNumber(object number, StringBuilder builder)
        {
            if (number is long)
                builder.Append(((long)number).ToString(CultureInfo.InvariantCulture));
            else if (number is ulong)
                builder.Append(((ulong)number).ToString(CultureInfo.InvariantCulture));
            else if (number is int)
                builder.Append(((int)number).ToString(CultureInfo.InvariantCulture));
            else if (number is uint)
                builder.Append(((uint)number).ToString(CultureInfo.InvariantCulture));
            else if (number is decimal)
                builder.Append(((decimal)number).ToString(CultureInfo.InvariantCulture));
            else if (number is float)
                builder.Append(((float)number).ToString(CultureInfo.InvariantCulture));
            else
                builder.Append(Convert.ToDouble(number, CultureInfo.InvariantCulture).ToString("r", CultureInfo.InvariantCulture));
            return true;
        }

        /// <summary>
        /// Determines if a given object is numeric in any way
        /// (can be integer, double, null, etc).
        /// </summary>
        static bool IsNumeric(object value)
        {
            if (value is sbyte) return true;
            if (value is byte) return true;
            if (value is short) return true;
            if (value is ushort) return true;
            if (value is int) return true;
            if (value is uint) return true;
            if (value is long) return true;
            if (value is ulong) return true;
            if (value is float) return true;
            if (value is double) return true;
            if (value is decimal) return true;
            return false;
        }

        private static IJsonSerializerStrategy _currentJsonSerializerStrategy;
        public static IJsonSerializerStrategy CurrentJsonSerializerStrategy
        {
            get
            {
                return _currentJsonSerializerStrategy ??
                    (_currentJsonSerializerStrategy =
#if SIMPLE_JSON_DATACONTRACT
 DataContractJsonSerializerStrategy
#else
                        PocoJsonSerializerStrategy
#endif
                        );
            }
            set
            {
                _currentJsonSerializerStrategy = value;
            }
        }

        private static PocoJsonSerializerStrategy _pocoJsonSerializerStrategy;
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public static PocoJsonSerializerStrategy PocoJsonSerializerStrategy
        {
            get
            {
                return _pocoJsonSerializerStrategy ?? (_pocoJsonSerializerStrategy = new PocoJsonSerializerStrategy());
            }
        }

#if SIMPLE_JSON_DATACONTRACT

        private static DataContractJsonSerializerStrategy _dataContractJsonSerializerStrategy;
        [System.ComponentModel.EditorBrowsable(EditorBrowsableState.Advanced)]
        public static DataContractJsonSerializerStrategy DataContractJsonSerializerStrategy
        {
            get
            {
                return _dataContractJsonSerializerStrategy ?? (_dataContractJsonSerializerStrategy = new DataContractJsonSerializerStrategy());
            }
        }

#endif
    }

    [GeneratedCode("simple-json", "1.0.0")]
#if SIMPLE_JSON_INTERNAL
    internal
#else
    public
#endif
        interface IJsonSerializerStrategy
    {
        [SuppressMessage("Microsoft.Design", "CA1007:UseGenericsWhereAppropriate", Justification = "Need to support .NET 2")]
        bool TrySerializeNonPrimitiveObject(object input, out object output);
        object DeserializeObject(object value, Type type);

        string MapDictionaryKeyToFieldName(string stringKey);
    }

    [GeneratedCode("simple-json", "1.0.0")]
#if SIMPLE_JSON_INTERNAL
    internal
#else
    public
#endif
        class PocoJsonSerializerStrategy : IJsonSerializerStrategy
    {
        internal static IDictionary<Type, ReflectionUtils.ConstructorDelegate> ConstructorCache;
        internal static IDictionary<Type, IDictionary<string, ReflectionUtils.GetDelegate>> GetCache;
        internal static IDictionary<Type, IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>>> SetCache;

        internal static readonly Type[] EmptyTypes = ArrayCache.Empty<Type>();
        internal static readonly Type[] ArrayConstructorParameterTypes = new Type[] { typeof(int) };
        protected static string FullDateTimeWithOffset = @"yyyy-MM-dd\THH:mm:ss.fffffffzzz";
        protected static string FullDateTimeUtc = @"yyyy-MM-dd\THH:mm:ss.fffffff\Z";

        private static readonly string[] Iso8601Format = new string[]
        {
            FullDateTimeWithOffset,
            @"yyyy-MM-dd\THH:mm:ss.FFFFFFFK",
            FullDateTimeUtc,
            @"yyyy-MM-dd\THH:mm:ss\Z",
            @"yyyy-MM-dd\THH:mm:ssK"
        };


        static PocoJsonSerializerStrategy()
        {
            ConstructorCache = new ReflectionUtils.ThreadSafeDictionary<Type, ReflectionUtils.ConstructorDelegate>(ContructorDelegateFactory);
            GetCache = new ReflectionUtils.ThreadSafeDictionary<Type, IDictionary<string, ReflectionUtils.GetDelegate>>(GetterValueFactory);
            SetCache = new ReflectionUtils.ThreadSafeDictionary<Type, IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>>>(SetterValueFactory);
        }

        public string MapDictionaryKeyToFieldName(string stringKey)
        {
            return this.MapClrMemberNameToJsonFieldName(stringKey);
        }

        protected virtual string MapClrMemberNameToJsonFieldName(string clrPropertyName)
        {
            return clrPropertyName;
        }

        internal static ReflectionUtils.ConstructorDelegate ContructorDelegateFactory(Type key)
        {
            return ReflectionUtils.GetContructor(key, key.IsArray ? ArrayConstructorParameterTypes : EmptyTypes);
        }

        internal static IDictionary<string, ReflectionUtils.GetDelegate> GetterValueFactory(Type type)
        {
            IDictionary<string, ReflectionUtils.GetDelegate> result = new Dictionary<string, ReflectionUtils.GetDelegate>();
            foreach (PropertyInfo propertyInfo in ReflectionUtils.GetProperties(type))
            {
                if (propertyInfo.CanRead && !Nancy.Helpers.ReflectionUtils.IsIndexedProperty(propertyInfo))
                {
                    MethodInfo getMethod = ReflectionUtils.GetGetterMethodInfo(propertyInfo);
                    if (getMethod.IsStatic || !getMethod.IsPublic)
                        continue;
                    result[propertyInfo.Name] = ReflectionUtils.GetGetMethod(propertyInfo);
                }
            }
            foreach (FieldInfo fieldInfo in ReflectionUtils.GetFields(type))
            {
                if (fieldInfo.IsStatic || !fieldInfo.IsPublic)
                    continue;
                result[fieldInfo.Name] = ReflectionUtils.GetGetMethod(fieldInfo);
            }
            return result;
        }

        internal static IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>> SetterValueFactory(Type type)
        {
            IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>> result = new Dictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>>();
            foreach (PropertyInfo propertyInfo in ReflectionUtils.GetProperties(type))
            {
                if (propertyInfo.CanWrite && !Nancy.Helpers.ReflectionUtils.IsIndexedProperty(propertyInfo))
                {
                    MethodInfo setMethod = ReflectionUtils.GetSetterMethodInfo(propertyInfo);
                    if (setMethod.IsStatic || !setMethod.IsPublic)
                        continue;
                    result[propertyInfo.Name] = new KeyValuePair<Type, ReflectionUtils.SetDelegate>(propertyInfo.PropertyType, ReflectionUtils.GetSetMethod(propertyInfo));
                }
            }
            foreach (FieldInfo fieldInfo in ReflectionUtils.GetFields(type))
            {
                if (fieldInfo.IsInitOnly || fieldInfo.IsStatic || !fieldInfo.IsPublic)
                    continue;
                result[fieldInfo.Name] = new KeyValuePair<Type, ReflectionUtils.SetDelegate>(fieldInfo.FieldType, ReflectionUtils.GetSetMethod(fieldInfo));
            }
            return result;
        }

        public virtual bool TrySerializeNonPrimitiveObject(object input, out object output)
        {
            return this.TrySerializeKnownTypes(input, out output) || this.TrySerializeUnknownTypes(input, out output);
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public virtual object DeserializeObject(object value, Type type)
        {
            if (type == null) throw new ArgumentNullException("type");
            string str = value as string;

            if (type == typeof(Guid) && string.IsNullOrEmpty(str))
                return default(Guid);

            if (value == null)
                return null;

            object obj = null;

            if (str != null)
            {
                if (str.Length != 0) // We know it can't be null now.
                {
                    if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime)))
                        return DateTime.ParseExact(str, Iso8601Format, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal);
                    if (type == typeof(DateTimeOffset) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTimeOffset)))
                        return DateTimeOffset.ParseExact(str, Iso8601Format, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal);
                    if (type == typeof(Guid) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(Guid)))
                        return new Guid(str);
                    if (type == typeof(Uri))
                    {
                        bool isValid = Uri.IsWellFormedUriString(str, UriKind.RelativeOrAbsolute);

                        Uri result;
                        if (isValid && Uri.TryCreate(str, UriKind.RelativeOrAbsolute, out result))
                            return result;

                        return null;
                    }

                    if (type == typeof(string))
                        return str;

                    return Convert.ChangeType(str, type, CultureInfo.InvariantCulture);
                }
                else
                {
                    if (type == typeof(Guid))
                        obj = default(Guid);
                    else if (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(Guid))
                        obj = null;
                    else
                        obj = str;
                }
                // Empty string case
                if (!ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(Guid))
                    return str;
            }
            else if (value is bool)
                return value;

            bool valueIsLong = value is long;
            bool valueIsDouble = value is double;
            if ((valueIsLong && type == typeof(long)) || (valueIsDouble && type == typeof(double)))
                return value;
            if ((valueIsDouble && type != typeof(double)) || (valueIsLong && type != typeof(long)))
            {
                obj = type == typeof(int) || type == typeof(uint) || type == typeof(long) || type == typeof(double) || type == typeof(float) || type == typeof(bool) || type == typeof(decimal) || type == typeof(byte) || type == typeof(short)
                    ? Convert.ChangeType(value, type, CultureInfo.InvariantCulture)
                    : value;
            }
            else
            {
                IDictionary<string, object> objects = value as IDictionary<string, object>;
                if (objects != null)
                {
                    IDictionary<string, object> jsonObject = objects;

                    if (ReflectionUtils.IsTypeDictionary(type))
                    {
                        // if dictionary then
                        Type[] types = ReflectionUtils.GetGenericTypeArguments(type);
                        Type keyType = types[0];
                        Type valueType = types[1];

                        Type genericType = typeof(Dictionary<,>).MakeGenericType(keyType, valueType);

                        IDictionary dict = (IDictionary)ConstructorCache[genericType]();

                        foreach (KeyValuePair<string, object> kvp in jsonObject)
                            dict.Add(kvp.Key, this.DeserializeObject(kvp.Value, valueType));

                        obj = dict;
                    }
                    else
                    {
                        if (type == typeof(object))
                            obj = value;
                        else
                        {
                            obj = ConstructorCache[type]();
                            foreach (KeyValuePair<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>> setter in SetCache[type])
                            {
                                object jsonValue;
                                if (jsonObject.TryGetValue(setter.Key, out jsonValue))
                                {
                                    jsonValue = this.DeserializeObject(jsonValue, setter.Value.Key);
                                    setter.Value.Value(obj, jsonValue);
                                }
                            }
                        }
                    }
                }
                else
                {
                    IList<object> valueAsList = value as IList<object>;
                    if (valueAsList != null)
                    {
                        IList<object> jsonObject = valueAsList;
                        IList list = null;

                        if (type.IsArray)
                        {
                            list = (IList)ConstructorCache[type](jsonObject.Count);
                            int i = 0;
                            foreach (object o in jsonObject)
                                list[i++] = this.DeserializeObject(o, type.GetElementType());
                        }
                        else if (ReflectionUtils.IsTypeGenericeCollectionInterface(type) || ReflectionUtils.IsAssignableFrom(typeof(IList), type))
                        {
                            Type innerType = ReflectionUtils.GetGenericListElementType(type);
                            list = (IList)(ConstructorCache[type] ?? ConstructorCache[typeof(List<>).MakeGenericType(innerType)])(jsonObject.Count);
                            foreach (object o in jsonObject)
                                list.Add(this.DeserializeObject(o, innerType));
                        }
                        obj = list;
                    }
                }
                return obj;
            }
            if (ReflectionUtils.IsNullableType(type))
                return ReflectionUtils.ToNullableType(obj, type);
            return obj;
        }


        protected virtual object SerializeEnum(Enum p)
        {
            return Convert.ToDouble(p, CultureInfo.InvariantCulture);
        }

        [SuppressMessage("Microsoft.Design", "CA1007:UseGenericsWhereAppropriate", Justification = "Need to support .NET 2")]
        protected virtual bool TrySerializeKnownTypes(object input, out object output)
        {
            bool returnValue = true;
            if (input is DateTime)
                output = ((DateTime)input).ToUniversalTime().ToString(Iso8601Format[0], CultureInfo.InvariantCulture);
            else if (input is DateTimeOffset)
                output = ((DateTimeOffset)input).ToUniversalTime().ToString(Iso8601Format[0], CultureInfo.InvariantCulture);
            else if (input is Guid)
                output = ((Guid)input).ToString("D");
            else if (input is Uri)
                output = input.ToString();
            else
            {
                Enum inputEnum = input as Enum;
                if (inputEnum != null)
                    output = this.SerializeEnum(inputEnum);
                else
                {
                    returnValue = false;
                    output = null;
                }
            }
            return returnValue;
        }
        [SuppressMessage("Microsoft.Design", "CA1007:UseGenericsWhereAppropriate", Justification = "Need to support .NET 2")]
        protected virtual bool TrySerializeUnknownTypes(object input, out object output)
        {
            if (input == null) throw new ArgumentNullException("input");
            output = null;
            Type type = input.GetType();
            if (type.FullName == null)
                return false;
            IDictionary<string, object> obj = new JsonObject();
            IDictionary<string, ReflectionUtils.GetDelegate> getters = GetCache[type];
            foreach (KeyValuePair<string, ReflectionUtils.GetDelegate> getter in getters)
            {
                if (getter.Value != null)
                    obj.Add(this.MapClrMemberNameToJsonFieldName(getter.Key), getter.Value(input));
            }
            output = obj;
            return true;
        }
    }

#if SIMPLE_JSON_DATACONTRACT
    [GeneratedCode("simple-json", "1.0.0")]
#if SIMPLE_JSON_INTERNAL
    internal
#else
    public
#endif
 class DataContractJsonSerializerStrategy : PocoJsonSerializerStrategy
    {
        public DataContractJsonSerializerStrategy()
        {
            GetCache = new ReflectionUtils.ThreadSafeDictionary<Type, IDictionary<string, ReflectionUtils.GetDelegate>>(GetterValueFactory);
            SetCache = new ReflectionUtils.ThreadSafeDictionary<Type, IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>>>(SetterValueFactory);
        }

        internal override IDictionary<string, ReflectionUtils.GetDelegate> GetterValueFactory(Type type)
        {
            bool hasDataContract = ReflectionUtils.GetAttribute(type, typeof(DataContractAttribute)) != null;
            if (!hasDataContract)
                return base.GetterValueFactory(type);
            string jsonKey;
            IDictionary<string, ReflectionUtils.GetDelegate> result = new Dictionary<string, ReflectionUtils.GetDelegate>();
            foreach (PropertyInfo propertyInfo in ReflectionUtils.GetProperties(type))
            {
                if (propertyInfo.CanRead)
                {
                    MethodInfo getMethod = ReflectionUtils.GetGetterMethodInfo(propertyInfo);
                    if (!getMethod.IsStatic && CanAdd(propertyInfo, out jsonKey))
                        result[jsonKey] = ReflectionUtils.GetGetMethod(propertyInfo);
                }
            }
            foreach (FieldInfo fieldInfo in ReflectionUtils.GetFields(type))
            {
                if (!fieldInfo.IsStatic && CanAdd(fieldInfo, out jsonKey))
                    result[jsonKey] = ReflectionUtils.GetGetMethod(fieldInfo);
            }
            return result;
        }

        internal override IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>> SetterValueFactory(Type type)
        {
            bool hasDataContract = ReflectionUtils.GetAttribute(type, typeof(DataContractAttribute)) != null;
            if (!hasDataContract)
                return base.SetterValueFactory(type);
            string jsonKey;
            IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>> result = new Dictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>>();
            foreach (PropertyInfo propertyInfo in ReflectionUtils.GetProperties(type))
            {
                if (propertyInfo.CanWrite)
                {
                    MethodInfo setMethod = ReflectionUtils.GetSetterMethodInfo(propertyInfo);
                    if (!setMethod.IsStatic && CanAdd(propertyInfo, out jsonKey))
                        result[jsonKey] = new KeyValuePair<Type, ReflectionUtils.SetDelegate>(propertyInfo.PropertyType, ReflectionUtils.GetSetMethod(propertyInfo));
                }
            }
            foreach (FieldInfo fieldInfo in ReflectionUtils.GetFields(type))
            {
                if (!fieldInfo.IsInitOnly && !fieldInfo.IsStatic && CanAdd(fieldInfo, out jsonKey))
                    result[jsonKey] = new KeyValuePair<Type, ReflectionUtils.SetDelegate>(fieldInfo.FieldType, ReflectionUtils.GetSetMethod(fieldInfo));
            }
            // todo implement sorting for DATACONTRACT.
            return result;
        }

        private static bool CanAdd(MemberInfo info, out string jsonKey)
        {
            jsonKey = null;
            if (ReflectionUtils.GetAttribute(info, typeof(IgnoreDataMemberAttribute)) != null)
                return false;
            DataMemberAttribute dataMemberAttribute = (DataMemberAttribute)ReflectionUtils.GetAttribute(info, typeof(DataMemberAttribute));
            if (dataMemberAttribute == null)
                return false;
            jsonKey = string.IsNullOrEmpty(dataMemberAttribute.Name) ? info.Name : dataMemberAttribute.Name;
            return true;
        }
    }

#endif

    // This class is meant to be copied into other libraries. So we want to exclude it from Code Analysis rules
    // that might be in place in the target project.
    [GeneratedCode("reflection-utils", "1.0.0")]
#if SIMPLE_JSON_REFLECTION_UTILS_PUBLIC
        public
#else
    internal
#endif
        class ReflectionUtils
    {
        private static readonly object[] EmptyObjects = new object[] { };

        public delegate object GetDelegate(object source);
        public delegate void SetDelegate(object source, object value);
        public delegate object ConstructorDelegate(params object[] args);

        public delegate TValue ThreadSafeDictionaryValueFactory<TKey, TValue>(TKey key);

#if SIMPLE_JSON_TYPEINFO
        public static TypeInfo GetTypeInfo(Type type)
        {
            return type.GetTypeInfo();
        }
#else
        public static Type GetTypeInfo(Type type)
        {
            return type;
        }
#endif

        public static Attribute GetAttribute(MemberInfo info, Type type)
        {
#if SIMPLE_JSON_TYPEINFO
            if (info == null || type == null || !info.IsDefined(type))
                return null;
            return info.GetCustomAttribute(type);
#else
            if (info == null || type == null || !Attribute.IsDefined(info, type))
                return null;
            return Attribute.GetCustomAttribute(info, type);
#endif
        }

        public static Type GetGenericListElementType(Type type)
        {
            IEnumerable<Type> interfaces;
#if SIMPLE_JSON_TYPEINFO
            interfaces = type.GetTypeInfo().ImplementedInterfaces;
#else
            interfaces = type.GetInterfaces();
#endif
            foreach (Type implementedInterface in interfaces)
            {
                if (IsTypeGeneric(implementedInterface) &&
                    implementedInterface.GetGenericTypeDefinition() == typeof(IList<>))
                {
                    return GetGenericTypeArguments(implementedInterface)[0];
                }
            }
            return GetGenericTypeArguments(type)[0];
        }

        public static Attribute GetAttribute(Type objectType, Type attributeType)
        {

#if SIMPLE_JSON_TYPEINFO
            if (objectType == null || attributeType == null || !objectType.GetTypeInfo().IsDefined(attributeType))
                return null;
            return objectType.GetTypeInfo().GetCustomAttribute(attributeType);
#else
            if (objectType == null || attributeType == null || !Attribute.IsDefined(objectType, attributeType))
                return null;
            return Attribute.GetCustomAttribute(objectType, attributeType);
#endif
        }

        public static Type[] GetGenericTypeArguments(Type type)
        {
#if SIMPLE_JSON_TYPEINFO
            return type.GetTypeInfo().GenericTypeArguments;
#else
            return type.GetGenericArguments();
#endif
        }

        public static bool IsTypeGeneric(Type type)
        {
            return GetTypeInfo(type).IsGenericType;
        }

        public static bool IsTypeGenericeCollectionInterface(Type type)
        {
            if (!IsTypeGeneric(type))
                return false;

            Type genericDefinition = type.GetGenericTypeDefinition();

            return (genericDefinition == typeof(IList<>)
                || genericDefinition == typeof(ICollection<>)
                || genericDefinition == typeof(IEnumerable<>)
#if SIMPLE_JSON_READONLY_COLLECTIONS
                    || genericDefinition == typeof(IReadOnlyCollection<>)
                    || genericDefinition == typeof(IReadOnlyList<>)
#endif
                );
        }

        public static bool IsAssignableFrom(Type type1, Type type2)
        {
            return GetTypeInfo(type1).IsAssignableFrom(GetTypeInfo(type2));
        }

        public static bool IsTypeDictionary(Type type)
        {
#if SIMPLE_JSON_TYPEINFO
            if (typeof(IDictionary<,>).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))
                return true;
#else
            if (typeof(System.Collections.IDictionary).IsAssignableFrom(type))
                return true;
#endif
            if (!GetTypeInfo(type).IsGenericType)
                return false;

            Type genericDefinition = type.GetGenericTypeDefinition();
            return genericDefinition == typeof(IDictionary<,>);
        }

        public static bool IsNullableType(Type type)
        {
            return GetTypeInfo(type).IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>);
        }

        public static object ToNullableType(object obj, Type nullableType)
        {
            return obj == null ? null : Convert.ChangeType(obj, Nullable.GetUnderlyingType(nullableType), CultureInfo.InvariantCulture);
        }

        public static bool IsValueType(Type type)
        {
            return GetTypeInfo(type).IsValueType;
        }

        public static IEnumerable<ConstructorInfo> GetConstructors(Type type)
        {
#if SIMPLE_JSON_TYPEINFO
            return type.GetTypeInfo().DeclaredConstructors;
#else
            return type.GetConstructors();
#endif
        }

        public static ConstructorInfo GetConstructorInfo(Type type, params Type[] argsType)
        {
            IEnumerable<ConstructorInfo> constructorInfos = GetConstructors(type);
            int i;
            bool matches;
            foreach (ConstructorInfo constructorInfo in constructorInfos)
            {
                ParameterInfo[] parameters = constructorInfo.GetParameters();
                if (argsType.Length != parameters.Length)
                    continue;

                i = 0;
                matches = true;
                foreach (ParameterInfo parameterInfo in constructorInfo.GetParameters())
                {
                    if (parameterInfo.ParameterType != argsType[i])
                    {
                        matches = false;
                        break;
                    }
                }

                if (matches)
                    return constructorInfo;
            }

            return null;
        }

        public static IEnumerable<PropertyInfo> GetProperties(Type type)
        {
#if SIMPLE_JSON_TYPEINFO
            return type.GetRuntimeProperties();
#else
            return type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
#endif
        }

        public static IEnumerable<FieldInfo> GetFields(Type type)
        {
#if SIMPLE_JSON_TYPEINFO
            return type.GetRuntimeFields();
#else
            return type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
#endif
        }

        public static MethodInfo GetGetterMethodInfo(PropertyInfo propertyInfo)
        {
#if SIMPLE_JSON_TYPEINFO
            return propertyInfo.GetMethod;
#else
            return propertyInfo.GetGetMethod(true);
#endif
        }

        public static MethodInfo GetSetterMethodInfo(PropertyInfo propertyInfo)
        {
#if SIMPLE_JSON_TYPEINFO
            return propertyInfo.SetMethod;
#else
            return propertyInfo.GetSetMethod(true);
#endif
        }

        public static ConstructorDelegate GetContructor(ConstructorInfo constructorInfo)
        {
#if SIMPLE_JSON_NO_LINQ_EXPRESSION
                return GetConstructorByReflection(constructorInfo);
#else
            return GetConstructorByExpression(constructorInfo);
#endif
        }

        public static ConstructorDelegate GetContructor(Type type, params Type[] argsType)
        {
#if SIMPLE_JSON_NO_LINQ_EXPRESSION
                return GetConstructorByReflection(type, argsType);
#else
            return GetConstructorByExpression(type, argsType);
#endif
        }

        public static ConstructorDelegate GetConstructorByReflection(ConstructorInfo constructorInfo)
        {
            return delegate (object[] args) { return constructorInfo.Invoke(args); };
        }

        public static ConstructorDelegate GetConstructorByReflection(Type type, params Type[] argsType)
        {
            ConstructorInfo constructorInfo = GetConstructorInfo(type, argsType);
            return constructorInfo == null ? null : GetConstructorByReflection(constructorInfo);
        }

#if !SIMPLE_JSON_NO_LINQ_EXPRESSION

        public static ConstructorDelegate GetConstructorByExpression(ConstructorInfo constructorInfo)
        {
            ParameterInfo[] paramsInfo = constructorInfo.GetParameters();
            ParameterExpression param = Expression.Parameter(typeof(object[]), "args");
            Expression[] argsExp = new Expression[paramsInfo.Length];
            for (int i = 0; i < paramsInfo.Length; i++)
            {
                Expression index = Expression.Constant(i);
                Type paramType = paramsInfo[i].ParameterType;
                Expression paramAccessorExp = Expression.ArrayIndex(param, index);
                Expression paramCastExp = Expression.Convert(paramAccessorExp, paramType);
                argsExp[i] = paramCastExp;
            }
            NewExpression newExp = Expression.New(constructorInfo, argsExp);
            Expression<Func<object[], object>> lambda = Expression.Lambda<Func<object[], object>>(newExp, param);
            Func<object[], object> compiledLambda = lambda.Compile();
            return delegate (object[] args) { return compiledLambda(args); };
        }

        public static ConstructorDelegate GetConstructorByExpression(Type type, params Type[] argsType)
        {
            ConstructorInfo constructorInfo = GetConstructorInfo(type, argsType);
            return constructorInfo == null ? null : GetConstructorByExpression(constructorInfo);
        }

#endif

        public static GetDelegate GetGetMethod(PropertyInfo propertyInfo)
        {
#if SIMPLE_JSON_NO_LINQ_EXPRESSION
                return GetGetMethodByReflection(propertyInfo);
#else
            return GetGetMethodByExpression(propertyInfo);
#endif
        }

        public static GetDelegate GetGetMethod(FieldInfo fieldInfo)
        {
#if SIMPLE_JSON_NO_LINQ_EXPRESSION
                return GetGetMethodByReflection(fieldInfo);
#else
            return GetGetMethodByExpression(fieldInfo);
#endif
        }

        public static GetDelegate GetGetMethodByReflection(PropertyInfo propertyInfo)
        {
            MethodInfo methodInfo = GetGetterMethodInfo(propertyInfo);
            return delegate (object source) { return methodInfo.Invoke(source, EmptyObjects); };
        }

        public static GetDelegate GetGetMethodByReflection(FieldInfo fieldInfo)
        {
            return delegate (object source) { return fieldInfo.GetValue(source); };
        }

#if !SIMPLE_JSON_NO_LINQ_EXPRESSION

        public static GetDelegate GetGetMethodByExpression(PropertyInfo propertyInfo)
        {
            MethodInfo getMethodInfo = GetGetterMethodInfo(propertyInfo);
            ParameterExpression instance = Expression.Parameter(typeof(object), "instance");
            UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance, propertyInfo.DeclaringType) : Expression.Convert(instance, propertyInfo.DeclaringType);
            Func<object, object> compiled = Expression.Lambda<Func<object, object>>(Expression.TypeAs(Expression.Call(instanceCast, getMethodInfo), typeof(object)), instance).Compile();
            return delegate (object source) { return compiled(source); };
        }

        public static GetDelegate GetGetMethodByExpression(FieldInfo fieldInfo)
        {
            ParameterExpression instance = Expression.Parameter(typeof(object), "instance");
            MemberExpression member = Expression.Field(Expression.Convert(instance, fieldInfo.DeclaringType), fieldInfo);
            GetDelegate compiled = Expression.Lambda<GetDelegate>(Expression.Convert(member, typeof(object)), instance).Compile();
            return delegate (object source) { return compiled(source); };
        }

#endif

        public static SetDelegate GetSetMethod(PropertyInfo propertyInfo)
        {
#if SIMPLE_JSON_NO_LINQ_EXPRESSION
                return GetSetMethodByReflection(propertyInfo);
#else
            return GetSetMethodByExpression(propertyInfo);
#endif
        }

        public static SetDelegate GetSetMethod(FieldInfo fieldInfo)
        {
#if SIMPLE_JSON_NO_LINQ_EXPRESSION
                return GetSetMethodByReflection(fieldInfo);
#else
            return GetSetMethodByExpression(fieldInfo);
#endif
        }

        public static SetDelegate GetSetMethodByReflection(PropertyInfo propertyInfo)
        {
            MethodInfo methodInfo = GetSetterMethodInfo(propertyInfo);
            return delegate (object source, object value) { methodInfo.Invoke(source, new object[] { value }); };
        }

        public static SetDelegate GetSetMethodByReflection(FieldInfo fieldInfo)
        {
            return delegate (object source, object value) { fieldInfo.SetValue(source, value); };
        }

#if !SIMPLE_JSON_NO_LINQ_EXPRESSION

        public static SetDelegate GetSetMethodByExpression(PropertyInfo propertyInfo)
        {
            MethodInfo setMethodInfo = GetSetterMethodInfo(propertyInfo);
            ParameterExpression instance = Expression.Parameter(typeof(object), "instance");
            ParameterExpression value = Expression.Parameter(typeof(object), "value");
            UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance, propertyInfo.DeclaringType) : Expression.Convert(instance, propertyInfo.DeclaringType);
            UnaryExpression valueCast = (!IsValueType(propertyInfo.PropertyType)) ? Expression.TypeAs(value, propertyInfo.PropertyType) : Expression.Convert(value, propertyInfo.PropertyType);
            Action<object, object> compiled = Expression.Lambda<Action<object, object>>(Expression.Call(instanceCast, setMethodInfo, valueCast), new ParameterExpression[] { instance, value }).Compile();
            return delegate (object source, object val) { compiled(source, val); };
        }

        public static SetDelegate GetSetMethodByExpression(FieldInfo fieldInfo)
        {
            ParameterExpression instance = Expression.Parameter(typeof(object), "instance");
            ParameterExpression value = Expression.Parameter(typeof(object), "value");
            Action<object, object> compiled = Expression.Lambda<Action<object, object>>(
                Assign(Expression.Field(Expression.Convert(instance, fieldInfo.DeclaringType), fieldInfo), Expression.Convert(value, fieldInfo.FieldType)), instance, value).Compile();
            return delegate (object source, object val) { compiled(source, val); };
        }

        public static BinaryExpression Assign(Expression left, Expression right)
        {
#if SIMPLE_JSON_TYPEINFO
            return Expression.Assign(left, right);
#else
            MethodInfo assign = typeof(Assigner<>).MakeGenericType(left.Type).GetMethod("Assign");
            BinaryExpression assignExpr = Expression.Add(left, right, assign);
            return assignExpr;
#endif
        }

        private static class Assigner<T>
        {
            public static T Assign(ref T left, T right)
            {
                return (left = right);
            }
        }

#endif

        public sealed class ThreadSafeDictionary<TKey, TValue> : IDictionary<TKey, TValue>
        {
            private readonly object _lock = new object();
            private readonly ThreadSafeDictionaryValueFactory<TKey, TValue> _valueFactory;
            private Dictionary<TKey, TValue> _dictionary;

            public ThreadSafeDictionary(ThreadSafeDictionaryValueFactory<TKey, TValue> valueFactory)
            {
                this._valueFactory = valueFactory;
            }

            private TValue Get(TKey key)
            {
                if (this._dictionary == null)
                    return this.AddValue(key);
                TValue value;
                if (!this._dictionary.TryGetValue(key, out value))
                    return this.AddValue(key);
                return value;
            }

            private TValue AddValue(TKey key)
            {
                TValue value = this._valueFactory(key);
                lock (this._lock)
                {
                    if (this._dictionary == null)
                    {
                        this._dictionary = new Dictionary<TKey, TValue>();
                        this._dictionary[key] = value;
                    }
                    else
                    {
                        TValue val;
                        if (this._dictionary.TryGetValue(key, out val))
                            return val;
                        Dictionary<TKey, TValue> dict = new Dictionary<TKey, TValue>(this._dictionary);
                        dict[key] = value;
                        this._dictionary = dict;
                    }
                }
                return value;
            }

            public void Add(TKey key, TValue value)
            {
                throw new NotImplementedException();
            }

            public bool ContainsKey(TKey key)
            {
                return this._dictionary.ContainsKey(key);
            }

            public ICollection<TKey> Keys
            {
                get { return this._dictionary.Keys; }
            }

            public bool Remove(TKey key)
            {
                throw new NotImplementedException();
            }

            public bool TryGetValue(TKey key, out TValue value)
            {
                value = this[key];
                return true;
            }

            public ICollection<TValue> Values
            {
                get { return this._dictionary.Values; }
            }

            public TValue this[TKey key]
            {
                get { return this.Get(key); }
                set { throw new NotImplementedException(); }
            }

            public void Add(KeyValuePair<TKey, TValue> item)
            {
                throw new NotImplementedException();
            }

            public void Clear()
            {
                throw new NotImplementedException();
            }

            public bool Contains(KeyValuePair<TKey, TValue> item)
            {
                throw new NotImplementedException();
            }

            public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
            {
                throw new NotImplementedException();
            }

            public int Count
            {
                get { return this._dictionary.Count; }
            }

            public bool IsReadOnly
            {
                get { throw new NotImplementedException(); }
            }

            public bool Remove(KeyValuePair<TKey, TValue> item)
            {
                throw new NotImplementedException();
            }

            public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
            {
                return this._dictionary.GetEnumerator();
            }

            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                return this._dictionary.GetEnumerator();
            }
        }

    }

    // ReSharper restore LoopCanBeConvertedToQuery
    // ReSharper restore RedundantExplicitArrayCreation
    // ReSharper restore SuggestUseVarKeywordEvident
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Contains extension methods for <see cref="ITypeCatalog"/> implementations.
    /// </summary>
    public static class TypeCatalogExtensions
    {
        /// <summary>
        /// Gets all <see cref="Type"/> instances that are assignable to <paramref name="type"/>, using <see cref="TypeResolveStrategies.All"/>.
        /// </summary>
        /// <param name="typeCatalog">The <see cref="ITypeCatalog"/> instance where the types should be retrieved from.</param>
        /// <param name="type">The <see cref="Type"/> that all returned types should be assingable to.</param>
        /// <returns>An <see cref="IReadOnlyCollection{T}"/> of <see cref="Type"/> instances.</returns>
        public static IReadOnlyCollection<Type> GetTypesAssignableTo(this ITypeCatalog typeCatalog, Type type)
        {
            return typeCatalog.GetTypesAssignableTo(type, TypeResolveStrategies.All);
        }

        /// <summary>
        /// Gets all <see cref="Type"/> instances that are assignable to <typeparamref name="TType"/>, using <see cref="TypeResolveStrategies.All"/>.
        /// </summary>
        /// <param name="typeCatalog">The <see cref="ITypeCatalog"/> instance where the types should be retrieved from.</param>
        /// <typeparam name="TType">The <see cref="Type"/> that all returned types should be assingable to.</typeparam>
        /// <returns>An <see cref="IReadOnlyCollection{T}"/> of <see cref="Type"/> instances.</returns>
        public static IReadOnlyCollection<Type> GetTypesAssignableTo<TType>(this ITypeCatalog typeCatalog)
        {
            return typeCatalog.GetTypesAssignableTo(typeof(TType), TypeResolveStrategies.All);
        }

        /// <summary>
        /// Gets all types that are assignable to the provided <typeparamref name="TType"/>.
        /// </summary>
        /// <param name="typeCatalog">The <see cref="ITypeCatalog"/> instance where the types should be retrieved from.</param>
        /// <param name="strategy">A <see cref="TypeResolveStrategy"/> that should be used then retrieving types.</param>
        /// <typeparam name="TType">The <see cref="Type"/> that returned types should be assignable to.</typeparam>
        /// <returns>An <see cref="IReadOnlyCollection{T}"/> of <see cref="Type"/> instances.</returns>
        public static IReadOnlyCollection<Type> GetTypesAssignableTo<TType>(this ITypeCatalog typeCatalog, TypeResolveStrategy strategy)
        {
            return typeCatalog.GetTypesAssignableTo(typeof(TType), strategy);
        }
    }
}
namespace Nancy.Json.Converters
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;

    public class TupleConverter : JavaScriptConverter
    {
        public override IEnumerable<Type> SupportedTypes
        {
            get
            {
                yield return typeof(Tuple<>);
                yield return typeof(Tuple<,>);
                yield return typeof(Tuple<,,>);
                yield return typeof(Tuple<,,,>);
                yield return typeof(Tuple<,,,,>);
                yield return typeof(Tuple<,,,,,>);
                yield return typeof(Tuple<,,,,,,>);
                yield return typeof(Tuple<,,,,,,,>);
            }
        }

        public override object Deserialize(IDictionary<string, object> dictionary, Type type, JavaScriptSerializer serializer)
        {
            var ctor = type.GetConstructors().First();
            object instance = ctor.Invoke(dictionary.Values.ToArray());
            return instance;
        }

        public override IDictionary<string, object> Serialize(object obj, JavaScriptSerializer serializer)
        {
            throw new NotImplementedException();
        }
    }
}
namespace Nancy.Json
{
    using Nancy.Configuration;

    /// <summary>
    /// Provides the default configuration for <see cref="JsonConfiguration"/>.
    /// </summary>
    public class DefaultJsonConfigurationProvider : NancyDefaultConfigurationProvider<JsonConfiguration>
    {
        /// <summary>
        /// Gets the default configuration instance to register in the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <returns>The configuration instance</returns>
        /// <remarks>Will return <see cref="JsonConfiguration.Default"/></remarks>
        public override JsonConfiguration GetDefaultConfiguration()
        {
            return JsonConfiguration.Default;
        }
    }
}
namespace Nancy.Json
{
    using System;
    using System.Collections.Generic;

    public abstract class JavaScriptPrimitiveConverter
    {
        public abstract IEnumerable<Type> SupportedTypes { get; }

        public virtual object Deserialize(object primitiveValue, Type type)
        {
            return Deserialize(primitiveValue, type, null);
        }

        public abstract object Deserialize(object primitiveValue, Type type, JavaScriptSerializer serializer);

        public virtual object Serialize(object obj)
        {
            return Serialize(obj, null);
        }

        public abstract object Serialize(object obj, JavaScriptSerializer serializer);
    }
}
namespace Nancy.Json
{
    using System.Collections.Generic;
    using System.Text;
    using Nancy.Configuration;
    using Nancy.Diagnostics;

    /// <summary>
    /// Contains <see cref="DiagnosticsConfiguration"/> configuration extensions for <see cref="INancyEnvironment"/>.
    /// </summary>
    public static class JsonConfigurationExtensions
    {

        /// <summary>
        /// Configures JSON serialization.
        /// </summary>
        /// <param name="environment"><see cref="INancyEnvironment"/> that should be configured.</param>
        /// <param name="maxJsonLength">Max length of JSON output.</param>
        /// <param name="defaultEncoding">The <see cref="Encoding"/> that should be as a default.</param>
        /// <param name="converters">List of <see cref="JavaScriptConverter"/> that should be used.</param>
        /// <param name="primitiveConverters">List of <see cref="JavaScriptPrimitiveConverter"/> that should be used.</param>
        /// <param name="retainCasing"><see langword="true" /> if C# casing should be retained, otherwise <see langword="false" /> to use camel-casing.</param>
        public static void Json(this INancyEnvironment environment, int? maxJsonLength = null, Encoding defaultEncoding = null, IList<JavaScriptConverter> converters = null, IList<JavaScriptPrimitiveConverter> primitiveConverters = null, bool? retainCasing = null)
        {
            environment.AddValue(new JsonConfiguration(
                defaultEncoding ?? JsonConfiguration.Default.DefaultEncoding,
                converters ?? JsonConfiguration.Default.Converters,
                primitiveConverters ?? JsonConfiguration.Default.PrimitiveConverters,
                retainCasing ?? JsonConfiguration.Default.RetainCasing));
        }
    }
}
namespace Nancy.Localization
{
    using System;
    using System.Dynamic;

    /// <summary>
    /// Returns text from an implemented ITextResource
    /// </summary>
    public class TextResourceFinder : DynamicObject
    {
        private readonly ITextResource textResource;
        private readonly NancyContext context;

        /// <summary>
        /// Initializes a new instance of the <see cref="TextResourceFinder"/> class.
        /// </summary>
        /// <param name="textResource">The <see cref="ITextResource"/> that should be used by the TextResourceFinder</param>
        /// <param name="context">The <see cref="NancyContext"/> that should be used by the TextResourceFinder</param>
        public TextResourceFinder(ITextResource textResource, NancyContext context)
        {
            this.textResource = textResource;
            this.context = context;
        }

        /// <summary>
        /// Gets the <see cref="ITextResource"/> that is being used to locate texts.
        /// </summary>
        /// <value>An <see cref="ITextResource"/> instance.</value>
        public ITextResource Resource
        {
            get { return this.textResource; }
        }

        /// <summary>
        /// Finds text resource
        /// </summary>
        /// <param name="binder">GetMemberBinder with dynamic text key</param>
        /// <param name="result">Text item</param>
        /// <returns>Returns a value or a non existing value from the <see cref="ITextResource"/> implementation</returns>
        public override bool TryGetMember(GetMemberBinder binder, out object result)
        {
            result =
                new DynamicMemberChainer(binder.Name, this.context, this.textResource);

            return true;
        }

        /// <summary>
        /// Gets a translation based on the provided key.
        /// </summary>
        /// <param name="key">The key to look up the translation for.</param>
        public string this[string key]
        {
            get
            {
                return this.textResource[key, this.context];
            }
        }

        public class DynamicMemberChainer : DynamicObject
        {
            private string memberName;
            private readonly NancyContext context;
            private readonly ITextResource textResource;

            public DynamicMemberChainer(string memberName, NancyContext context, ITextResource resource)
            {
                this.memberName = memberName;
                this.context = context;
                this.textResource = resource;
            }

            public override bool TryGetMember(GetMemberBinder binder, out object result)
            {
                this.memberName =
                    string.Concat(this.memberName, ".", binder.Name);

                result = this;

                return true;
            }

            public override bool TryConvert(ConvertBinder binder, out object result)
            {
                if (binder.ReturnType == typeof(string))
                {
                    result = this.textResource[this.memberName, this.context];
                    return true;
                }

                throw new InvalidOperationException("Cannot cast dynamic member access to anything else than a string.");
            }

            public override string ToString()
            {
                return this.textResource[this.memberName, this.context];
            }
        }
    }
}
namespace Nancy.Helpers
{
    using System;
    using System.Threading.Tasks;

    public static class TaskHelpers
    {
        public static readonly Task CompletedTask = Task.FromResult<object>(null);

        public static Task<T> GetFaultedTask<T>(Exception exception)
        {
            var tcs = new TaskCompletionSource<T>();
            tcs.SetException(exception);
            return tcs.Task;
        }
    }
}
namespace Nancy.ModelBinding
{
    /// <summary>
    /// Configurations that controls the behavior of the binder at runtime.
    /// </summary>
    public class BindingConfig
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="BindingConfig"/> class.
        /// </summary>
        public BindingConfig()
        {
            this.Overwrite = true;
        }

        /// <summary>
        /// Binding configuration that permits that the binder overwrites non-default values.
        /// </summary>
        public static readonly BindingConfig NoOverwrite = new BindingConfig { Overwrite = false };

        /// <summary>
        /// Default binding configuration.
        /// </summary>
        public static readonly BindingConfig Default = new BindingConfig();

        /// <summary>
        /// Gets or sets whether the binder should be happy once it has bound to the request body. In this case,
        /// request and context parameters will not be bound to. If there is no body and this option is enabled,
        /// no binding will take place at all.
        /// </summary>
        /// <value><see langword="true" /> if the binder will stop once the body has been bound, otherwise <see langword="false" />.</value>
        public bool BodyOnly { get; set; }

        /// <summary>
        /// Gets or sets whether binding error should be ignored and the binder should continue with the next property.
        /// </summary>
        /// <remarks>Setting this property to <see langword="true" /> means that no <see cref="ModelBindingException"/> will be thrown if an error occurs.</remarks>
        /// <value><see langword="true" />If the binder should ignore errors, otherwise <see langword="false" />.</value>
        public bool IgnoreErrors { get; set; }

        /// <summary>
        /// Gets or sets whether the binder is allowed to overwrite properties that does not have a default value.
        /// </summary>
        /// <value><see langword="true" /> if the binder is allowed to overwrite non-default values, otherwise <see langword="false" />.</value>
        public bool Overwrite { get; set; }
    }
}
namespace Nancy.ModelBinding
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;

    /// <summary>
    /// Represents a bindable member of a type, which can be a property or a field.
    /// </summary>
    public class BindingMemberInfo
    {
        PropertyInfo propertyInfo;
        FieldInfo fieldInfo;

        /// <summary>
        /// Gets a reference to the MemberInfo that this BindingMemberInfo represents. This can be a property or a field.
        /// </summary>
        public MemberInfo MemberInfo
        {
            get { return this.propertyInfo ?? (MemberInfo)this.fieldInfo; }
        }

        /// <summary>
        /// Gets the name of the property or field represented by this BindingMemberInfo.
        /// </summary>
        public string Name
        {
            get { return this.MemberInfo.Name; }
        }

        /// <summary>
        /// Gets the data type of the property or field represented by this BindingMemberInfo.
        /// </summary>
        public Type PropertyType
        {
            get
            {
                if (this.propertyInfo != null)
                {
                    return this.propertyInfo.PropertyType;
                }
                else
                {
                    return this.fieldInfo.FieldType;
                }
            }
        }

        /// <summary>
        /// Constructs a BindingMemberInfo instance for a property.
        /// </summary>
        /// <param name="propertyInfo">The bindable property to represent.</param>
        public BindingMemberInfo(PropertyInfo propertyInfo)
        {
            if (propertyInfo == null)
            {
                throw new ArgumentNullException("propertyInfo");
            }

            this.propertyInfo = propertyInfo;
        }

        /// <summary>
        /// Constructs a BindingMemberInfo instance for a field.
        /// </summary>
        /// <param name="fieldInfo">The bindable field to represent.</param>
        public BindingMemberInfo(FieldInfo fieldInfo)
        {
            if (fieldInfo == null)
            {
                throw new ArgumentNullException("fieldInfo");
            }

            this.fieldInfo = fieldInfo;
        }

        /// <summary>
        /// Gets the value from a specified object associated with the property or field represented by this BindingMemberInfo.
        /// </summary>
        /// <param name="sourceObject">The object whose property or field should be retrieved.</param>
        /// <returns>The value for this BindingMemberInfo's property or field in the specified object.</returns>
        public object GetValue(object sourceObject)
        {
            if (this.propertyInfo != null)
            {
                return this.propertyInfo.GetValue(sourceObject, null);
            }
            else
            {
                return this.fieldInfo.GetValue(sourceObject);
            }
        }

        /// <summary>
        /// Sets the value from a specified object associated with the property or field represented by this BindingMemberInfo.
        /// </summary>
        /// <param name="destinationObject">The object whose property or field should be assigned.</param>
        /// <param name="newValue">The value to assign in the specified object to this BindingMemberInfo's property or field.</param>
        public void SetValue(object destinationObject, object newValue)
        {
            if (this.propertyInfo != null)
            {
                this.propertyInfo.SetValue(destinationObject, newValue, null);
            }
            else
            {
                this.fieldInfo.SetValue(destinationObject, newValue);
            }
        }

        /// <inherit-doc/>
        public override bool Equals(object obj)
        {
            if (obj == null)
            {
                return false;
            }

            var other = obj as BindingMemberInfo;

            if (other == null)
            {
                return false;
            }

            return this.MemberInfo.Equals(other.MemberInfo);
        }

        /// <summary>
        /// Compares two BindingMemberInfo's with eachother on their respective values rather then their reference
        /// </summary>
        /// <param name="obj">the other BindingMemberInfo</param>
        /// <returns>true when they are equal and false otherwise</returns>
        public bool Equals(BindingMemberInfo obj)
        {
            if (obj == null)
            {
                return false;
            }

            return this.MemberInfo.Equals(obj.MemberInfo);
        }

        /// <inherit-doc/>
        public override int GetHashCode()
        {
            return this.MemberInfo.GetHashCode();
        }

        /// <summary>
        /// Returns an enumerable sequence of bindable properties for the specified type.
        /// </summary>
        /// <typeparam name="T">The type to enumerate.</typeparam>
        /// <returns>Bindable properties.</returns>
        public static IEnumerable<BindingMemberInfo> Collect<T>()
        {
            return Collect(typeof(T));
        }

        /// <summary>
        /// Returns an enumerable sequence of bindable properties for the specified type.
        /// </summary>
        /// <param name="type">The type to enumerate.</param>
        /// <returns>Bindable properties.</returns>
        public static IEnumerable<BindingMemberInfo> Collect(Type type)
        {
            var fromProperties = type
                .GetProperties(BindingFlags.Public | BindingFlags.Instance).Where(p => p.CanRead && p.CanWrite)
                .Where(property => !property.GetIndexParameters().Any())
                .Select(property => new BindingMemberInfo(property));

            var fromFields = type.GetFields(BindingFlags.Public | BindingFlags.Instance).Where(f => !f.IsInitOnly)
                .Select(field => new BindingMemberInfo(field));

            return fromProperties.Concat(fromFields);
        }
    }
}
namespace Nancy.ModelBinding.DefaultConverters
{
    using System;

    /// <summary>
    /// Converter for datetime types
    /// </summary>
    public class DateTimeConverter : ITypeConverter
    {
        /// <summary>
        /// Whether the converter can convert to the destination type
        /// </summary>
        /// <param name="destinationType">Destination type</param>
        /// <param name="context">The current binding context</param>
        /// <returns>True if conversion supported, false otherwise</returns>
        public bool CanConvertTo(Type destinationType, BindingContext context)
        {
            return destinationType == typeof(DateTime);
        }

        /// <summary>
        /// Convert the string representation to the destination type
        /// </summary>
        /// <param name="input">Input string</param>
        /// <param name="destinationType">Destination type</param>
        /// <param name="context">Current context</param>
        /// <returns>Converted object of the destination type</returns>
        public object Convert(string input, Type destinationType, BindingContext context)
        {
            if (string.IsNullOrEmpty(input))
            {
                return null;
            }

            return System.Convert.ChangeType(input, destinationType, context.Context.Culture);
        }
    }
}
namespace Nancy.ModelBinding.DefaultConverters
{
    using System;

    using Nancy.Extensions;

    /// <summary>
    /// Converter for numeric types
    /// </summary>
    public class NumericConverter : ITypeConverter
    {
        /// <summary>
        /// Whether the converter can convert to the destination type
        /// </summary>
        /// <param name="destinationType">Destination type</param>
        /// <param name="context">The current binding context</param>
        /// <returns>True if conversion supported, false otherwise</returns>
        public bool CanConvertTo(Type destinationType, BindingContext context)
        {
            return destinationType.IsNumeric();
        }

        /// <summary>
        /// Convert the string representation to the destination type
        /// </summary>
        /// <param name="input">Input string</param>
        /// <param name="destinationType">Destination type</param>
        /// <param name="context">Current context</param>
        /// <returns>Converted object of the destination type</returns>
        public object Convert(string input, Type destinationType, BindingContext context)
        {
            if (string.IsNullOrEmpty(input))
            {
                return null;
            }


            return System.Convert.ChangeType(input, destinationType, context.Context.Culture);
        }
    }
}
namespace Nancy.ModelBinding
{
    using System.Linq.Expressions;
    using System.Reflection;

    /// <summary>
    /// Contains extension methods for the <see cref="Expression"/> type.
    /// </summary>
    public static class ExpressionExtensions
    {
        /// <summary>
        /// Retrieves the member that an expression is defined for.
        /// </summary>
        /// <param name="expression">The expression to retrieve the member from.</param>
        /// <returns>A <see cref="MemberInfo"/> instance if the member could be found; otherwise <see langword="null"/>.</returns>
        public static MemberInfo GetTargetMemberInfo(this Expression expression)
        {
            switch (expression.NodeType)
            {
                case ExpressionType.Convert:
                    return GetTargetMemberInfo(((UnaryExpression)expression).Operand);
                case ExpressionType.Lambda:
                    return GetTargetMemberInfo(((LambdaExpression)expression).Body);
                case ExpressionType.Call:
                    return ((MethodCallExpression)expression).Method;
                case ExpressionType.MemberAccess:
                    return ((MemberExpression)expression).Member;
                default:
                    return null;
            }
        }
    }
}
namespace Nancy.ModelBinding
{
    using System;

    public class PropertyBindingException : Exception
    {
        private const string ExceptionMessage = "Unable to bind property: {0}; Attempted value: {1}";

        /// <summary>
        /// Gets the property name for which the bind failed
        /// </summary>
        public string PropertyName { get; private set; }

        /// <summary>
        /// Gets the value which was attempted to be assigned to the property
        /// </summary>
        public string AttemptedValue { get; private set; }

        /// <summary>
        /// Creates new instance
        /// </summary>
        /// <param name="propertyName">the name of the property which failed to bind</param>
        /// <param name="attemptedValue">the value attempted to set</param>
        /// <param name="innerException">the underlying exception</param>
        public PropertyBindingException(string propertyName, string attemptedValue, Exception innerException = null)
            : base(String.Format(ExceptionMessage, propertyName, attemptedValue), innerException)
        {
            this.PropertyName = propertyName;
            this.AttemptedValue = attemptedValue;
        }
    }
}
namespace Nancy
{
    using System.Collections.Generic;
    using System.ComponentModel;

    using Nancy.ModelBinding;
    using Nancy.Responses.Negotiation;
    using Nancy.Routing;
    using Nancy.Validation;
    using Nancy.ViewEngines;

    /// <summary>
    /// Nancy module base interface
    /// Defines all the properties / behaviour needed by Nancy internally
    /// </summary>
    public interface INancyModule
    {
        /// <summary><para>
        /// The post-request hook
        /// </para><para>
        /// The post-request hook is called after the response is created by the route execution.
        /// It can be used to rewrite the response or add/remove items from the context.
        /// </para></summary>
        AfterPipeline After { get; set; }

        /// <summary><para>
        /// The pre-request hook
        /// </para><para>
        /// The PreRequest hook is called prior to executing a route. If any item in the
        /// pre-request pipeline returns a response then the route is not executed and the
        /// response is returned.
        /// </para></summary>
        BeforePipeline Before { get; set; }

        /// <summary><para>
        /// The error hook
        /// </para><para>
        /// The error hook is called if an exception is thrown at any time during executing
        /// the PreRequest hook, a route and the PostRequest hook. It can be used to set
        /// the response and/or finish any ongoing tasks (close database session, etc).
        /// </para></summary>
        ErrorPipeline OnError { get; set; }

        /// <summary>
        /// Gets or sets the current Nancy context
        /// </summary><value>A <see cref="T:Nancy.NancyContext" /> instance.</value>
        NancyContext Context { get; set; }

        /// <summary>
        /// An extension point for adding support for formatting response contents.
        /// </summary><value>This property will always return <see langword="null" /> because it acts as an extension point.</value><remarks>Extension methods to this property should always return <see cref="P:Nancy.NancyModuleBase.Response" /> or one of the types that can implicitly be types into a <see cref="P:Nancy.NancyModuleBase.Response" />.</remarks>
        IResponseFormatter Response { get; set; }

        /// <summary>
        /// Gets or sets the model binder locator
        /// </summary>
        IModelBinderLocator ModelBinderLocator { get; set; }

        /// <summary>
        /// Gets or sets the model validation result
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        ModelValidationResult ModelValidationResult { get; set; }

        /// <summary>
        /// Gets or sets the validator locator.
        /// </summary>
        IModelValidatorLocator ValidatorLocator { get; set; }

        /// <summary>
        /// Gets or sets an <see cref="Request" /> instance that represents the current request.
        /// </summary><value>An <see cref="Request" /> instance.</value>
        Request Request { get; set; }

        /// <summary>
        /// The extension point for accessing the view engines in Nancy.
        /// </summary><value>An <see cref="T:Nancy.ViewEngines.IViewFactory" /> instance.</value><remarks>This is automatically set by Nancy at runtime.</remarks>
        IViewFactory ViewFactory { get; set; }

        /// <summary>
        /// Get the root path of the routes in the current module.
        /// </summary><value>A <see cref="T:System.String" /> containing the root path of the module or <see langword="null" /> if no root path should be used.</value><remarks>All routes will be relative to this root path.</remarks>
        string ModulePath { get; }

        /// <summary>
        /// Gets all declared routes by the module.
        /// </summary><value>A <see cref="T:System.Collections.Generic.IEnumerable`1" /> instance, containing all <see cref="T:Nancy.Routing.Route" /> instances declared by the module.</value>
        IEnumerable<Route> Routes { get; }

        /// <summary>
        /// Gets or sets the dynamic object used to locate text resources.
        /// </summary>
        dynamic Text { get; }

        /// <summary>
        /// Renders a view from inside a route handler.
        /// </summary>
        /// <value>A <see cref="ViewRenderer"/> instance that is used to determine which view that should be rendered.</value>
        ViewRenderer View { get; }

        /// <summary>
        /// Used to negotiate the content returned based on Accepts header.
        /// </summary>
        /// <value>A <see cref="Negotiator"/> instance that is used to negotiate the content returned.</value>
        Negotiator Negotiate { get; }
    }
}
namespace Nancy
{
    using System.Threading;
    using System.Threading.Tasks;

    public static class NancyEngineExtensions
    {
        /// <summary>
        /// Handles an incoming <see cref="Request"/>.
        /// </summary>
        /// <param name="nancyEngine">The <see cref="INancyEngine"/> instance.</param>
        /// <param name="request">An <see cref="Request"/> instance, containing the information about the current request.</param>
        /// <returns>A <see cref="NancyContext"/> instance containing the request/response context.</returns>
        public static Task<NancyContext> HandleRequest(this INancyEngine nancyEngine, Request request)
        {
            return nancyEngine.HandleRequest(request, context => context, CancellationToken.None);
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Threading;
    using System.Threading.Tasks;
    using Nancy.Configuration;
    using Nancy.ModelBinding;
    using Nancy.Responses.Negotiation;
    using Nancy.Routing;
    using Nancy.Session;
    using Nancy.Validation;
    using Nancy.ViewEngines;

    /// <summary>
    /// Basic class containing the functionality for defining routes and actions in Nancy.
    /// </summary>
    [Obsolete("LegacyNancyModule is a compatibility shim that will be removed in a future release. Please migrate to the 'async only' NancyModule.")]
    public abstract class LegacyNancyModule : INancyModule, IHideObjectMembers
    {
        private readonly List<Route> routes;

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyModule"/> class.
        /// </summary>
        protected LegacyNancyModule()
            : this(String.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyModule"/> class.
        /// </summary>
        /// <param name="modulePath">A <see cref="string"/> containing the root relative path that all paths in the module will be a subset of.</param>
        protected LegacyNancyModule(string modulePath)
        {
            this.After = new AfterPipeline();
            this.Before = new BeforePipeline();
            this.OnError = new ErrorPipeline();

            this.ModulePath = modulePath;
            this.routes = new List<Route>();
        }

        /// <summary>
        /// Non-model specific data for rendering in the response
        /// </summary>
        public dynamic ViewBag
        {
            get
            {
                return this.Context == null ? null : this.Context.ViewBag;
            }
        }

        public dynamic Text
        {
            get { return this.Context.Text; }
        }

        /// <summary>
        /// Gets <see cref="LegacyRouteBuilder"/> for declaring actions for DELETE requests.
        /// </summary>
        /// <value>A <see cref="LegacyRouteBuilder"/> instance.</value>
        public LegacyRouteBuilder Delete
        {
            get { return new LegacyRouteBuilder("DELETE", this); }
        }

        /// <summary>
        /// Gets <see cref="LegacyRouteBuilder"/> for declaring actions for GET requests.
        /// </summary>
        /// <value>A <see cref="LegacyRouteBuilder"/> instance.</value>
        public LegacyRouteBuilder Get
        {
            get { return new LegacyRouteBuilder("GET", this); }
        }

        /// <summary>
        /// Gets <see cref="LegacyRouteBuilder"/> for declaring actions for HEAD requests.
        /// </summary>
        /// <value>A <see cref="LegacyRouteBuilder"/> instance.</value>
        public LegacyRouteBuilder Head
        {
            get { return new LegacyRouteBuilder("HEAD", this); }
        }

        /// <summary>
        /// Gets <see cref="LegacyRouteBuilder"/> for declaring actions for OPTIONS requests.
        /// </summary>
        /// <value>A <see cref="LegacyRouteBuilder"/> instance.</value>
        public LegacyRouteBuilder Options
        {
            get { return new LegacyRouteBuilder("OPTIONS", this); }
        }

        /// <summary>
        /// Gets <see cref="LegacyRouteBuilder"/> for declaring actions for PATCH requests.
        /// </summary>
        /// <value>A <see cref="LegacyRouteBuilder"/> instance.</value>
        public LegacyRouteBuilder Patch
        {
            get { return new LegacyRouteBuilder("PATCH", this); }
        }

        /// <summary>
        /// Gets <see cref="LegacyRouteBuilder"/> for declaring actions for POST requests.
        /// </summary>
        /// <value>A <see cref="LegacyRouteBuilder"/> instance.</value>
        public LegacyRouteBuilder Post
        {
            get { return new LegacyRouteBuilder("POST", this); }
        }

        /// <summary>
        /// Gets <see cref="LegacyRouteBuilder"/> for declaring actions for PUT requests.
        /// </summary>
        /// <value>A <see cref="LegacyRouteBuilder"/> instance.</value>
        public LegacyRouteBuilder Put
        {
            get { return new LegacyRouteBuilder("PUT", this); }
        }

        /// <summary>
        /// Get the root path of the routes in the current module.
        /// </summary>
        /// <value>
        /// A <see cref="T:System.String" /> containing the root path of the module or <see langword="null" />
        /// if no root path should be used.</value><remarks>All routes will be relative to this root path.
        /// </remarks>
        public string ModulePath { get; protected set; }

        /// <summary>
        /// Gets all declared routes by the module.
        /// </summary>
        /// <value>A <see cref="IEnumerable{T}"/> instance, containing all <see cref="Route"/> instances declared by the module.</value>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual IEnumerable<Route> Routes
        {
            get { return this.routes.AsReadOnly(); }
        }

        /// <summary>
        /// Gets the current session.
        /// </summary>
        public ISession Session
        {
            get { return this.Request.Session; }
        }

        /// <summary>
        /// Renders a view from inside a route handler.
        /// </summary>
        /// <value>A <see cref="ViewRenderer"/> instance that is used to determine which view that should be rendered.</value>
        public ViewRenderer View
        {
            get { return new ViewRenderer(this); }
        }

        /// <summary>
        /// Used to negotiate the content returned based on Accepts header.
        /// </summary>
        /// <value>A <see cref="Negotiator"/> instance that is used to negotiate the content returned.</value>
        public Negotiator Negotiate
        {
            get { return new Negotiator(this.Context); }
        }

        /// <summary>
        /// Gets or sets the validator locator.
        /// </summary>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public IModelValidatorLocator ValidatorLocator { get; set; }

        /// <summary>
        /// Gets or sets an <see cref="Request"/> instance that represents the current request.
        /// </summary>
        /// <value>An <see cref="Request"/> instance.</value>
        public virtual Request Request
        {
            get { return this.Context.Request; }
            set { this.Context.Request = value; }
        }

        /// <summary>
        /// The extension point for accessing the view engines in Nancy.
        /// </summary><value>An <see cref="IViewFactory" /> instance.</value>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public IViewFactory ViewFactory { get; set; }

        /// <summary><para>
        /// The post-request hook
        /// </para><para>
        /// The post-request hook is called after the response is created by the route execution.
        /// It can be used to rewrite the response or add/remove items from the context.
        /// </para>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        /// </summary>
        public AfterPipeline After { get; set; }

        /// <summary>
        /// <para>
        /// The pre-request hook
        /// </para>
        /// <para>
        /// The PreRequest hook is called prior to executing a route. If any item in the
        /// pre-request pipeline returns a response then the route is not executed and the
        /// response is returned.
        /// </para>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        /// </summary>
        public BeforePipeline Before { get; set; }

        /// <summary>
        /// <para>
        /// The error hook
        /// </para>
        /// <para>
        /// The error hook is called if an exception is thrown at any time during executing
        /// the PreRequest hook, a route and the PostRequest hook. It can be used to set
        /// the response and/or finish any ongoing tasks (close database session, etc).
        /// </para>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        /// </summary>
        public ErrorPipeline OnError { get; set; }

        /// <summary>
        /// Gets or sets the current Nancy context
        /// </summary>
        /// <value>A <see cref="NancyContext" /> instance.</value>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        public NancyContext Context { get; set; }

        /// <summary>
        /// An extension point for adding support for formatting response contents.
        /// </summary><value>This property will always return <see langword="null" /> because it acts as an extension point.</value><remarks>Extension methods to this property should always return <see cref="P:Nancy.NancyModuleBase.Response" /> or one of the types that can implicitly be types into a <see cref="P:Nancy.NancyModuleBase.Response" />.</remarks>
        public IResponseFormatter Response { get; set; }

        /// <summary>
        /// Gets or sets the model binder locator
        /// </summary>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public IModelBinderLocator ModelBinderLocator { get; set; }

        /// <summary>
        /// Gets or sets the model validation result
        /// </summary>
        /// <remarks>This is automatically set by Nancy at runtime when you run validation.</remarks>
        public virtual ModelValidationResult ModelValidationResult
        {
            get { return this.Context == null ? null : this.Context.ModelValidationResult; }
            set
            {
                if (this.Context != null)
                {
                    this.Context.ModelValidationResult = value;
                }
            }
        }

        /// <summary>
        /// Helper class for configuring a route handler in a module.
        /// </summary>
        public class LegacyRouteBuilder : IHideObjectMembers
        {
            private readonly string method;
            private readonly LegacyNancyModule parentModule;

            /// <summary>
            /// Initializes a new instance of the <see cref="LegacyRouteBuilder"/> class.
            /// </summary>
            /// <param name="method">The HTTP request method that the route should be available for.</param>
            /// <param name="parentModule">The <see cref="INancyModule"/> that the route is being configured for.</param>
            public LegacyRouteBuilder(string method, LegacyNancyModule parentModule)
            {
                this.method = method;
                this.parentModule = parentModule;
            }

            /// <summary>
            /// Defines a Nancy route for the specified <paramref name="path"/>.
            /// </summary>
            /// <value>A delegate that is used to invoke the route.</value>
            public Func<dynamic, dynamic> this[string path]
            {
                set { this.AddRoute(string.Empty, path, null, value); }
            }

            /// <summary>
            /// Defines a Nancy route for the specified <paramref name="path"/> and <paramref name="condition"/>.
            /// </summary>
            /// <value>A delegate that is used to invoke the route.</value>
            public Func<dynamic, dynamic> this[string path, Func<NancyContext, bool> condition]
            {
                set { this.AddRoute(string.Empty, path, condition, value); }
            }

            /// <summary>
            /// Defines an async route for the specified <paramref name="path"/>
            /// </summary>
            public Func<dynamic, CancellationToken, Task<dynamic>> this[string path, bool runAsync]
            {
                set { this.AddRoute(string.Empty, path, null, value); }
            }

            /// <summary>
            /// Defines an async route for the specified <paramref name="path"/> and <paramref name="condition"/>.
            /// </summary>
            public Func<dynamic, CancellationToken, Task<dynamic>> this[string path, Func<NancyContext, bool> condition, bool runAsync]
            {
                set { this.AddRoute(string.Empty, path, condition, value); }
            }

            /// <summary>
            /// Defines a Nancy route for the specified <paramref name="path"/> and <paramref name="name"/>
            /// </summary>
            /// <value>A delegate that is used to invoke the route.</value>
            public Func<dynamic, dynamic> this[string name, string path]
            {
                set { this.AddRoute(name, path, null, value); }
            }

            /// <summary>
            /// Defines a Nancy route for the specified <paramref name="path"/>, <paramref name="condition"/> and <paramref name="name"/>
            /// </summary>
            /// <value>A delegate that is used to invoke the route.</value>
            public Func<dynamic, dynamic> this[string name, string path, Func<NancyContext, bool> condition]
            {
                set { this.AddRoute(name, path, condition, value); }
            }

            /// <summary>
            /// Defines an async route for the specified <paramref name="path"/> and <paramref name="name"/>
            /// </summary>
            public Func<dynamic, CancellationToken, Task<dynamic>> this[string name, string path, bool runAsync]
            {
                set { this.AddRoute(name, path, null, value); }
            }

            /// <summary>
            /// Defines an async route for the specified <paramref name="path"/>, <paramref name="condition"/> and <paramref name="name"/>
            /// </summary>
            public Func<dynamic, CancellationToken, Task<dynamic>> this[string name, string path, Func<NancyContext, bool> condition, bool runAsync]
            {
                set { this.AddRoute(name, path, condition, value); }
            }

            protected void AddRoute(string name, string path, Func<NancyContext, bool> condition, Func<dynamic, dynamic> value)
            {
                var fullPath = GetFullPath(path);

                this.parentModule.routes.Add(Route.FromSync(name, this.method, fullPath, condition, value));
            }

            protected void AddRoute(string name, string path, Func<NancyContext, bool> condition, Func<dynamic, CancellationToken, Task<dynamic>> value)
            {
                var fullPath = GetFullPath(path);

                this.parentModule.routes.Add(new Route(name, this.method, fullPath, condition, value));
            }

            private string GetFullPath(string path)
            {
                var relativePath = (path ?? string.Empty).Trim('/');
                var parentPath = (this.parentModule.ModulePath ?? string.Empty).Trim('/');

                if (string.IsNullOrEmpty(parentPath))
                {
                    return string.Concat("/", relativePath);
                }

                if (string.IsNullOrEmpty(relativePath))
                {
                    return string.Concat("/", parentPath);
                }

                return string.Concat("/", parentPath, "/", relativePath);
            }
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    using Nancy.Cookies;
    using Nancy.Responses.Negotiation;

    public static class NegotiatorExtensions
    {
        /// <summary>
        /// Add a cookie to the response.
        /// </summary>
        /// <param name="negotiator">The <see cref="Negotiator"/> instance.</param>
        /// <param name="cookie">The <see cref="INancyCookie"/> instance that should be added.</param>
        /// <returns>The modified <see cref="Negotiator"/> instance.</returns>
        public static Negotiator WithCookie(this Negotiator negotiator, INancyCookie cookie)
        {
            negotiator.NegotiationContext.Cookies.Add(cookie);
            return negotiator;
        }

        /// <summary>
        /// Add a collection of cookies to the response.
        /// </summary>
        /// <param name="negotiator">The <see cref="Negotiator"/> instance.</param>
        /// <param name="cookies">The <see cref="INancyCookie"/> instances that should be added.</param>
        /// <returns>The modified <see cref="Negotiator"/> instance.</returns>
        public static Negotiator WithCookies(this Negotiator negotiator, IEnumerable<INancyCookie> cookies)
        {
            foreach (var cookie in cookies)
            {
                negotiator.WithCookie(cookie);
            }

            return negotiator;
        }

        /// <summary>
        /// Add a header to the response
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="header">Header name</param>
        /// <param name="value">Header value</param>
        /// <returns>Modified negotiator</returns>
        public static Negotiator WithHeader(this Negotiator negotiator, string header, string value)
        {
            return negotiator.WithHeaders(new { Header = header, Value = value });
        }

        /// <summary>
        /// Add a content type to the response
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="contentType">Content type value</param>
        /// <returns>Modified negotiator</returns>
        public static Negotiator WithContentType(this Negotiator negotiator, string contentType)
        {
            return negotiator.WithHeaders(new { Header = "Content-Type", Value = contentType });
        }
        /// <summary>
        /// Adds headers to the response using anonymous types
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="headers">
        /// Array of headers - each header should be an anonymous type with two string properties
        /// 'Header' and 'Value' to represent the header name and its value.
        /// </param>
        /// <returns>Modified negotiator</returns>
        public static Negotiator WithHeaders(this Negotiator negotiator, params object[] headers)
        {
            return negotiator.WithHeaders(headers.Select(GetTuple).ToArray());
        }

        /// <summary>
        /// Adds headers to the response using anonymous types
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="headers">
        /// Array of headers - each header should be a Tuple with two string elements 
        /// for header name and header value
        /// </param>
        /// <returns>Modified negotiator</returns>
        public static Negotiator WithHeaders(this Negotiator negotiator, params Tuple<string, string>[] headers)
        {
            foreach (var keyValuePair in headers)
            {
                negotiator.NegotiationContext.Headers[keyValuePair.Item1] = keyValuePair.Item2;
            }

            return negotiator;
        }

        /// <summary>
        /// Allows the response to be negotiated with any processors available for any content type
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <returns>Modified negotiator</returns>
        public static Negotiator WithFullNegotiation(this Negotiator negotiator)
        {
            negotiator.NegotiationContext.PermissableMediaRanges.Clear();
            negotiator.NegotiationContext.PermissableMediaRanges.Add("*/*");

            return negotiator;
        }

        /// <summary>
        /// Allows the response to be negotiated with a specific media range
        /// This will remove the wildcard range if it is already specified
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="mediaRange">Media range to add</param>
        /// <returns>Modified negotiator</returns>
        public static Negotiator WithAllowedMediaRange(this Negotiator negotiator, MediaRange mediaRange)
        {
            var wildcards =
                negotiator.NegotiationContext.PermissableMediaRanges.Where(
                    mr => mr.Type.IsWildcard && mr.Subtype.IsWildcard).ToArray();

            foreach (var wildcard in wildcards)
            {
                negotiator.NegotiationContext.PermissableMediaRanges.Remove(wildcard);
            }

            negotiator.NegotiationContext.PermissableMediaRanges.Add(mediaRange);

            return negotiator;
        }

        /// <summary>
        /// Uses the specified model as the default model for negotiation
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="model">Model object</param>
        /// <returns>Modified negotiator</returns>
        public static Negotiator WithModel(this Negotiator negotiator, dynamic model)
        {
            negotiator.NegotiationContext.DefaultModel = model;

            return negotiator;
        }

        /// <summary>
        /// Uses the specified view for html output
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="viewName">View name</param>
        /// <returns>Modified negotiator</returns>
        public static Negotiator WithView(this Negotiator negotiator, string viewName)
        {
            negotiator.NegotiationContext.ViewName = viewName;

            return negotiator;
        }

        /// <summary>
        /// Sets the model to use for a particular media range.
        /// Will also add the MediaRange to the allowed list
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="range">Range to match against</param>
        /// <param name="model">Model object</param>
        /// <returns>Updated negotiator object</returns>
        public static Negotiator WithMediaRangeModel(this Negotiator negotiator, MediaRange range, object model)
        {
            return negotiator.WithMediaRangeModel(range, () => model);
        }

        /// <summary>
        /// Sets the model to use for a particular media range.
        /// Will also add the MediaRange to the allowed list
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="range">Range to match against</param>
        /// <param name="modelFactory">Model factory for returning the model object</param>
        /// <returns>Updated negotiator object</returns>
        public static Negotiator WithMediaRangeModel(this Negotiator negotiator, MediaRange range, Func<object> modelFactory)
        {
            negotiator.NegotiationContext.PermissableMediaRanges.Add(range);
            negotiator.NegotiationContext.MediaRangeModelMappings.Add(range, modelFactory);

            return negotiator;
        }

        /// <summary>
        /// Sets the <see cref="Response"/> to use for a particular media range.
        /// Will also add the MediaRange to the allowed list
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="range">Range to match against</param>
        /// <param name="response">A <see cref="Response"/> object</param>
        /// <returns>Updated negotiator object</returns>
        public static Negotiator WithMediaRangeResponse(this Negotiator negotiator, MediaRange range, Response response)
        {
            return negotiator.WithMediaRangeResponse(range, () => response);
        }

        /// <summary>
        /// Sets the <see cref="Response"/> to use for a particular media range.
        /// Will also add the MediaRange to the allowed list
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="range">Range to match against</param>
        /// <param name="responseFactory">Factory for returning the <see cref="Response"/> object</param>
        /// <returns>Updated negotiator object</returns>
        public static Negotiator WithMediaRangeResponse(this Negotiator negotiator, MediaRange range, Func<Response> responseFactory)
        {
            return negotiator.WithMediaRangeModel(range, responseFactory);
        }

        /// <summary>
        /// Sets the status code that should be assigned to the final response.
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="statusCode">The status code that should be used.</param>
        /// <returns>Updated negotiator object</returns>
        public static Negotiator WithStatusCode(this Negotiator negotiator, int statusCode)
        {
            negotiator.NegotiationContext.StatusCode = (HttpStatusCode)statusCode;
            return negotiator;
        }

        /// <summary>
        /// Sets the description of the status code that should be assigned to the final response.
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="reasonPhrase">The status code description that should be used.</param>
        /// <returns>Updated negotiator object</returns>
        public static Negotiator WithReasonPhrase(this Negotiator negotiator, string reasonPhrase)
        {
            negotiator.NegotiationContext.ReasonPhrase = reasonPhrase;
            return negotiator;
        }

        /// <summary>
        /// Sets the status code that should be assigned to the final response.
        /// </summary>
        /// <param name="negotiator">Negotiator object</param>
        /// <param name="statusCode">The status code that should be used.</param>
        /// <returns>Updated negotiator object</returns>
        public static Negotiator WithStatusCode(this Negotiator negotiator, HttpStatusCode statusCode)
        {
            negotiator.NegotiationContext.StatusCode = statusCode;
            return negotiator;
        }

        private static Tuple<string, string> GetTuple(object header)
        {
            var properties = header.GetType()
                                   .GetProperties()
                                   .Where(prop => prop.CanRead && prop.PropertyType == typeof(string))
                                   .ToArray();

            var headerProperty = properties
                                    .Where(p => string.Equals(p.Name, "Header", StringComparison.OrdinalIgnoreCase))
                                    .FirstOrDefault();

            var valueProperty = properties
                                    .Where(p => string.Equals(p.Name, "Value", StringComparison.OrdinalIgnoreCase))
                                    .FirstOrDefault();

            if (headerProperty == null || valueProperty == null)
            {
                throw new ArgumentException("Unable to extract 'Header' or 'Value' properties from anonymous type.");
            }

            return Tuple.Create(
                (string)headerProperty.GetValue(header, null),
                (string)valueProperty.GetValue(header, null));
        }
    }
}
namespace Nancy.Owin
{
    using System;

    using AppFunc = System.Func<System.Collections.Generic.IDictionary<string, object>,
        System.Threading.Tasks.Task>;

    using MidFunc = System.Func<System.Func<System.Collections.Generic.IDictionary<string, object>,
            System.Threading.Tasks.Task>, System.Func<System.Collections.Generic.IDictionary<string, object>,
            System.Threading.Tasks.Task>>;

    /// <summary>
    /// OWIN extensions for the delegate-based approach.
    /// </summary>
    public static class DelegateExtensions
    {
        /// <summary>
        /// Adds Nancy to the OWIN pipeline.
        /// </summary>
        /// <param name="builder">The application builder delegate.</param>
        /// <param name="action">A configuration builder action.</param>
        /// <returns>The application builder delegate.</returns>
        public static Action<MidFunc> UseNancy(this Action<MidFunc> builder, Action<NancyOptions> action)
        {
            var options = new NancyOptions();

            action(options);

            return builder.UseNancy(options);
        }

        /// <summary>
        /// Adds Nancy to the OWIN pipeline.
        /// </summary>
        /// <param name="builder">The application builder delegate.</param>
        /// <param name="options">The Nancy options.</param>
        /// <returns>The application builder delegate.</returns>
        public static Action<MidFunc> UseNancy(this Action<MidFunc> builder, NancyOptions options = null)
        {
            var nancyOptions = options ?? new NancyOptions();

            builder(NancyMiddleware.UseNancy(nancyOptions).Invoke);

            return builder;
        }
    }
}
namespace Nancy.Owin
{
    using System.Collections.Generic;

    /// <summary>
    /// OWIN extensions for the NancyContext.
    /// </summary>
    public static class NancyContextExtensions
    {
        /// <summary>
        /// Gets the OWIN environment dictionary.
        /// </summary>
        /// <param name="context">The Nancy context.</param>
        /// <returns>The OWIN environment dictionary.</returns>
        public static IDictionary<string, object> GetOwinEnvironment(this NancyContext context)
        {
            object environment;
            if (context.Items.TryGetValue(NancyMiddleware.RequestEnvironmentKey, out environment))
            {
                return environment as IDictionary<string, object>;
            }

            return null;
        }
    }
}
namespace Nancy.Owin
{
    using System;

    using Nancy.Bootstrapper;

    /// <summary>
    /// Options for hosting Nancy with OWIN.
    /// </summary>
    public class NancyOptions
    {
        private INancyBootstrapper bootstrapper;
        private Func<NancyContext, bool> performPassThrough;

        /// <summary>
        /// Gets or sets the bootstrapper. If none is set, NancyBootstrapperLocator.Bootstrapper is used.
        /// </summary>
        public INancyBootstrapper Bootstrapper
        {
            get { return this.bootstrapper ?? NancyBootstrapperLocator.Bootstrapper; }
            set { this.bootstrapper = value; }
        }

        /// <summary>
        /// Gets or sets the delegate that determines if NancyMiddleware performs pass through.
        /// </summary>
        public Func<NancyContext, bool> PerformPassThrough
        {
            get { return this.performPassThrough ?? (context => false); }
            set { this.performPassThrough = value; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether to request a client certificate or not.
        /// Defaults to false.
        /// </summary>
        public bool EnableClientCertificates { get; set; }
    }
}
namespace Nancy.Owin
{
    using System.Linq;

    /// <summary>
    /// Extensions for the NancyOptions class.
    /// </summary>
    public static class NancyOptionsExtensions
    {
        /// <summary>
        /// Tells the NancyMiddleware to pass through when
        /// response has one of the given status codes.
        /// </summary>
        /// <param name="nancyOptions">The Nancy options.</param>
        /// <param name="httpStatusCode">The HTTP status code.</param>
        public static void PassThroughWhenStatusCodesAre(this NancyOptions nancyOptions, params HttpStatusCode[] httpStatusCode)
        {
            nancyOptions.PerformPassThrough = context => httpStatusCode.Any(code => context.Response.StatusCode == code);
        }
    }
}
namespace Nancy.Owin
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Security.Claims;
    using System.Security.Cryptography.X509Certificates;
    using System.Threading;
    using System.Threading.Tasks;

    using Nancy.Helpers;
    using Nancy.IO;

    using AppFunc = System.Func<System.Collections.Generic.IDictionary<string, object>,
       System.Threading.Tasks.Task>;

    using MidFunc = System.Func<System.Func<System.Collections.Generic.IDictionary<string, object>,
            System.Threading.Tasks.Task>, System.Func<System.Collections.Generic.IDictionary<string, object>,
            System.Threading.Tasks.Task>>;

    /// <summary>
    /// Nancy middleware for OWIN.
    /// </summary>
    public static class NancyMiddleware
    {
        /// <summary>
        /// The request environment key
        /// </summary>
        public const string RequestEnvironmentKey = "OWIN_REQUEST_ENVIRONMENT";

        /// <summary>
        /// Use Nancy in an OWIN pipeline
        /// </summary>
        /// <param name="configuration">A delegate to configure the <see cref="NancyOptions"/>.</param>
        /// <returns>An OWIN middleware delegate.</returns>
        public static MidFunc UseNancy(Action<NancyOptions> configuration)
        {
            var options = new NancyOptions();
            configuration(options);
            return UseNancy(options);
        }

        /// <summary>
        /// Use Nancy in an OWIN pipeline
        /// </summary>
        /// <param name="options">An <see cref="NancyOptions"/> to configure the Nancy middleware</param>
        /// <returns>An OWIN middleware delegate.</returns>
        public static MidFunc UseNancy(NancyOptions options = null)
        {
            options = options ?? new NancyOptions();
            options.Bootstrapper.Initialise();
            var engine = options.Bootstrapper.GetEngine();

            return
                next =>
                    async environment =>
                    {
                        var owinRequestMethod = Get<string>(environment, "owin.RequestMethod");
                        var owinRequestScheme = Get<string>(environment, "owin.RequestScheme");
                        var owinRequestHeaders = Get<IDictionary<string, string[]>>(environment, "owin.RequestHeaders");
                        var owinRequestPathBase = Get<string>(environment, "owin.RequestPathBase");
                        var owinRequestPath = Get<string>(environment, "owin.RequestPath");
                        var owinRequestQueryString = Get<string>(environment, "owin.RequestQueryString");
                        var owinRequestBody = Get<Stream>(environment, "owin.RequestBody");
                        var owinRequestProtocol = Get<string>(environment, "owin.RequestProtocol");
                        var owinCallCancelled = Get<CancellationToken>(environment, "owin.CallCancelled");
                        var owinRequestHost = GetHeader(owinRequestHeaders, "Host") ?? Dns.GetHostName();
                        var owinUser = GetUser(environment);

                        byte[] certificate = null;
                        if (options.EnableClientCertificates)
                        {
                            var clientCertificate = Get<X509Certificate>(environment, "ssl.ClientCertificate");
                            certificate = (clientCertificate == null) ? null : clientCertificate.GetRawCertData();
                        }

                        var serverClientIp = Get<string>(environment, "server.RemoteIpAddress");

                        var url = CreateUrl(owinRequestHost, owinRequestScheme, owinRequestPathBase, owinRequestPath, owinRequestQueryString);

                        var nancyRequestStream = new RequestStream(owinRequestBody, ExpectedLength(owinRequestHeaders), StaticConfiguration.DisableRequestStreamSwitching ?? false);

                        var nancyRequest = new Request(
                                owinRequestMethod,
                                url,
                                nancyRequestStream,
                                owinRequestHeaders.ToDictionary(kv => kv.Key, kv => (IEnumerable<string>)kv.Value, StringComparer.OrdinalIgnoreCase),
                                serverClientIp,
                                certificate,
                                owinRequestProtocol);

                        var nancyContext = await engine.HandleRequest(
                            nancyRequest,
                            StoreEnvironment(environment, owinUser),
                            owinCallCancelled).ConfigureAwait(false);

                        await RequestComplete(nancyContext, environment, options.PerformPassThrough, next).ConfigureAwait(false);
                    };
        }

        /// <summary>
        /// Gets a delegate to handle converting a nancy response
        /// to the format required by OWIN and signals that the we are
        /// now complete.
        /// </summary>
        /// <param name="context">The Nancy Context.</param>
        /// <param name="environment">OWIN environment.</param>
        /// <param name="next">The next stage in the OWIN pipeline.</param>
        /// <param name="performPassThrough">A predicate that will allow the caller to determine if the request passes through to the 
        /// next stage in the owin pipeline.</param>
        /// <returns>Delegate</returns>
        private static Task RequestComplete(
            NancyContext context,
            IDictionary<string, object> environment,
            Func<NancyContext, bool> performPassThrough,
            AppFunc next)
        {
            var owinResponseHeaders = Get<IDictionary<string, string[]>>(environment, "owin.ResponseHeaders");
            var owinResponseBody = Get<Stream>(environment, "owin.ResponseBody");

            var nancyResponse = context.Response;
            if (!performPassThrough(context))
            {
                environment["owin.ResponseStatusCode"] = (int)nancyResponse.StatusCode;

                if (nancyResponse.ReasonPhrase != null)
                {
                    environment["owin.ResponseReasonPhrase"] = nancyResponse.ReasonPhrase;
                }

                foreach (var responseHeader in nancyResponse.Headers)
                {
                    owinResponseHeaders[responseHeader.Key] = new[] { responseHeader.Value };
                }

                if (!string.IsNullOrWhiteSpace(nancyResponse.ContentType))
                {
                    owinResponseHeaders["Content-Type"] = new[] { nancyResponse.ContentType };
                }

                if (nancyResponse.Cookies != null && nancyResponse.Cookies.Count != 0)
                {
                    const string setCookieHeaderKey = "Set-Cookie";
                    string[] setCookieHeader = owinResponseHeaders.ContainsKey(setCookieHeaderKey)
                                                    ? owinResponseHeaders[setCookieHeaderKey]
                                                    : ArrayCache.Empty<string>();
                    owinResponseHeaders[setCookieHeaderKey] = setCookieHeader
                        .Concat(nancyResponse.Cookies.Select(cookie => cookie.ToString()))
                        .ToArray();
                }

                nancyResponse.Contents(owinResponseBody);
            }
            else
            {
                return next(environment);
            }

            context.Dispose();

            return TaskHelpers.CompletedTask;
        }

        private static T Get<T>(IDictionary<string, object> env, string key)
        {
            object value;
            return env.TryGetValue(key, out value) && value is T ? (T)value : default(T);
        }

        private static string GetHeader(IDictionary<string, string[]> headers, string key)
        {
            string[] value;
            return headers.TryGetValue(key, out value) && value != null ? string.Join(",", value.ToArray()) : null;
        }

        private static ClaimsPrincipal GetUser(IDictionary<string, object> environment)
        {
            // OWIN 1.1
            object user;
            if (environment.TryGetValue("owin.RequestUser", out user))
            {
                return user as ClaimsPrincipal;
            }

            // check for Katana User
            if (environment.TryGetValue("server.User", out user))
            {
                return user as ClaimsPrincipal;
            }
            return null;
        }

        private static long ExpectedLength(IDictionary<string, string[]> headers)
        {
            var header = GetHeader(headers, "Content-Length");
            if (string.IsNullOrWhiteSpace(header))
                return 0;

            int contentLength;
            return int.TryParse(header, NumberStyles.Any, CultureInfo.InvariantCulture, out contentLength) ? contentLength : 0;
        }

        /// <summary>
        /// Creates the Nancy URL
        /// </summary>
        /// <param name="owinRequestHost">OWIN Hostname</param>
        /// <param name="owinRequestScheme">OWIN Scheme</param>
        /// <param name="owinRequestPathBase">OWIN Base path</param>
        /// <param name="owinRequestPath">OWIN Path</param>
        /// <param name="owinRequestQueryString">OWIN Querystring</param>
        /// <returns></returns>
        private static Url CreateUrl(
            string owinRequestHost,
            string owinRequestScheme,
            string owinRequestPathBase,
            string owinRequestPath,
            string owinRequestQueryString)
        {
            int? port = null;

            var hostnameParts = owinRequestHost.Split(':');
            if (hostnameParts.Length == 2)
            {
                owinRequestHost = hostnameParts[0];

                int tempPort;
                if (int.TryParse(hostnameParts[1], out tempPort))
                {
                    port = tempPort;
                }
            }

            var url = new Url
            {
                Scheme = owinRequestScheme,
                HostName = owinRequestHost,
                Port = port,
                BasePath = owinRequestPathBase,
                Path = owinRequestPath,
                Query = owinRequestQueryString,
            };
            return url;
        }

        /// <summary>
        /// Gets a delegate to store the OWIN environment and flow the user into the NancyContext
        /// </summary>
        /// <param name="environment">OWIN Environment</param>
        /// <returns>Delegate</returns>
        private static Func<NancyContext, NancyContext> StoreEnvironment(IDictionary<string, object> environment, ClaimsPrincipal user)
        {
            return context =>
            {
                context.CurrentUser = user;
                environment["nancy.NancyContext"] = context;
                context.Items[RequestEnvironmentKey] = environment;
                return context;
            };
        }
    }
}
namespace Nancy.Responses
{
    using System;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Security.Cryptography;
    using System.Text;
    using System.Text.RegularExpressions;

    public class EmbeddedFileResponse : Response
    {
        private static readonly byte[] ErrorText;

        static EmbeddedFileResponse()
        {
            ErrorText = Encoding.UTF8.GetBytes("NOT FOUND");
        }

        public EmbeddedFileResponse(Assembly assembly, string resourcePath, string name)
        {
            this.ContentType = MimeTypes.GetMimeType(name);
            this.StatusCode = HttpStatusCode.OK;

            var content =
                    GetResourceContent(assembly, resourcePath, name);

            if (content != null)
            {
                this.WithHeader("ETag", GenerateETag(content));
                content.Seek(0, SeekOrigin.Begin);
            }

            this.Contents = stream =>
            {
                if (content != null)
                {
                    content.CopyTo(stream);
                }
                else
                {
                    stream.Write(ErrorText, 0, ErrorText.Length);
                }
            };
        }

        private Stream GetResourceContent(Assembly assembly, string resourcePath, string name)
        {
            var resourceName = assembly
                .GetManifestResourceNames()
                .FirstOrDefault(x => GetFileNameFromResourceName(resourcePath, x).Equals(name, StringComparison.OrdinalIgnoreCase));

            if (resourceName == null)
                return null;

            return assembly.GetManifestResourceStream(resourceName);
        }

        private static string GetFileNameFromResourceName(string resourcePath, string resourceName)
        {
            return Regex.Replace(resourceName, resourcePath, string.Empty, RegexOptions.IgnoreCase).Substring(1);
        }

        private static string GenerateETag(Stream stream)
        {
            using (var sha1 = new SHA1CryptoServiceProvider())
            {
                var hash = sha1.ComputeHash(stream);
                return string.Concat("\"", ByteArrayToString(hash), "\"");
            }
        }

        private static string ByteArrayToString(byte[] data)
        {
            var output = new StringBuilder(data.Length);
            for (int i = 0; i < data.Length; i++)
            {
                output.Append(data[i].ToString("X2"));
            }

            return output.ToString();
        }
    }
}
namespace Nancy.Diagnostics
{
    /// <summary>
    /// Defines the functionality a diagnostics provider.
    /// </summary>
    public interface IDiagnosticsProvider
    {
        /// <summary>
        /// Gets the name of the provider.
        /// </summary>
        /// <value>A <see cref="string"/> containing the name of the provider.</value>
        string Name { get; }

        /// <summary>
        /// Gets the description of the provider.
        /// </summary>
        /// <value>A <see cref="string"/> containing the description of the provider.</value>
        string Description { get; }

        /// <summary>
        /// Gets the object that contains the interactive diagnostics methods.
        /// </summary>
        /// <value>An instance of the interactive diagnostics object.</value>
        object DiagnosticObject { get; }
    }
}
namespace Nancy.Diagnostics
{
    using System.Collections.Generic;

    public interface IInteractiveDiagnostics
    {
        IEnumerable<InteractiveDiagnostic> AvailableDiagnostics { get; }

        object ExecuteDiagnostic(InteractiveDiagnosticMethod interactiveDiagnosticMethod, object[] arguments);

        string GetTemplate(InteractiveDiagnosticMethod interactiveDiagnosticMethod);

        InteractiveDiagnostic GetDiagnostic(string providerName);

        InteractiveDiagnosticMethod GetMethod(string providerName, string methodName);
    }
}
namespace Nancy.Diagnostics
{
    using System.Collections.Generic;

    public class InteractiveDiagnostic
    {
        public string Name { get; set; }

        public string Description { get; set; }

        public IEnumerable<InteractiveDiagnosticMethod> Methods { get; set; }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Collections.Generic;

    public class InteractiveDiagnosticMethod
    {
        public object ParentDiagnosticObject { get; private set; }

        public Type ReturnType { get; private set; }

        public string MethodName { get; private set; }

        public string Description { get; private set; }

        public IEnumerable<Tuple<string, Type>> Arguments { get; private set; }

        public InteractiveDiagnosticMethod(object parentDiagnostic, Type returnType, string methodName, IEnumerable<Tuple<string, Type>> arguments, string description)
        {
            this.ParentDiagnosticObject = parentDiagnostic;
            this.ReturnType = returnType;
            this.MethodName = methodName;
            this.Arguments = arguments;
            this.Description = description;
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;

    using Nancy.Routing;

    public class InteractiveDiagnostics : IInteractiveDiagnostics
    {
        private readonly IDiagnosticsProvider[] providers;

        private const BindingFlags Flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy;

        public IEnumerable<InteractiveDiagnostic> AvailableDiagnostics { get; private set; }

        public InteractiveDiagnostics(IEnumerable<IDiagnosticsProvider> providers)
        {
            var customProvidersAvailable = providers.Any(provider =>
            {
                Type providerType = provider.GetType();

                return providerType != typeof(TestingDiagnosticProvider) &
                       providerType != typeof(DefaultRouteCacheProvider);
            });

            if (customProvidersAvailable)
            {
                // Exclude only the TestingDiagnosticProvider
                this.providers = providers.Where(provider => provider.GetType() != typeof(TestingDiagnosticProvider)).ToArray();
            }
            else
            {
                this.providers = providers.ToArray();
            }

            this.BuildAvailableDiagnostics();
        }

        public object ExecuteDiagnostic(InteractiveDiagnosticMethod interactiveDiagnosticMethod, object[] arguments)
        {
            var method = GetMethodInfo(interactiveDiagnosticMethod);

            if (method == null)
            {
                throw new ArgumentException(string.Format("Unable to locate method: {0}", interactiveDiagnosticMethod.MethodName));
            }

            return method.Invoke(interactiveDiagnosticMethod.ParentDiagnosticObject, arguments);
        }

        public string GetTemplate(InteractiveDiagnosticMethod interactiveDiagnosticMethod)
        {
            var diagObjectType = interactiveDiagnosticMethod.ParentDiagnosticObject.GetType();

            return GetTemplateFromProperty(interactiveDiagnosticMethod, diagObjectType) ??
                   GetTemplateFromAttribute(interactiveDiagnosticMethod);
        }

        public InteractiveDiagnostic GetDiagnostic(string providerName)
        {
            return this.AvailableDiagnostics.FirstOrDefault(d => string.Equals(d.Name, providerName, StringComparison.OrdinalIgnoreCase));
        }

        public InteractiveDiagnosticMethod GetMethod(string providerName, string methodName)
        {
            var diagnostic = this.GetDiagnostic(providerName);

            if (diagnostic == null)
            {
                return null;
            }

            return diagnostic.Methods.FirstOrDefault(m => string.Equals(m.MethodName, methodName, StringComparison.OrdinalIgnoreCase));
        }

        private void BuildAvailableDiagnostics()
        {
            var diags = new List<InteractiveDiagnostic>(this.providers.Length);

            foreach (var diagnosticsProvider in this.providers)
            {
                diags.Add(new InteractiveDiagnostic
                {
                    Name = diagnosticsProvider.Name,
                    Description = diagnosticsProvider.Description,
                    Methods = this.GetDiagnosticMethods(diagnosticsProvider)
                });
            }

            this.AvailableDiagnostics = diags;
        }

        private IEnumerable<InteractiveDiagnosticMethod> GetDiagnosticMethods(IDiagnosticsProvider diagnosticsProvider)
        {
            var objectMethods = typeof(object).GetMethods().Select(x => x.Name).ToList();

            var methods = diagnosticsProvider.DiagnosticObject
                                             .GetType()
                                             .GetMethods(Flags)
                                             .Where(x => !objectMethods.Contains(x.Name))
                                             .Where(mi => !mi.IsSpecialName)
                                             .ToArray();

            var diagnosticMethods = new List<InteractiveDiagnosticMethod>(methods.Length);

            foreach (var methodInfo in methods)
            {
                diagnosticMethods.Add(new InteractiveDiagnosticMethod(
                                            diagnosticsProvider.DiagnosticObject,
                                            methodInfo.ReturnType,
                                            methodInfo.Name,
                                            this.GetArguments(methodInfo),
                                            this.GetDescription(diagnosticsProvider, methodInfo)));
            }

            return diagnosticMethods;
        }

        private string GetDescription(IDiagnosticsProvider diagnosticsProvider, MethodInfo methodInfo)
        {
            return GetDescriptionFromProperty(diagnosticsProvider, methodInfo) ??
                   GetDescriptionFromAttribute(diagnosticsProvider, methodInfo);
        }

        private IEnumerable<Tuple<string, Type>> GetArguments(MethodInfo methodInfo)
        {
            var parameters = methodInfo.GetParameters();
            var arguments = new List<Tuple<string, Type>>(parameters.Length);

            foreach (var parameterInfo in parameters)
            {
                arguments.Add(Tuple.Create(parameterInfo.Name, parameterInfo.ParameterType));
            }

            return arguments;
        }

        private static string GetTemplateFromProperty(
            InteractiveDiagnosticMethod interactiveDiagnosticMethod, Type diagObjectType)
        {
            var propertyName = String.Format("{0}{1}", interactiveDiagnosticMethod.MethodName, "Template");
            var property = diagObjectType.GetProperty(propertyName);

            if (property == null)
            {
                return null;
            }

            return (string)property.GetValue(interactiveDiagnosticMethod.ParentDiagnosticObject, null);
        }

        private static string GetTemplateFromAttribute(InteractiveDiagnosticMethod interactiveDiagnosticMethod)
        {
            var method = GetMethodInfo(interactiveDiagnosticMethod);

            var attribute = (TemplateAttribute)Attribute.GetCustomAttribute(method, typeof(TemplateAttribute));

            return attribute != null ? attribute.Template : null;
        }

        private static string GetDescriptionFromProperty(IDiagnosticsProvider diagnosticsProvider, MethodInfo methodInfo)
        {
            var propertyName = String.Format("{0}{1}", methodInfo.Name, "Description");
            var property = diagnosticsProvider.DiagnosticObject.GetType().GetProperty(propertyName);

            if (property == null)
            {
                return null;
            }

            return (string)property.GetValue(diagnosticsProvider.DiagnosticObject, null);
        }

        private static string GetDescriptionFromAttribute(IDiagnosticsProvider diagnosticsProvider, MethodInfo methodInfo)
        {
            var attribute = (DescriptionAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DescriptionAttribute));

            return attribute != null ? attribute.Description : null;
        }

        private static MethodInfo GetMethodInfo(InteractiveDiagnosticMethod interactiveDiagnosticMethod)
        {
            var diagObjectType = interactiveDiagnosticMethod.ParentDiagnosticObject.GetType();

            var method = diagObjectType.GetMethod(interactiveDiagnosticMethod.MethodName, Flags);

            return method;
        }
    }
}
namespace Nancy.Diagnostics.Modules
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Dynamic;
    using System.Linq;
    using System.Reflection;
    using Nancy.Bootstrapper;
    using Nancy.Configuration;
    using Nancy.ViewEngines;

    public class InfoModule : DiagnosticModule
    {
        private readonly ITypeCatalog typeCatalog;

        public InfoModule(IRootPathProvider rootPathProvider, NancyInternalConfiguration configuration, INancyEnvironment environment, ITypeCatalog typeCatalog)
            : base("/info")
        {
            this.typeCatalog = typeCatalog;

            Get["/"] = async (_, __) =>
            {
                return View["Info"];
            };

            Get["/data"] = async (_, __) =>
            {
                dynamic data = new ExpandoObject();



                data.Nancy = new ExpandoObject();
                data.Nancy.Version = string.Format("v{0}", this.GetType().Assembly.GetName().Version.ToString());
                data.Nancy.TracesDisabled = !environment.GetValue<TraceConfiguration>().DisplayErrorTraces;
                data.Nancy.CaseSensitivity = StaticConfiguration.CaseSensitive ? "Sensitive" : "Insensitive";
                data.Nancy.RootPath = rootPathProvider.GetRootPath();
                data.Nancy.Hosting = GetHosting();
                data.Nancy.BootstrapperContainer = GetBootstrapperContainer();
                data.Nancy.LocatedBootstrapper = NancyBootstrapperLocator.Bootstrapper.GetType().ToString();
                data.Nancy.LoadedViewEngines = GetViewEngines();

                data.Configuration = new Dictionary<string, object>();
                foreach (var propertyInfo in configuration.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public))
                {
                    var value =
                        propertyInfo.GetValue(configuration, null);

                    data.Configuration[propertyInfo.Name] = (!typeof(IEnumerable).IsAssignableFrom(value.GetType())) ?
                        new[] { value.ToString() } :
                        ((IEnumerable<object>)value).Select(x => x.ToString());
                }

                return this.Response.AsJson((object)data);
            };
        }

        private string[] GetViewEngines()
        {
            var engines = this.typeCatalog.GetTypesAssignableTo<IViewEngine>();

            return engines
                .Select(engine => engine.Name.Split(new[] { "ViewEngine" }, StringSplitOptions.None)[0])
                .ToArray();
        }

        private static string GetBootstrapperContainer()
        {
            var name = AppDomain.CurrentDomain
                .GetAssemblies()
                .Select(asm => asm.GetName())
                .FirstOrDefault(asmName => asmName.Name != null && asmName.Name.StartsWith("Nancy.Bootstrappers."));

            return (name == null) ?
                "TinyIoC" :
                string.Format("{0} (v{1})", name.Name.Split('.').Last(), name.Version);
        }

        private static string GetHosting()
        {
            var name = AppDomain.CurrentDomain
                .GetAssemblies()
                .Select(asm => asm.GetName())
                .FirstOrDefault(asmName => asmName.Name != null && asmName.Name.StartsWith("Nancy.Hosting."));

            return (name == null) ?
                "Unknown" :
                string.Format("{0} (v{1})", name.Name.Split('.').Last(), name.Version);
        }
    }
}
namespace Nancy.Diagnostics.Modules
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using System.Text.RegularExpressions;
    using Nancy.ModelBinding;

    public class SettingsModule : DiagnosticModule
    {
        private static readonly IEnumerable<Type> Types = new[] { typeof(StaticConfiguration) }.Union(
                                                                  typeof(StaticConfiguration).GetNestedTypes(BindingFlags.Static | BindingFlags.Public));

        public SettingsModule()
            : base("/settings")
        {
            Get["/"] = async (_, __) =>
            {
                var properties = Types.SelectMany(t => t.GetProperties(BindingFlags.Static | BindingFlags.Public))
                                      .Where(x => x.PropertyType == typeof(bool));

                var model = from property in properties
                            orderby property.Name
                            let value = (bool)property.GetValue(null, null)
                            let description = GetDescription(property)
                            where !string.IsNullOrEmpty(description)
                            select new
                            {
                                Name = property.Name,
                                Description = description,
                                DisplayName = Regex.Replace(property.Name, "[A-Z]", " $0"),
                                Value = value,
                                Checked = (value) ? "checked='checked'" : string.Empty
                            };

                return View["Settings", model];
            };

            Post["/"] = async (_, __) => {

                var model =
                    this.Bind<SettingsModel>();

                var property = GetProperty(model);

                if (property != null)
                {
                    property.SetValue(null, model.Value, null);
                }

                return HttpStatusCode.OK;
            };
        }

        private static PropertyInfo GetProperty(SettingsModel model)
        {
            return Types.SelectMany(t => t.GetProperties(BindingFlags.Static | BindingFlags.Public))
                        .SingleOrDefault(x => x.Name.Equals(model.Name, StringComparison.OrdinalIgnoreCase));
        }

        private static string GetDescription(PropertyInfo property)
        {
            var attributes = property
                .GetCustomAttributes(typeof(DescriptionAttribute), false)
                .Cast<DescriptionAttribute>()
                .ToArray();

            return (!attributes.Any()) ? string.Empty : attributes.First().Description;
        }
    }

    public class SettingsModel
    {
        public string Name { get; set; }

        public bool Value { get; set; }
    }
}
namespace Nancy.Diagnostics.Modules
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Linq;
    using Nancy.Helpers;

    public class InteractiveModule : DiagnosticModule
    {
        private readonly IInteractiveDiagnostics interactiveDiagnostics;

        public InteractiveModule(IInteractiveDiagnostics interactiveDiagnostics)
            : base("/interactive")
        {
            this.interactiveDiagnostics = interactiveDiagnostics;

            Get["/"] = async (_, __) =>
            {
                return View["InteractiveDiagnostics"];
            };

            Get["/providers"] = async (_, __) =>
            {
                var providers = this.interactiveDiagnostics
                    .AvailableDiagnostics
                    .Select(p => new
                    {
                        p.Name,
                        p.Description,
                        Type = p.GetType().Name,
                        p.GetType().Namespace,
                        Assembly = p.GetType().Assembly.GetName().Name
                    })
                    .ToArray();

                return this.Response.AsJson(providers);
            };

            Get["/providers/{providerName}"] = async (ctx, __) =>
            {
                var providerName =
                    HttpUtility.UrlDecode((string)ctx.providerName);

                var diagnostic =
                    this.interactiveDiagnostics.GetDiagnostic(providerName);

                if (diagnostic == null)
                {
                    return HttpStatusCode.NotFound;
                }

                var methods = diagnostic.Methods
                    .Select(m => new
                    {
                        m.MethodName,
                        ReturnType = m.ReturnType.ToString(),
                        m.Description,
                        Arguments = m.Arguments.Select(a => new
                        {
                            ArgumentName = a.Item1,
                            ArgumentType = a.Item2.ToString()
                        })
                    })
                    .ToArray();

                return this.Response.AsJson(methods);
            };

            Get["/providers/{providerName}/{methodName}"] = async (ctx, __) =>
            {
                var providerName =
                    HttpUtility.UrlDecode((string)ctx.providerName);

                var methodName =
                    HttpUtility.UrlDecode((string)ctx.methodName);

                var method =
                    this.interactiveDiagnostics.GetMethod(providerName, methodName);

                if (method == null)
                {
                    return HttpStatusCode.NotFound;
                }

                object[] arguments =
                    GetArguments(method, this.Request.Query);

                return this.Response.AsJson(new { Result = this.interactiveDiagnostics.ExecuteDiagnostic(method, arguments) });
            };

            Get["/templates/{providerName}/{methodName}"] = async (ctx, __) =>
            {
                var providerName =
                    HttpUtility.UrlDecode((string)ctx.providerName);

                var methodName =
                    HttpUtility.UrlDecode((string)ctx.methodName);

                var method =
                    this.interactiveDiagnostics.GetMethod(providerName, methodName);

                if (method == null)
                {
                    return HttpStatusCode.NotFound;
                }

                var template =
                    this.interactiveDiagnostics.GetTemplate(method);

                if (template == null)
                {
                    return HttpStatusCode.NotFound;
                }

                return template;
            };
        }

        private static object[] GetArguments(InteractiveDiagnosticMethod method, dynamic query)
        {
            var arguments = new List<object>();

            foreach (var argument in method.Arguments)
            {
                arguments.Add(ConvertArgument((string)query[argument.Item1].Value, argument.Item2));
            }

            return arguments.ToArray();
        }

        private static object ConvertArgument(string value, Type destinationType)
        {
            var converter =
                TypeDescriptor.GetConverter(destinationType);

            if (converter == null || !converter.CanConvertFrom(typeof(string)))
            {
                return null;
            }

            try
            {
                return converter.ConvertFrom(value);
            }
            catch (FormatException)
            {
                return null;
            }
        }
    }
}
namespace Nancy.Diagnostics.Modules
{
    public class MainModule : DiagnosticModule
    {
        public MainModule()
        {
            Get["/"] = async (_, __) =>
            {
                return View["Dashboard"];
            };

            Post["/"] = async (_, __) => this.Response.AsRedirect("~/");
        }
    }
}
namespace Nancy.Diagnostics.Modules
{
    using System;
    using System.Linq;

    public class TraceModule : DiagnosticModule
    {
        private readonly IRequestTracing sessionProvider;

        public TraceModule(IRequestTracing sessionProvider)
            : base("/trace")
        {
            this.sessionProvider = sessionProvider;

            Get["/"] = async (_, __) =>
            {
                return View["RequestTracing"];
            };

            Get["/sessions"] = async (_, __) =>
            {
                return this.Response.AsJson(this.sessionProvider.GetSessions().Select(s => new { Id = s.Id }).ToArray());
            };

            Get["/sessions/{id}"] = async (ctx, __) =>
            {
                Guid id;
                if (!Guid.TryParse(ctx.Id, out id))
                {
                    return HttpStatusCode.NotFound;
                }

                var session =
                    this.sessionProvider.GetSessions().FirstOrDefault(s => s.Id == id);

                if (session == null)
                {
                    return HttpStatusCode.NotFound;
                }

                return this.Response.AsJson(session.RequestTraces.Select(t => new
                {
                    t.RequestData.Method,
                    RequestUrl = t.RequestData.Url,
                    RequestContentType = t.RequestData.ContentType,
                    ResponseContentType = t.ResponseData.ContentType,
                    RequestHeaders = t.RequestData.Headers,
                    ResponseHeaders = t.ResponseData.Headers,
                    t.ResponseData.StatusCode,
                    Log = t.TraceLog.ToString().Replace("\r", "").Split(new[] { "\n" }, StringSplitOptions.None),
                }).ToArray());
            };
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;

    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public class TemplateAttribute : Attribute
    {
        public string Template { get; set; }

        public TemplateAttribute(string template)
        {
            this.Template = template;
        }
    }
}
namespace Nancy.Diagnostics
{
    public class TestingDiagnosticProvider : IDiagnosticsProvider
    {
        private readonly object diagObject;

        public TestingDiagnosticProvider()
        {
            this.diagObject = new DiagObject();
        }

        /// <summary>
        /// Gets the name of the provider.
        /// </summary>
        /// <value>A <see cref="string"/> containing the name of the provider.</value>
        public string Name
        {
            get { return "Testing Diagnostic Provider"; }
        }

        /// <summary>
        /// Gets the description of the provider.
        /// </summary>
        /// <value>A <see cref="string"/> containing the description of the provider.</value>
        public string Description
        {
            get { return "Some testing methods that can be called to.. erm.. test things."; }
        }

        /// <summary>
        /// Gets the object that contains the interactive diagnostics methods.
        /// </summary>
        /// <value>An instance of the interactive diagnostics object.</value>
        public object DiagnosticObject
        {
            get { return this.diagObject; }
        }

        public class DiagObject
        {
            public void NoReturnValue()
            {

            }

            public string StringReturnValue()
            {
                return "Hello!";
            }

            public string SayHello(string name)
            {
                return string.Format("Hello {0}!", name);
            }

            public string SayHelloWithAgeTemplate
            {
                get
                {
                    return "<h1>Templated Results</h1><p>{{model.result}}</p>";
                }
            }

            public string SayHelloWithAgeDescription
            {
                get
                {
                    return "Simple test method that takes a name and an age and returns a result with a template.";
                }
            }

            public string SayHelloWithAge(string myName, int myAge)
            {
                return string.Format("Hello {0}, you are {1} years old!", myName, myAge);
            }

            [Template("<h1>Templated Results</h1><p>{{model.result}}</p>")]
            [Description("Simple test method that takes a name and an age and returns a result with a template.")]
            public string SayHelloWithAge2(string myName, int myAge)
            {
                return string.Format("Hello {0}, you are {1} years old!", myName, myAge);
            }
        }
    }
}
namespace Nancy
{
    /// <summary>
    /// Defines the functionality of a <see cref="IResponseFormatter"/> factory.
    /// </summary>
    public interface IResponseFormatterFactory
    {
        /// <summary>
        /// Creates a new <see cref="IResponseFormatter"/> instance.
        /// </summary>
        /// <param name="context">The <see cref="NancyContext"/> instance that should be used by the response formatter.</param>
        /// <returns>An <see cref="IResponseFormatter"/> instance.</returns>
        IResponseFormatter Create(NancyContext context);
    }
}
namespace Nancy
{
    using System;
    using System.IO;
    using System.Linq;
    using System.Text;
    using Nancy.Bootstrapper;
    using Nancy.Configuration;
    using Nancy.Json;

    /// <summary>
    /// Handles JSONP requests.
    /// </summary>
    public static class Jsonp
    {
        private static readonly PipelineItem<Action<NancyContext>> JsonpItem;
        private static Encoding encoding;

        static Jsonp()
        {
            JsonpItem = new PipelineItem<Action<NancyContext>>("JSONP", PrepareJsonp);
        }

        private static string Encoding
        {
            get { return string.Concat("; charset=", encoding.WebName); }
        }

        /// <summary>
        /// Enable JSONP support in the application
        /// </summary>
        /// <param name="pipelines">Application Pipeline to Hook into</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public static void Enable(IPipelines pipelines, INancyEnvironment environment)
        {
            var jsonpEnabled = pipelines.AfterRequest.PipelineItems.Any(ctx => ctx.Name == "JSONP");

            if (!jsonpEnabled)
            {
                encoding = environment.GetValue<JsonConfiguration>().DefaultEncoding;
                pipelines.AfterRequest.AddItemToEndOfPipeline(JsonpItem);
            }
        }

        /// <summary>
        /// Disable JSONP support in the application
        /// </summary>
        /// <param name="pipelines">Application Pipeline to Hook into</param>
        public static void Disable(IPipelines pipelines)
        {
            pipelines.AfterRequest.RemoveByName("JSONP");
        }

        /// <summary>
        /// Transmogrify original response and apply JSONP Padding
        /// </summary>
        /// <param name="context">Current Nancy Context</param>
        private static void PrepareJsonp(NancyContext context)
        {
            var isJson = Json.Json.IsJsonContentType(context.Response.ContentType);
            bool hasCallback = context.Request.Query["callback"].HasValue;

            if (!isJson || !hasCallback)
            {
                return;
            }

            // grab original contents for running later
            var original = context.Response.Contents;
            string callback = context.Request.Query["callback"].Value;

            // set content type to application/javascript so browsers can handle it by default
            // http://stackoverflow.com/questions/111302/best-content-type-to-serve-jsonp
            context.Response.ContentType = string.Concat("application/javascript", Encoding);

            context.Response.Contents = stream =>
            {
                // disposing of stream is handled elsewhere
                var writer = new StreamWriter(stream)
                {
                    AutoFlush = true
                };

                writer.Write("{0}(", callback);
                original(stream);
                writer.Write(");");
            };
        }
    }
}
namespace Nancy
{
    using Nancy.Bootstrapper;
    using Nancy.Configuration;

    /// <summary>
    /// Enables JSONP support at application startup.
    /// </summary>
    public class JsonpApplicationStartup : IApplicationStartup
    {
        private readonly INancyEnvironment environment;

        /// <summary>
        /// Initializes a new instance of the <see cref="JsonpApplicationStartup"/> class,
        /// with the provided <see cref="INancyEnvironment"/> instance.
        /// </summary>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public JsonpApplicationStartup(INancyEnvironment environment)
        {
            this.environment = environment;
        }

        /// <summary>
        /// Perform any initialisation tasks
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        public void Initialize(IPipelines pipelines)
        {
            Jsonp.Enable(pipelines, this.environment);
        }
    }
}
namespace Nancy
{
    using System;

    /// <summary>
    /// Exception that is thrown when an unhandled exception occurred during
    /// the execution of the current request.
    /// </summary>
    public class RequestExecutionException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RequestExecutionException"/>, with
        /// the specified <paramref name="innerException"/>.
        /// </summary>
        /// <param name="innerException"></param>
        public RequestExecutionException(Exception innerException)
            : base("Oh noes!", innerException)
        {
        }
    }
}
namespace Nancy.Responses
{
    using System;
    using System.IO;
    using System.Threading.Tasks;

    using Nancy.Helpers;

    /// <summary>
    /// Takes an existing response and materialises the body.
    /// Can be used as a wrapper to force execution of the deferred body for
    /// error checking etc.
    /// Copies the existing response into memory, so use with caution.
    /// </summary>
    public class MaterialisingResponse : Response
    {
        private readonly Response sourceResponse;
        private byte[] oldResponseOutput;

        public override Task PreExecute(NancyContext context)
        {
            using (var memoryStream = new MemoryStream())
            {
                this.sourceResponse.Contents.Invoke(memoryStream);
                this.oldResponseOutput = memoryStream.ToArray();
            }

            return base.PreExecute(context);
        }

        public MaterialisingResponse(Response sourceResponse)
        {
            this.sourceResponse = sourceResponse;
            this.ContentType = sourceResponse.ContentType;
            this.Headers = sourceResponse.Headers;
            this.StatusCode = sourceResponse.StatusCode;
            this.ReasonPhrase = sourceResponse.ReasonPhrase;

            this.Contents = WriteContents;
        }

        private void WriteContents(Stream stream)
        {
            if (this.oldResponseOutput == null)
            {
                this.sourceResponse.Contents.Invoke(stream);
            }
            else
            {
                stream.Write(this.oldResponseOutput, 0, this.oldResponseOutput.Length);
            }
        }
    }
}
namespace Nancy.Responses
{
    /// <summary>
    /// Response that indicates that the response format should be negotiated between the client and the server.
    /// </summary>
    public class NegotiatedResponse : Response
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NegotiatedResponse"/> response for the
        /// provided <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The response value that should be negotiated.</param>
        public NegotiatedResponse(dynamic value)
        {
            Value = value;
        }

        /// <summary>
        /// Gets or sets the value that should be negotiated.
        /// </summary>
        public dynamic Value { get; set; }
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;

    using Nancy.Conventions;
    using Nancy.Extensions;

    /// <summary>
    /// The default implementation for a response negotiator.
    /// </summary>
    public class DefaultResponseNegotiator : IResponseNegotiator
    {
        private readonly IEnumerable<IResponseProcessor> processors;
        private readonly AcceptHeaderCoercionConventions coercionConventions;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultResponseNegotiator"/> class.
        /// </summary>
        /// <param name="processors">The response processors.</param>
        /// <param name="coercionConventions">The Accept header coercion conventions.</param>
        public DefaultResponseNegotiator(IEnumerable<IResponseProcessor> processors, AcceptHeaderCoercionConventions coercionConventions)
        {
            this.processors = processors;
            this.coercionConventions = coercionConventions;
        }

        /// <summary>
        /// Negotiates the response based on the given result and context.
        /// </summary>
        /// <param name="routeResult">The route result.</param>
        /// <param name="context">The context.</param>
        /// <returns>A <see cref="Response" />.</returns>
        public Response NegotiateResponse(dynamic routeResult, NancyContext context)
        {
            Response response;
            if (TryCastResultToResponse(routeResult, out response))
            {
                context.WriteTraceLog(sb =>
                    sb.AppendLine("[DefaultResponseNegotiator] Processing as real response"));

                return response;
            }

            context.WriteTraceLog(sb =>
                sb.AppendLine("[DefaultResponseNegotiator] Processing as negotiation"));

            NegotiationContext negotiationContext = GetNegotiationContext(routeResult, context);

            var coercedAcceptHeaders = this.GetCoercedAcceptHeaders(context).ToArray();

            context.WriteTraceLog(sb => GetAccepHeaderTraceLog(context, negotiationContext, coercedAcceptHeaders, sb));

            var compatibleHeaders = this.GetCompatibleHeaders(coercedAcceptHeaders, negotiationContext, context).ToArray();

            if (!compatibleHeaders.Any())
            {
                context.WriteTraceLog(sb =>
                    sb.AppendLine("[DefaultResponseNegotiator] Unable to negotiate response - no headers compatible"));

                return new NotAcceptableResponse();
            }

            return CreateResponse(compatibleHeaders, negotiationContext, context);
        }

        /// <summary>
        /// Tries to cast the dynamic result to a <see cref="Response"/>.
        /// </summary>
        /// <param name="routeResult">The result.</param>
        /// <param name="response">The response.</param>
        /// <returns><c>true</c> if the result is a <see cref="Response"/>, <c>false</c> otherwise.</returns>
        private static bool TryCastResultToResponse(dynamic routeResult, out Response response)
        {
            // This code has to be designed this way in order for the cast operator overloads
            // to be called in the correct way. It cannot be replaced by the as-operator.
            try
            {
                response = (Response)routeResult;
                return true;
            }
            catch
            {
                response = null;
                return false;
            }
        }

        /// <summary>
        /// Gets a <see cref="NegotiationContext"/> based on the given result and context.
        /// </summary>
        /// <param name="routeResult">The route result.</param>
        /// <param name="context">The context.</param>
        /// <returns>A <see cref="NegotiationContext"/>.</returns>
        private static NegotiationContext GetNegotiationContext(object routeResult, NancyContext context)
        {
            var negotiator = routeResult as Negotiator;

            if (negotiator == null)
            {
                context.WriteTraceLog(sb =>
                    sb.AppendFormat("[DefaultResponseNegotiator] Wrapping result of type {0} in negotiator\n", routeResult.GetType()));

                negotiator = new Negotiator(context).WithModel(routeResult);
            }

            return negotiator.NegotiationContext;
        }

        /// <summary>
        /// Gets the coerced accept headers based on the <see cref="AcceptHeaderCoercionConventions"/>.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <returns>IEnumerable{Tuple{System.String, System.Decimal}}.</returns>
        private IEnumerable<Tuple<string, decimal>> GetCoercedAcceptHeaders(NancyContext context)
        {
            return this.coercionConventions.Aggregate(context.Request.Headers.Accept, (current, coercion) => coercion.Invoke(current, context));
        }

        private static void GetAccepHeaderTraceLog(
            NancyContext context,
            NegotiationContext negotiationContext,
            Tuple<string, decimal>[] coercedAcceptHeaders,
            StringBuilder sb)
        {
            var allowableFormats = negotiationContext.PermissableMediaRanges
                .Select(mr => mr.ToString())
                .Aggregate((t1, t2) => t1 + ", " + t2);

            var originalAccept = context.Request.Headers["accept"].Any()
                ? string.Join(", ", context.Request.Headers["accept"])
                : "None";

            var coercedAccept = coercedAcceptHeaders.Any()
                ? coercedAcceptHeaders.Select(h => h.Item1).Aggregate((t1, t2) => t1 + ", " + t2)
                : "None";

            sb.AppendFormat("[DefaultResponseNegotiator] Original accept header: {0}\n", originalAccept);
            sb.AppendFormat("[DefaultResponseNegotiator] Coerced accept header: {0}\n", coercedAccept);
            sb.AppendFormat("[DefaultResponseNegotiator] Acceptable media ranges: {0}\n", allowableFormats);
        }

        private IEnumerable<CompatibleHeader> GetCompatibleHeaders(
            IEnumerable<Tuple<string, decimal>> coercedAcceptHeaders,
            NegotiationContext negotiationContext,
            NancyContext context)
        {
            var acceptHeaders = GetCompatibleHeaders(coercedAcceptHeaders, negotiationContext);

            foreach (var header in acceptHeaders)
            {
                var mediaRangeModel = negotiationContext.GetModelForMediaRange(header.Item1);

                IEnumerable<Tuple<IResponseProcessor, ProcessorMatch>> compatibleProcessors =
                    this.GetCompatibleProcessorsByHeader(header.Item1, mediaRangeModel, context);

                if (compatibleProcessors.Any())
                {
                    yield return new CompatibleHeader(header.Item1, compatibleProcessors);
                }
            }
        }

        private static IEnumerable<Tuple<string, decimal>> GetCompatibleHeaders(
            IEnumerable<Tuple<string, decimal>> coercedAcceptHeaders,
            NegotiationContext negotiationContext)
        {
            var permissableMediaRanges = negotiationContext.PermissableMediaRanges;
            if (permissableMediaRanges.Any(mr => mr.IsWildcard))
            {
                return coercedAcceptHeaders.Where(header => header.Item2 > 0m);
            }

            return coercedAcceptHeaders
                .Where(header => header.Item2 > 0m)
                .SelectMany(header => permissableMediaRanges
                    .Where(mr => mr.Matches(header.Item1))
                    .Select(mr => Tuple.Create(mr.ToString(), header.Item2)));
        }

        /// <summary>
        /// Gets compatible response processors by header.
        /// </summary>
        /// <param name="acceptHeader">The accept header.</param>
        /// <param name="model">The model.</param>
        /// <param name="context">The context.</param>
        /// <returns>IEnumerable{Tuple{IResponseProcessor, ProcessorMatch}}.</returns>
        private IEnumerable<Tuple<IResponseProcessor, ProcessorMatch>> GetCompatibleProcessorsByHeader(
            string acceptHeader, dynamic model, NancyContext context)
        {
            foreach (var processor in this.processors)
            {
                ProcessorMatch match = processor.CanProcess(acceptHeader, model, context);

                if (match.ModelResult != MatchResult.NoMatch && match.RequestedContentTypeResult != MatchResult.NoMatch)
                {
                    yield return new Tuple<IResponseProcessor, ProcessorMatch>(processor, match);
                }
            }
        }

        /// <summary>
        /// Creates a response from the compatible headers.
        /// </summary>
        /// <param name="compatibleHeaders">The compatible headers.</param>
        /// <param name="negotiationContext">The negotiation context.</param>
        /// <param name="context">The context.</param>
        /// <returns>A <see cref="Response"/>.</returns>
        private static Response CreateResponse(
            IList<CompatibleHeader> compatibleHeaders,
            NegotiationContext negotiationContext,
            NancyContext context)
        {
            var response = NegotiateResponse(compatibleHeaders, negotiationContext, context);

            if (response == null)
            {
                context.WriteTraceLog(sb =>
                    sb.AppendLine("[DefaultResponseNegotiator] Unable to negotiate response - no processors returned valid response"));

                response = new NotAcceptableResponse();
            }

            response.WithHeader("Vary", "Accept");

            AddLinkHeader(compatibleHeaders, response, context.Request.Url);
            SetStatusCode(negotiationContext, response);
            SetReasonPhrase(negotiationContext, response);
            AddCookies(negotiationContext, response);

            if (response is NotAcceptableResponse)
            {
                return response;
            }

            AddContentTypeHeader(negotiationContext, response);
            AddNegotiatedHeaders(negotiationContext, response);

            return response;
        }

        /// <summary>
        /// Prioritizes the response processors and tries to negotiate a response.
        /// </summary>
        /// <param name="compatibleHeaders">The compatible headers.</param>
        /// <param name="negotiationContext">The negotiation context.</param>
        /// <param name="context">The context.</param>
        /// <returns>Response.</returns>
        private static Response NegotiateResponse(
            IEnumerable<CompatibleHeader> compatibleHeaders,
            NegotiationContext negotiationContext,
            NancyContext context)
        {
            foreach (var compatibleHeader in compatibleHeaders)
            {
                var prioritizedProcessors = compatibleHeader.Processors
                    .OrderByDescending(x => x.Item2.ModelResult)
                    .ThenByDescending(x => x.Item2.RequestedContentTypeResult);

                foreach (var prioritizedProcessor in prioritizedProcessors)
                {
                    var processorType = prioritizedProcessor.Item1.GetType();

                    context.WriteTraceLog(sb =>
                        sb.AppendFormat("[DefaultResponseNegotiator] Invoking processor: {0}\n", processorType));

                    var mediaRangeModel = negotiationContext.GetModelForMediaRange(compatibleHeader.MediaRange);

                    var response = prioritizedProcessor.Item1.Process(compatibleHeader.MediaRange, mediaRangeModel, context);
                    if (response != null)
                    {
                        return response;
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// Adds a link header to the <see cref="Response"/>.
        /// </summary>
        /// <param name="compatibleHeaders">The compatible headers.</param>
        /// <param name="response">The response.</param>
        /// <param name="requestUrl">The request URL.</param>
        private static void AddLinkHeader(
            IEnumerable<CompatibleHeader> compatibleHeaders,
            Response response,
            Url requestUrl)
        {
            var linkProcessors = GetLinkProcessors(compatibleHeaders, response.ContentType);
            if (linkProcessors.Any())
            {
                response.Headers["Link"] = CreateLinkHeader(requestUrl, linkProcessors);
            }
        }

        /// <summary>
        /// Gets the link processors based on the compatible headers and content-type.
        /// </summary>
        /// <param name="compatibleHeaders">The compatible headers.</param>
        /// <param name="contentType">The content-type of the response.</param>
        /// <returns>Dictionary{System.String, MediaRange}.</returns>
        private static IDictionary<string, MediaRange> GetLinkProcessors(
            IEnumerable<CompatibleHeader> compatibleHeaders,
            string contentType)
        {
            var linkProcessors = new Dictionary<string, MediaRange>();

            var compatibleHeaderMappings = compatibleHeaders
                .SelectMany(header => header.Processors)
                .SelectMany(processor => processor.Item1.ExtensionMappings)
                .Where(mapping => !mapping.Item2.Matches(contentType));

            foreach (var compatibleHeaderMapping in compatibleHeaderMappings)
            {
                linkProcessors[compatibleHeaderMapping.Item1] = compatibleHeaderMapping.Item2;
            }

            return linkProcessors;
        }

        /// <summary>
        /// Creates the link header with the different media ranges.
        /// </summary>
        /// <param name="requestUrl">The request URL.</param>
        /// <param name="linkProcessors">The link processors.</param>
        /// <returns>The link header.</returns>
        private static string CreateLinkHeader(Url requestUrl, IEnumerable<KeyValuePair<string, MediaRange>> linkProcessors)
        {
            var fileName = Path.GetFileNameWithoutExtension(requestUrl.Path);
            var baseUrl = string.Concat(requestUrl.BasePath, "/", fileName);

            var links = linkProcessors
                .Select(lp => string.Format("<{0}.{1}>; rel=\"{2}\"", baseUrl, lp.Key, lp.Value));

            return string.Join(",", links);
        }

        /// <summary>
        /// Adds the content type header from the <see cref="NegotiationContext"/> to the <see cref="Response"/>.
        /// </summary>
        /// <param name="negotiationContext">The negotiation context.</param>
        /// <param name="response">The response.</param>
        private static void AddContentTypeHeader(NegotiationContext negotiationContext, Response response)
        {
            if (negotiationContext.Headers.ContainsKey("Content-Type"))
            {
                response.ContentType = negotiationContext.Headers["Content-Type"];
                negotiationContext.Headers.Remove("Content-Type");
            }
        }

        /// <summary>
        /// Adds the negotiated headers from the <see cref="NegotiationContext"/> to the <see cref="Response"/>.
        /// </summary>
        /// <param name="negotiationContext">The negotiation context.</param>
        /// <param name="response">The response.</param>
        private static void AddNegotiatedHeaders(NegotiationContext negotiationContext, Response response)
        {
            foreach (var header in negotiationContext.Headers)
            {
                response.Headers[header.Key] = header.Value;
            }
        }

        /// <summary>
        /// Sets the status code from the <see cref="NegotiationContext"/> on the <see cref="Response"/>.
        /// </summary>
        /// <param name="negotiationContext">The negotiation context.</param>
        /// <param name="response">The response.</param>
        private static void SetStatusCode(NegotiationContext negotiationContext, Response response)
        {
            if (negotiationContext.StatusCode.HasValue)
            {
                response.StatusCode = negotiationContext.StatusCode.Value;
            }
        }

        /// <summary>
        /// Sets the reason phrase from the <see cref="NegotiationContext"/> on the <see cref="Response"/>.
        /// </summary>
        /// <param name="negotiationContext">The negotiation context.</param>
        /// <param name="response">The response.</param>
        private static void SetReasonPhrase(NegotiationContext negotiationContext, Response response)
        {
            if (negotiationContext.ReasonPhrase != null)
            {
                response.ReasonPhrase = negotiationContext.ReasonPhrase;
            }
        }

        /// <summary>
        /// Adds the cookies from the <see cref="NegotiationContext"/> to the <see cref="Response"/>.
        /// </summary>
        /// <param name="negotiationContext">The negotiation context.</param>
        /// <param name="response">The response.</param>
        private static void AddCookies(NegotiationContext negotiationContext, Response response)
        {
            foreach (var cookie in negotiationContext.Cookies)
            {
                response.Cookies.Add(cookie);
            }
        }

        private class CompatibleHeader
        {
            public CompatibleHeader(
                string mediaRange,
                IEnumerable<Tuple<IResponseProcessor, ProcessorMatch>> processors)
            {
                this.MediaRange = mediaRange;
                this.Processors = processors;
            }

            public string MediaRange { get; private set; }

            public IEnumerable<Tuple<IResponseProcessor, ProcessorMatch>> Processors { get; private set; }
        }
    }
}
namespace Nancy.Responses.Negotiation
{
    /// <summary>
    /// Creates a response from a given result and context.
    /// </summary>
    public interface IResponseNegotiator
    {
        /// <summary>
        /// Negotiates the response based on the given result and context.
        /// </summary>
        /// <param name="routeResult">The route result.</param>
        /// <param name="context">The context.</param>
        /// <returns>A <see cref="Response"/>.</returns>
        Response NegotiateResponse(dynamic routeResult, NancyContext context);
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Content negotiation response processor
    /// </summary>
    public interface IResponseProcessor
    {
        /// <summary>
        /// Gets a set of mappings that map a given extension (such as .json)
        /// to a media range that can be sent to the client in a vary header.
        /// </summary>
        IEnumerable<Tuple<string, MediaRange>> ExtensionMappings { get; }

        /// <summary>
        /// Determines whether the processor can handle a given content type and model.
        /// </summary>
        /// <param name="requestedMediaRange">Content type requested by the client.</param>
        /// <param name="model">The model for the given media range.</param>
        /// <param name="context">The nancy context.</param>
        /// <returns>A <see cref="ProcessorMatch"/> result that determines the priority of the processor.</returns>
        ProcessorMatch CanProcess(MediaRange requestedMediaRange, dynamic model, NancyContext context);

        /// <summary>
        /// Process the response.
        /// </summary>
        /// <param name="requestedMediaRange">Content type requested by the client.</param>
        /// <param name="model">The model for the given media range.</param>
        /// <param name="context">The nancy context.</param>
        /// <returns>A <see cref="Response"/> instance.</returns>
        Response Process(MediaRange requestedMediaRange, dynamic model, NancyContext context);
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Nancy.Configuration;

    /// <summary>
    /// Processes the model for json media types and extension.
    /// </summary>
    public class JsonProcessor : IResponseProcessor
    {
        private readonly ISerializer serializer;
        private readonly INancyEnvironment environment;

        private static readonly IEnumerable<Tuple<string, MediaRange>> extensionMappings =
            new[] { new Tuple<string, MediaRange>("json", new MediaRange("application/json")) };

        /// <summary>
        /// Initializes a new instance of the <see cref="JsonProcessor"/> class,
        /// with the provided <paramref name="serializers"/>.
        /// </summary>
        /// <param name="serializers">The serializes that the processor will use to process the request.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public JsonProcessor(IEnumerable<ISerializer> serializers, INancyEnvironment environment)
        {
            this.serializer = serializers.FirstOrDefault(x => x.CanSerialize("application/json"));
            this.environment = environment;
        }

        /// <summary>
        /// Gets a set of mappings that map a given extension (such as .json)
        /// to a media range that can be sent to the client in a vary header.
        /// </summary>
        public IEnumerable<Tuple<string, MediaRange>> ExtensionMappings
        {
            get { return extensionMappings; }
        }

        /// <summary>
        /// Determines whether the processor can handle a given content type and model
        /// </summary>
        /// <param name="requestedMediaRange">Content type requested by the client</param>
        /// <param name="model">The model for the given media range</param>
        /// <param name="context">The nancy context</param>
        /// <returns>A ProcessorMatch result that determines the priority of the processor</returns>
        public ProcessorMatch CanProcess(MediaRange requestedMediaRange, dynamic model, NancyContext context)
        {
            if (IsExactJsonContentType(requestedMediaRange))
            {
                return new ProcessorMatch
                {
                    ModelResult = MatchResult.DontCare,
                    RequestedContentTypeResult = MatchResult.ExactMatch
                };
            }

            if (IsWildcardJsonContentType(requestedMediaRange))
            {
                return new ProcessorMatch
                {
                    ModelResult = MatchResult.DontCare,
                    RequestedContentTypeResult = MatchResult.NonExactMatch
                };
            }

            return new ProcessorMatch
            {
                ModelResult = MatchResult.DontCare,
                RequestedContentTypeResult = MatchResult.NoMatch
            };
        }

        /// <summary>
        /// Process the response
        /// </summary>
        /// <param name="requestedMediaRange">Content type requested by the client</param>
        /// <param name="model">The model for the given media range</param>
        /// <param name="context">The nancy context</param>
        /// <returns>A response</returns>
        public Response Process(MediaRange requestedMediaRange, dynamic model, NancyContext context)
        {
            return new JsonResponse(model, this.serializer, this.environment);
        }

        private static bool IsExactJsonContentType(MediaRange requestedContentType)
        {
            if (requestedContentType.Type.IsWildcard && requestedContentType.Subtype.IsWildcard)
            {
                return true;
            }

            return requestedContentType.Matches("application/json") || requestedContentType.Matches("text/json");
        }

        private static bool IsWildcardJsonContentType(MediaRange requestedContentType)
        {
            if (!requestedContentType.Type.IsWildcard && !string.Equals("application", requestedContentType.Type, StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }

            if (requestedContentType.Subtype.IsWildcard)
            {
                return true;
            }

            var subtypeString = requestedContentType.Subtype.ToString();

            return (subtypeString.StartsWith("vnd", StringComparison.OrdinalIgnoreCase) &&
                    subtypeString.EndsWith("+json", StringComparison.OrdinalIgnoreCase));
        }
    }
}
namespace Nancy.Responses.Negotiation
{
    /// <summary>
    /// Represents whether a processor has matched/can handle processing the response.
    /// Values are of increasing priority.
    /// </summary>
    public enum MatchResult
    {
        /// <summary>
        /// No match, nothing to see here, move along
        /// </summary>
        NoMatch,

        /// <summary>
        /// Will accept anything
        /// </summary>
        DontCare,

        /// <summary>
        /// Matched, but in a non-specific way such as a wildcard match or fallback
        /// </summary>
        NonExactMatch,

        /// <summary>
        /// Exact specific match
        /// </summary>
        ExactMatch
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;
    using System.Linq;

    /// <summary>
    /// Represents a media range from an accept header
    /// </summary>
    public class MediaRange
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MediaRange"/> class from a string representation of a media range
        /// </summary>
        /// <param name="contentType">the content type</param>
        public MediaRange(string contentType) : this()
        {
            if (string.IsNullOrEmpty(contentType))
            {
                throw new ArgumentException("inputString cannot be null or empty", contentType);
            }

            if (contentType.Equals("*"))
            {
                contentType = "*/*";
            }

            var parts = contentType.Split('/', ';');

            if (parts.Length < 2)
            {
                {
                    throw new ArgumentException("inputString not in correct Type/SubType format", contentType);
                }
            }

            this.Type = parts[0];
            this.Subtype = parts[1].TrimEnd();

            if (parts.Length > 2)
            {
                var separator = contentType.IndexOf(';');
                this.Parameters = MediaRangeParameters.FromString(contentType.Substring(separator));
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MediaRange"/> class.
        /// </summary>
        public MediaRange()
        {
            this.Parameters = new MediaRangeParameters();
        }

        /// <summary>
        /// Media range type
        /// </summary>
        public MediaType Type { get; private set; }

        /// <summary>
        /// Media range subtype
        /// </summary>
        public MediaType Subtype { get; private set; }

        /// <summary>
        /// Media range parameters
        /// </summary>
        public MediaRangeParameters Parameters { get; private set; }

        /// <summary>
        /// Gets a value indicating if the media range is the */* wildcard
        /// </summary>
        public bool IsWildcard
        {
            get
            {
                return this.Type.IsWildcard && this.Subtype.IsWildcard;
            }
        }

        /// <summary>
        /// Whether or not a media range matches another, taking into account wildcards
        /// </summary>
        /// <param name="other">Other media range</param>
        /// <returns>True if matching, false if not</returns>
        public bool Matches(MediaRange other)
        {
            return this.Type.Matches(other.Type) && this.Subtype.Matches(other.Subtype);
        }

        /// <summary>
        /// Whether or not a media range matches another, taking into account wildcards and parameters
        /// </summary>
        /// <param name="other">Other media range</param>
        /// <returns>True if matching, false if not</returns>
        public bool MatchesWithParameters(MediaRange other)
        {
            return this.Matches(other) && this.Parameters.Matches(other.Parameters);
        }

        public static implicit operator MediaRange(string contentType)
        {
            return new MediaRange(contentType);
        }

        public static implicit operator string(MediaRange mediaRange)
        {
            if (mediaRange.Parameters.Any())
            {
                return string.Format("{0}/{1};{2}", mediaRange.Type, mediaRange.Subtype, mediaRange.Parameters);
            }

            return string.Format("{0}/{1}", mediaRange.Type, mediaRange.Subtype);
        }

        public override string ToString()
        {
            return this;
        }
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Provides strongly-typed access to media range parameters.
    /// </summary>
    public class MediaRangeParameters : IEnumerable<KeyValuePair<string, string>>
    {
        private readonly IDictionary<string, string> parameters;

        /// <summary>
        /// Initializes a new instance of the <see cref="MediaRangeParameters"/> class.
        /// </summary>
        public MediaRangeParameters()
        {
            this.parameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MediaRangeParameters"/> class.
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        public MediaRangeParameters(IDictionary<string, string> parameters)
        {
            this.parameters = new Dictionary<string, string>(parameters, StringComparer.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Gets the names of the available parameters.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> containing the names of the parameters.</value>
        public IEnumerable<string> Keys
        {
            get { return this.parameters.Keys; }
        }

        /// <summary>
        /// Gets all the parameters values.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains all the parameters values.</value>
        public IEnumerable<string> Values
        {
            get { return this.parameters.Values; }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>A <see cref="IEnumerator{T}"/> that can be used to iterate through the collection.</returns>
        public IEnumerator<KeyValuePair<string, string>> GetEnumerator()
        {
            return this.parameters.GetEnumerator();
        }

        /// <summary>
        /// Whether or not a set of media range parameters matches another, regardless of order
        /// </summary>
        /// <param name="other">Other media range parameters</param>
        /// <returns>True if matching, false if not</returns>
        public bool Matches(MediaRangeParameters other)
        {
            return this.parameters.OrderBy(p => p.Key).SequenceEqual(other.parameters.OrderBy(p => p.Key));
        }

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        /// <summary>
        /// Gets the value for the parameter identified by the <paramref name="name"/> parameter.
        /// </summary>
        /// <param name="name">The name of the parameter to return the value for.</param>
        /// <returns>The value for the parameter. If the parameter is not defined then null is returned.</returns>
        public string this[string name]
        {
            get
            {
                return (this.parameters.ContainsKey(name)) ? this.parameters[name] : null;
            }
        }

        public static implicit operator string(MediaRangeParameters mediaRangeParameters)
        {
            return string.Join(";", mediaRangeParameters.parameters.Select(p => p.Key + "=" + p.Value));
        }

        /// <summary>
        /// Creates a MediaRangeParameters collection from a "a=1,b=2" string
        /// </summary>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public static MediaRangeParameters FromString(string parameters)
        {
            var dictionary = parameters.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries)
               .Select(part => part.Split('='))
               .ToDictionary(split => split[0].Trim(), split => split[1].Trim());

            return new MediaRangeParameters(dictionary);
        }

        public override string ToString()
        {
            return this;
        }
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;

    /// <summary>
    /// Represents a media type or subtype in a <see cref="MediaRange"/>.
    /// </summary>
    public class MediaType
    {
        private readonly string type;

        /// <summary>
        /// Initializes a new instance of the <see cref="MediaType"/> class for the media type part.
        /// </summary>
        /// <param name="type"></param>
        public MediaType(string type)
        {
            this.type = type;
        }

        /// <summary>
        /// Gets a value indicating whether the media type is a wildcard or not
        /// </summary>
        /// <value><see langword="true" /> if the media type is a wildcard, otherwise <see langword="false" />.</value>
        public bool IsWildcard
        {
            get
            {
                return this.type != null && string.Equals(this.type, "*", StringComparison.Ordinal);
            }
        }

        /// <summary>
        /// Matched the media type with another media type.
        /// </summary>
        /// <param name="other">The media type that should be matched against.</param>
        /// <returns><see langword="true" /> if the media types match, otherwise <see langword="false" />.</returns>
        public bool Matches(MediaType other)
        {
            return this.IsWildcard ||
                   other.IsWildcard ||
                   this.type.Equals(other.type, StringComparison.OrdinalIgnoreCase);
        }

        public static implicit operator MediaType(string inputString)
        {
            return new MediaType(inputString);
        }

        public static implicit operator string(MediaType inputMediaType)
        {
            return inputMediaType.type;
        }

        public override string ToString()
        {
            return this.type;
        }
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    using Nancy.Cookies;

    using Nancy.Extensions;

    /// <summary>
    /// Context for content negotiation.
    /// </summary>
    public class NegotiationContext
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NegotiationContext"/> class.
        /// </summary>
        public NegotiationContext()
        {
            this.Cookies = new List<INancyCookie>();
            this.PermissableMediaRanges = new List<MediaRange>(new[] { (MediaRange)"*/*" });
            this.MediaRangeModelMappings = new Dictionary<MediaRange, Func<dynamic>>();
            this.Headers = new Dictionary<string, string>();
        }

        /// <summary>
        /// Gets or sets additional cookies to assign to the response.
        /// </summary>
        /// <value>An <see cref="IList{T}"/> of <see cref="INancyCookie"/> instances.</value>
        public IList<INancyCookie> Cookies { get; set; }

        /// <summary>
        /// Gets or sets the default model that will be used if a content type specific model is not specified.
        /// </summary>
        /// <value>The default model instance.</value>
        public dynamic DefaultModel { get; set; }

        /// <summary>
        /// Gets or sets the additional response headers required.
        /// </summary>
        /// <value>An <see cref="IDictionary{TKey,TValue}"/> containing the headers.</value>
        public IDictionary<string, string> Headers { get; set; }

        /// <summary>
        /// Gets or sets the model mappings for media ranges.
        /// </summary>
        /// <value>An <see cref="IDictionary{TKey,TValue}"/> containing the media range model mappings.</value>
        public IDictionary<MediaRange, Func<dynamic>> MediaRangeModelMappings { get; set; }

        /// <summary>
        /// The name of the <see cref="INancyModule"/> that is locating a view.
        /// </summary>
        /// <value>A <see cref="string"/> containing the name of the module.</value>
        public string ModuleName { get; set; }

        /// <summary>
        /// The module path of the <see cref="INancyModule"/> that is locating a view.
        /// </summary>
        /// <value>A <see cref="string"/> containing the module path.</value>
        public string ModulePath { get; set; }

        /// <summary>
        /// Gets or sets allowed media ranges.
        /// </summary>
        /// <value>A list of the allowed media ranges.</value>
        public IList<MediaRange> PermissableMediaRanges { get; set; }

        /// <summary>
        /// Gets or sets the status code of the response.
        /// </summary>
        /// <value>A <see cref="HttpStatusCode"/> value.</value>
        public HttpStatusCode? StatusCode { get; set; }

        /// <summary>
        /// Gets or sets a text description of the HTTP status code returned to the client.
        /// </summary>
        /// <value>The HTTP status code description.</value>
        public string ReasonPhrase { get; set; }

        /// <summary>
        /// Gets or sets the view name if one is required.
        /// </summary>
        /// <value>The name of the view that should be rendered.</value>
        public string ViewName { get; set; }

        /// <summary>
        /// Gets the correct model for the given media range
        /// </summary>
        /// <param name="mediaRange">The <see cref="MediaRange"/> to get the model for.</param>
        /// <returns>The model for the provided <paramref name="mediaRange"/> if it has been mapped, otherwise the <see cref="DefaultModel"/> will be returned.</returns>
        public dynamic GetModelForMediaRange(MediaRange mediaRange)
        {
            var matching = this.MediaRangeModelMappings.Any(m => mediaRange.Matches(m.Key));

            return matching ?
                this.MediaRangeModelMappings.First(m => mediaRange.Matches(m.Key)).Value.Invoke() :
                this.DefaultModel;
        }

        public void SetModule(INancyModule module)
        {
            if (module == null)
            {
                throw new ArgumentNullException("module");
            }

            this.ModuleName = module.GetModuleName();
            this.ModulePath = module.ModulePath;
        }
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;

    public class Negotiator : IHideObjectMembers
    {
        // TODO - this perhaps should be an interface, along with the view thing above
        // that would then wrap this to give more granular extension point for things like
        // AsNegotiated

        /// <summary>
        /// Initializes a new instance of the <see cref="Negotiator"/> class,
        /// with the provided <paramref name="context"/>.
        /// </summary>
        /// <param name="context">The context that should be negotiated.</param>
        public Negotiator(NancyContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            this.NegotiationContext = context.NegotiationContext;
        }

        /// <summary>
        /// Gets the <see cref="NegotiationContext"/> used by the negotiator.
        /// </summary>
        /// <value>A <see cref="NegotiationContext"/> instance.</value>
        public NegotiationContext NegotiationContext { get; private set; }
    }
}
namespace Nancy.Responses.Negotiation
{
    /// <summary>
    /// Represents whether a processor has matched / can handle a requested response
    /// </summary>
    public class ProcessorMatch
    {
        /// <summary>
        /// A <see cref="ProcessorMatch"/> with both <see cref="ModelResult"/> and <see cref="RequestedContentTypeResult"/> set to <see cref="MatchResult.NoMatch"/>.
        /// </summary>
        public static ProcessorMatch None = new ProcessorMatch
        {
            ModelResult = MatchResult.NoMatch,
            RequestedContentTypeResult = MatchResult.NoMatch
        };

        /// <summary>
        /// Gets or sets the match result based on the content type
        /// </summary>
        public MatchResult RequestedContentTypeResult { get; set; }

        /// <summary>
        /// Gets or sets the match result based on the model
        /// </summary>
        public MatchResult ModelResult { get; set; }
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Processes negotiated responses of model type <see cref="Response"/>.
    /// </summary>
    public class ResponseProcessor : IResponseProcessor
    {
        /// <summary>
        /// Gets a set of mappings that map a given extension (such as .json)
        /// to a media range that can be sent to the client in a vary header.
        /// </summary>
        public IEnumerable<Tuple<string, MediaRange>> ExtensionMappings
        {
            get
            {
                return Enumerable.Empty<Tuple<string, MediaRange>>();
            }
        }

        /// <summary>
        /// Determines whether the processor can handle a given content type and model.
        /// </summary>
        /// <param name="requestedMediaRange">Content type requested by the client.</param>
        /// <param name="model">The model for the given media range.</param>
        /// <param name="context">The nancy context.</param>
        /// <returns>A <see cref="ProcessorMatch"/> result that determines the priority of the processor.</returns>
        public ProcessorMatch CanProcess(MediaRange requestedMediaRange, dynamic model, NancyContext context)
        {
            return new ProcessorMatch
            {
                ModelResult = (model is Response) ? MatchResult.ExactMatch : MatchResult.NoMatch,
                RequestedContentTypeResult = MatchResult.DontCare
            };
        }

        /// <summary>
        /// Process the response.
        /// </summary>
        /// <param name="requestedMediaRange">Content type requested by the client.</param>
        /// <param name="model">The model for the given media range.</param>
        /// <param name="context">The nancy context.</param>
        /// <returns>A <see cref="Response"/> instance.</returns>
        public Response Process(MediaRange requestedMediaRange, dynamic model, NancyContext context)
        {
            return (Response)model;
        }
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;
    using System.Collections.Generic;
    using Nancy.Configuration;
    using Nancy.ViewEngines;

    /// <summary>
    /// Processes the model for view requests.
    /// </summary>
    public class ViewProcessor : IResponseProcessor
    {
        private readonly IViewFactory viewFactory;
        private readonly TraceConfiguration traceConfiguration;

        /// <summary>
        /// Initializes a new instance of the <see cref="ViewProcessor"/> class,
        /// with the provided <paramref name="viewFactory"/>.
        /// </summary>
        /// <param name="viewFactory">The view factory that should be used to render views.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public ViewProcessor(IViewFactory viewFactory, INancyEnvironment environment)
        {
            this.viewFactory = viewFactory;
            this.traceConfiguration = environment.GetValue<TraceConfiguration>();
        }

        /// <summary>
        /// Gets a set of mappings that map a given extension (such as .json)
        /// to a media range that can be sent to the client in a vary header.
        /// </summary>
        public IEnumerable<Tuple<string, MediaRange>> ExtensionMappings
        {
            get { yield break; }
        }

        /// <summary>
        /// Determines whether the processor can handle a given content type and model.
        /// </summary>
        /// <param name="requestedMediaRange">Content type requested by the client.</param>
        /// <param name="model">The model for the given media range.</param>
        /// <param name="context">The nancy context.</param>
        /// <returns>A <see cref="ProcessorMatch"/> result that determines the priority of the processor.</returns>
        public ProcessorMatch CanProcess(MediaRange requestedMediaRange, dynamic model, NancyContext context)
        {
            var matchingContentType =
                requestedMediaRange.Matches("text/html");

            return matchingContentType
                ? new ProcessorMatch { ModelResult = MatchResult.DontCare, RequestedContentTypeResult = MatchResult.ExactMatch }
                : new ProcessorMatch();
        }

        /// <summary>
        /// Process the response.
        /// </summary>
        /// <param name="requestedMediaRange">Content type requested by the client.</param>
        /// <param name="model">The model for the given media range.</param>
        /// <param name="context">The nancy context.</param>
        /// <returns>A <see cref="Response"/> instance.</returns>
        public Response Process(MediaRange requestedMediaRange, dynamic model, NancyContext context)
        {
            var viewResponse = this.viewFactory.RenderView(context.NegotiationContext.ViewName, model, GetViewLocationContext(context));

            return this.traceConfiguration.DisplayErrorTraces
                ? new MaterialisingResponse(viewResponse)
                : viewResponse;
        }

        private static ViewLocationContext GetViewLocationContext(NancyContext context)
        {
            return new ViewLocationContext
            {
                Context = context,
                ModuleName = context.NegotiationContext.ModuleName,
                ModulePath = context.NegotiationContext.ModulePath
            };
        }
    }
}
namespace Nancy.Responses.Negotiation
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Processes the model for xml media types and extension.
    /// </summary>
    public class XmlProcessor : IResponseProcessor
    {
        private readonly ISerializer serializer;

        private static readonly IEnumerable<Tuple<string, MediaRange>> extensionMappings =
            new[] { new Tuple<string, MediaRange>("xml", new MediaRange("application/xml")) };

        /// <summary>
        /// Initializes a new instance of the <see cref="XmlProcessor"/> class,
        /// with the provided <see paramref="serializers"/>.
        /// </summary>
        /// <param name="serializers">The serializes that the processor will use to process the request.</param>
        public XmlProcessor(IEnumerable<ISerializer> serializers)
        {
            this.serializer = serializers.FirstOrDefault(x => x.CanSerialize("application/xml"));
        }

        /// <summary>
        /// Gets a set of mappings that map a given extension (such as .json)
        /// to a media range that can be sent to the client in a vary header.
        /// </summary>
        public IEnumerable<Tuple<string, MediaRange>> ExtensionMappings
        {
            get { return extensionMappings; }
        }

        /// <summary>
        /// Determines whether the processor can handle a given content type and model.
        /// </summary>
        /// <param name="requestedMediaRange">Content type requested by the client.</param>
        /// <param name="model">The model for the given media range.</param>
        /// <param name="context">The nancy context.</param>
        /// <returns>A <see cref="ProcessorMatch"/> result that determines the priority of the processor.</returns>
        public ProcessorMatch CanProcess(MediaRange requestedMediaRange, dynamic model, NancyContext context)
        {
            if (IsExactXmlContentType(requestedMediaRange))
            {
                return new ProcessorMatch
                {
                    ModelResult = MatchResult.DontCare,
                    RequestedContentTypeResult = MatchResult.ExactMatch
                };
            }

            if (IsWildcardXmlContentType(requestedMediaRange))
            {
                return new ProcessorMatch
                {
                    ModelResult = MatchResult.DontCare,
                    RequestedContentTypeResult = MatchResult.NonExactMatch
                };
            }

            return new ProcessorMatch
            {
                ModelResult = MatchResult.DontCare,
                RequestedContentTypeResult = MatchResult.NoMatch
            };
        }

        /// <summary>
        /// Process the response.
        /// </summary>
        /// <param name="requestedMediaRange">Content type requested by the client.</param>
        /// <param name="model">The model for the given media range.</param>
        /// <param name="context">The nancy context.</param>
        /// <returns>A <see cref="Response"/> instance.</returns>
        public Response Process(MediaRange requestedMediaRange, dynamic model, NancyContext context)
        {
            return CreateResponse(model, serializer);
        }

        private static Response CreateResponse(dynamic model, ISerializer serializer)
        {
            return new Response
            {
                Contents = stream =>
                {
                    if (model != null)
                    {
                        serializer.Serialize("application/xml", model, stream);
                    }
                },
                ContentType = "application/xml",
                StatusCode = HttpStatusCode.OK
            };
        }

        private static bool IsExactXmlContentType(MediaRange requestedContentType)
        {
            if (requestedContentType.Type.IsWildcard && requestedContentType.Subtype.IsWildcard)
            {
                return true;
            }

            return requestedContentType.Matches("application/xml") || requestedContentType.Matches("text/xml");
        }

        private static bool IsWildcardXmlContentType(MediaRange requestedContentType)
        {
            if (!requestedContentType.Type.IsWildcard && !string.Equals("application", requestedContentType.Type, StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }

            if (requestedContentType.Subtype.IsWildcard)
            {
                return true;
            }

            var subtypeString = requestedContentType.Subtype.ToString();

            return (subtypeString.StartsWith("vnd", StringComparison.OrdinalIgnoreCase) &&
                    subtypeString.EndsWith("+xml", StringComparison.OrdinalIgnoreCase));
        }
    }
}
namespace Nancy.Responses
{
    /// <summary>
    /// Response with status code 406 (Not Acceptable).
    /// </summary>
    public class NotAcceptableResponse : Response
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NotAcceptableResponse"/> class.
        /// </summary>
        public NotAcceptableResponse()
        {
            this.StatusCode = HttpStatusCode.NotAcceptable;
        }
    }
}
namespace Nancy.Responses
{
    using System;
    using System.IO;

    /// <summary>
    /// Response that returns the contents of a stream of a given content-type.
    /// </summary>
    public class StreamResponse : Response
    {
        private Stream source;

        /// <summary>
        /// Initializes a new instance of the <see cref="StreamResponse"/> class with the
        /// provided stream provider and content-type.
        /// </summary>
        /// <param name="source">The value producer for the response.</param>
        /// <param name="contentType">The content-type of the stream contents.</param>
        public StreamResponse(Func<Stream> source, string contentType)
        {
            this.Contents = GetResponseBodyDelegate(source);
            this.ContentType = contentType;
            this.StatusCode = HttpStatusCode.OK;
        }

        private Action<Stream> GetResponseBodyDelegate(Func<Stream> sourceDelegate)
        {
            return stream =>
            {
                using (this.source = sourceDelegate.Invoke())
                {
                    this.source.CopyTo(stream);
                }
            };
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public override void Dispose()
        {
            if (this.source != null)
            {
                this.source.Dispose();
            }
        }
    }
}
namespace Nancy.IO
{
    using System;
    using System.IO;

    /// <summary>
    /// To close the unclosable stream..
    /// To fight the unbeatable foe..
    /// To bear with unbearable sorrow..
    /// To run where the brave dare not go..
    /// </summary>
    public class UnclosableStreamWrapper : Stream, IDisposable
    {
        /// <summary>
        /// The wrapped stream
        /// </summary>
        private readonly Stream baseStream;

        /// <summary>
        /// Initializes a new instance of the <see cref="UnclosableStreamWrapper"/> class.
        /// </summary>
        /// <param name="baseStream">The base stream to wrap.</param>
        public UnclosableStreamWrapper(Stream baseStream)
        {
            if (baseStream == null)
            {
                throw new ArgumentNullException("baseStream");
            }

            this.baseStream = baseStream;
        }

        /// <summary>
        /// Gets the base stream that the wrapper is wrapping
        /// </summary>
        public Stream BaseStream
        {
            get
            {
                return this.baseStream;
            }
        }

        /// <summary>
        /// When overridden in a derived class, gets a value indicating whether the current stream supports reading.
        /// </summary>
        /// <returns>
        /// true if the stream supports reading; otherwise, false.
        /// </returns>
        /// <filterpriority>1</filterpriority>
        public override bool CanRead
        {
            get
            {
                return this.baseStream.CanRead;
            }
        }

        /// <summary>
        /// When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
        /// </summary>
        /// <returns>
        /// true if the stream supports seeking; otherwise, false.
        /// </returns>
        /// <filterpriority>1</filterpriority>
        public override bool CanSeek
        {
            get
            {
                return this.baseStream.CanSeek;
            }
        }

        /// <summary>
        /// When overridden in a derived class, gets a value indicating whether the current stream supports writing.
        /// </summary>
        /// <returns>
        /// true if the stream supports writing; otherwise, false.
        /// </returns>
        /// <filterpriority>1</filterpriority>
        public override bool CanWrite
        {
            get
            {
                return this.baseStream.CanWrite;
            }
        }

        /// <summary>
        /// When overridden in a derived class, gets the length in bytes of the stream.
        /// </summary>
        /// <returns>
        /// A long value representing the length of the stream in bytes.
        /// </returns>
        /// <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        public override long Length
        {
            get
            {
                return this.baseStream.Length;
            }
        }

        /// <summary>
        /// When overridden in a derived class, gets or sets the position within the current stream.
        /// </summary>
        /// <returns>
        /// The current position within the stream.
        /// </returns>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        public override long Position
        {
            get
            {
                return this.baseStream.Position;
            }

            set
            {
                this.baseStream.Position = value;
            }
        }

        /// <summary>
        /// Gets a value that determines whether the current stream can time out.
        /// </summary>
        /// <returns>
        /// A value that determines whether the current stream can time out.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        public override bool CanTimeout
        {
            get
            {
                return this.baseStream.CanTimeout;
            }
        }

        /// <summary>
        /// Gets or sets a value, in milliseconds, that determines how long the stream will attempt to read before timing out. 
        /// </summary>
        /// <returns>
        /// A value, in milliseconds, that determines how long the stream will attempt to read before timing out.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">The <see cref="P:System.IO.Stream.ReadTimeout"/> method always throws an <see cref="T:System.InvalidOperationException"/>. </exception><filterpriority>2</filterpriority>
        public override int ReadTimeout
        {
            get
            {
                return this.baseStream.ReadTimeout;
            }

            set
            {
                this.baseStream.ReadTimeout = value;
            }
        }

        /// <summary>
        /// Gets or sets a value, in milliseconds, that determines how long the stream will attempt to write before timing out. 
        /// </summary>
        /// <returns>
        /// A value, in milliseconds, that determines how long the stream will attempt to write before timing out.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">The <see cref="P:System.IO.Stream.WriteTimeout"/> method always throws an <see cref="T:System.InvalidOperationException"/>. </exception><filterpriority>2</filterpriority>
        public override int WriteTimeout
        {
            get
            {
                return this.baseStream.WriteTimeout;
            }

            set
            {
                this.baseStream.WriteTimeout = value;
            }
        }

        /// <summary>
        /// Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.
        /// </summary>
        /// <filterpriority>1</filterpriority>
        public override void Close()
        {
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        /// <filterpriority>2</filterpriority>
        public new void Dispose()
        {
        }

        /// <summary>
        /// When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
        /// </summary>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>2</filterpriority>
        public override void Flush()
        {
            this.baseStream.Flush();
        }

        /// <summary>
        /// When overridden in a derived class, sets the position within the current stream.
        /// </summary>
        /// <returns>
        /// The new position within the current stream.
        /// </returns>
        /// <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter. </param><param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this.baseStream.Seek(offset, origin);
        }

        /// <summary>
        /// When overridden in a derived class, sets the length of the current stream.
        /// </summary>
        /// <param name="value">The desired length of the current stream in bytes. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        public override void SetLength(long value)
        {
            this.baseStream.SetLength(value);
        }

        /// <summary>
        /// When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
        /// </summary>
        /// <returns>
        /// The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
        /// </returns>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source. </param><param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream. </param><param name="count">The maximum number of bytes to be read from the current stream. </param><exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length. </exception><exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative. </exception><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support reading. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        public override int Read(byte[] buffer, int offset, int count)
        {
            return this.baseStream.Read(buffer, offset, count);
        }

        /// <summary>
        /// When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream. </param><param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream. </param><param name="count">The number of bytes to be written to the current stream. </param><exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is greater than the buffer length. </exception><exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative. </exception><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support writing. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        public override void Write(byte[] buffer, int offset, int count)
        {
            this.baseStream.Write(buffer, offset, count);
        }

        /// <summary>
        /// Begins an asynchronous read operation.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.IAsyncResult"/> that represents the asynchronous read, which could still be pending.
        /// </returns>
        /// <param name="buffer">The buffer to read the data into. </param><param name="offset">The byte offset in <paramref name="buffer"/> at which to begin writing data read from the stream. </param><param name="count">The maximum number of bytes to read. </param><param name="callback">An optional asynchronous callback, to be called when the read is complete. </param><param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests. </param><exception cref="T:System.IO.IOException">Attempted an asynchronous read past the end of the stream, or a disk error occurs. </exception><exception cref="T:System.ArgumentException">One or more of the arguments is invalid. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><exception cref="T:System.NotSupportedException">The current Stream implementation does not support the read operation. </exception><filterpriority>2</filterpriority>
        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return this.baseStream.BeginRead(buffer, offset, count, callback, state);
        }

        /// <summary>
        /// Begins an asynchronous write operation.
        /// </summary>
        /// <returns>
        /// An IAsyncResult that represents the asynchronous write, which could still be pending.
        /// </returns>
        /// <param name="buffer">The buffer to write data from. </param><param name="offset">The byte offset in <paramref name="buffer"/> from which to begin writing. </param><param name="count">The maximum number of bytes to write. </param><param name="callback">An optional asynchronous callback, to be called when the write is complete. </param><param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests. </param><exception cref="T:System.IO.IOException">Attempted an asynchronous write past the end of the stream, or a disk error occurs. </exception><exception cref="T:System.ArgumentException">One or more of the arguments is invalid. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><exception cref="T:System.NotSupportedException">The current Stream implementation does not support the write operation. </exception><filterpriority>2</filterpriority>
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return this.baseStream.BeginWrite(buffer, offset, count, callback, state);
        }

        /// <summary>
        /// Waits for the pending asynchronous read to complete.
        /// </summary>
        /// <returns>
        /// The number of bytes read from the stream, between zero (0) and the number of bytes you requested. Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.
        /// </returns>
        /// <param name="asyncResult">The reference to the pending asynchronous request to finish. </param><exception cref="T:System.ArgumentNullException"><paramref name="asyncResult"/> is null. </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult"/> did not originate from a <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"/> method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception><filterpriority>2</filterpriority>
        public override int EndRead(IAsyncResult asyncResult)
        {
            return this.baseStream.EndRead(asyncResult);
        }

        /// <summary>
        /// Ends an asynchronous write operation.
        /// </summary>
        /// <param name="asyncResult">A reference to the outstanding asynchronous I/O request. </param><exception cref="T:System.ArgumentNullException"><paramref name="asyncResult"/> is null. </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult"/> did not originate from a <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"/> method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception><filterpriority>2</filterpriority>
        public override void EndWrite(IAsyncResult asyncResult)
        {
            this.baseStream.EndWrite(asyncResult);
        }

        /// <summary>
        /// Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
        /// </summary>
        /// <returns>
        /// The unsigned byte cast to an Int32, or -1 if at the end of the stream.
        /// </returns>
        /// <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        public override int ReadByte()
        {
            return this.baseStream.ReadByte();
        }

        /// <summary>
        /// Writes a byte to the current position in the stream and advances the position within the stream by one byte.
        /// </summary>
        /// <param name="value">The byte to write to the stream. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support writing, or the stream is already closed. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        public override void WriteByte(byte value)
        {
            this.baseStream.WriteByte(value);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the <see cref="T:System.IO.Stream"/> and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected override void Dispose(bool disposing)
        {
        }
    }
}
namespace Nancy
{
    using System.Collections.Generic;
    using System.IO;
    using Nancy.Responses.Negotiation;

    /// <summary>
    /// Defines the functionality for providing serialization support.
    /// </summary>
    public interface ISerializer
    {
        /// <summary>
        /// Whether the serializer can serialize the content type
        /// </summary>
        /// <param name="mediaRange">Content type to serialise</param>
        /// <returns>True if supported, false otherwise</returns>
        bool CanSerialize(MediaRange mediaRange);

        /// <summary>
        /// Gets the list of extensions that the serializer can handle.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> of extensions if any are available, otherwise an empty enumerable.</value>
        IEnumerable<string> Extensions { get; }

        /// <summary>
        /// Serialize the given model with the given contentType
        /// </summary>
        /// <param name="mediaRange">Content type to serialize into</param>
        /// <param name="model">Model to serialize</param>
        /// <param name="outputStream">Output stream to serialize to</param>
        /// <returns>Serialised object</returns>
        void Serialize<TModel>(MediaRange mediaRange, TModel model, Stream outputStream);
    }
}
namespace Nancy.Json.Converters
{
    using System;
    using System.Collections.Generic;

    public class TimeSpanConverter : JavaScriptConverter
    {
        public override IEnumerable<Type> SupportedTypes
        {
            get
            {
                return new[] { typeof(TimeSpan) };
            }
        }

        public override object Deserialize(IDictionary<string, object> dictionary, Type type, JavaScriptSerializer serializer)
        {
            return new TimeSpan(
                this.GetValue(dictionary, "Days"),
                this.GetValue(dictionary, "Hours"),
                this.GetValue(dictionary, "Minutes"),
                this.GetValue(dictionary, "Seconds"),
                this.GetValue(dictionary, "Milliseconds"));
        }

        public override IDictionary<string, object> Serialize(object obj, JavaScriptSerializer serializer)
        {
            var timeSpan = (TimeSpan)obj;

            var result = new Dictionary<string, object>
                             {
                                 { "Days", timeSpan.Days },
                                 { "Hours", timeSpan.Hours },
                                 { "Minutes", timeSpan.Minutes },
                                 { "Seconds", timeSpan.Seconds },
                                 { "Milliseconds", timeSpan.Milliseconds }
                             };

            return result;
        }

        private int GetValue(IDictionary<string, object> dictionary, string key)
        {
            const int DefaultValue = 0;

            object value;
            if (!dictionary.TryGetValue(key, out value))
            {
                return DefaultValue;
            }

            if (value is int)
            {
                return (int)value;
            }

            if (value is long)
            {
                return Convert.ToInt32((long)value);
            }

            var valueString = value as string;
            if (valueString == null)
            {
                return DefaultValue;
            }

            int returnValue;
            return !int.TryParse(valueString, out returnValue) ? DefaultValue : returnValue;
        }
    }
}
namespace Nancy.Json
{
    using System.Collections.Generic;
    using System.Text;
    using Nancy.Json.Converters;

    /// <summary>
    /// Configuration for JSON serialization.
    /// </summary>
    public class JsonConfiguration
    {
        /// <summary>
        /// A default instance of the <see cref="JsonConfiguration"/> class.
        /// </summary>
        public static readonly JsonConfiguration Default = new JsonConfiguration
        {
            Converters = new List<JavaScriptConverter> { new TimeSpanConverter(), new TupleConverter() },
            DefaultEncoding = Encoding.UTF8,
            PrimitiveConverters = new List<JavaScriptPrimitiveConverter>(),
            RetainCasing = false
        };

        private JsonConfiguration()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="JsonConfiguration"/> class.
        /// </summary>
        /// <param name="defaultEncoding">The default <see cref="Encoding"/> that should be used by the serializer.</param>
        /// <param name="converters">List of <see cref="JavaScriptConverter"/> instances.</param>
        /// <param name="primitiveConverters">List of <see cref="JavaScriptPrimitiveConverter"/> instances.</param>
        /// <param name="retainCasing"><see langword="true"/> if the name casing should be retained during serialization, otherwise <see langword="false"/>.</param>
        public JsonConfiguration(Encoding defaultEncoding, IList<JavaScriptConverter> converters, IList<JavaScriptPrimitiveConverter> primitiveConverters, bool? retainCasing)
        {
            this.DefaultEncoding = defaultEncoding ?? Default.DefaultEncoding;
            this.Converters = converters ?? Default.Converters;
            this.PrimitiveConverters = primitiveConverters ?? Default.PrimitiveConverters;
            this.RetainCasing = retainCasing ?? Default.RetainCasing;
        }

        /// <summary>
        /// Gets the default <see cref="Encoding"/> for JSON responses.
        /// </summary>
        /// <remarks>The default is <see langword="Encoding.UTF8" />.</remarks>
        public Encoding DefaultEncoding { get; private set; }

        /// <summary>
        /// Gets or sets the type converters that should be used.
        /// </summary>
        /// <remarks>The default is <see cref="TimeSpanConverter"/> and <see cref="TupleConverter"/>.</remarks>
        public IList<JavaScriptConverter> Converters { get; private set; }

        /// <summary>
        /// Gets or sets the converters used for primitive types.
        /// </summary>
        /// <remarks>The default are no converters.</remarks>
        public IList<JavaScriptPrimitiveConverter> PrimitiveConverters { get; private set; }

        /// <summary>
        /// Gets or sets if C# casing should be retained or if camel-casing should be enforeced.
        /// </summary>
        /// <remarks>The default is <see langword="false"/>.</remarks>
        public bool RetainCasing { get; private set; }
    }
}
namespace Nancy.Responses
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using Nancy.Configuration;
    using Nancy.IO;
    using Nancy.Json;
    using Nancy.Responses.Negotiation;

    /// <summary>
    /// Default <see cref="ISerializer"/> implementation for JSON serialization.
    /// </summary>
    public class DefaultJsonSerializer : ISerializer
    {
        private readonly JsonConfiguration jsonConfiguration;
        private readonly TraceConfiguration traceConfiguration;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultJsonSerializer"/> class,
        /// with the provided <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public DefaultJsonSerializer(INancyEnvironment environment)
        {
            this.jsonConfiguration = environment.GetValue<JsonConfiguration>();
            this.traceConfiguration = environment.GetValue<TraceConfiguration>();
        }

        /// <summary>
        /// Whether the serializer can serialize the content type
        /// </summary>
        /// <param name="mediaRange">Content type to serialise</param>
        /// <returns>True if supported, false otherwise</returns>
        public bool CanSerialize(MediaRange mediaRange)
        {
            return IsJsonType(mediaRange);
        }

        /// <summary>
        /// Gets the list of extensions that the serializer can handle.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> of extensions if any are available, otherwise an empty enumerable.</value>
        public IEnumerable<string> Extensions
        {
            get { yield return "json"; }
        }

        /// <summary>
        /// Serialize the given model with the given contentType
        /// </summary>
        /// <param name="mediaRange">Content type to serialize into</param>
        /// <param name="model">Model to serialize</param>
        /// <param name="outputStream">Stream to serialize to</param>
        /// <returns>Serialised object</returns>
        public void Serialize<TModel>(MediaRange mediaRange, TModel model, Stream outputStream)
        {
            using (var writer = new StreamWriter(new UnclosableStreamWrapper(outputStream)))
            {
                var serializer = new JavaScriptSerializer(this.jsonConfiguration);

                serializer.RegisterConverters(this.jsonConfiguration.Converters,
                    this.jsonConfiguration.PrimitiveConverters);

                try
                {
                    serializer.Serialize(model, writer);
                }
                catch (Exception exception)
                {
                    if (this.traceConfiguration.DisplayErrorTraces)
                    {
                        writer.Write(exception.Message);
                    }
                }
            }
        }

        /// <summary>
        /// Attempts to detect if the content type is JSON.
        /// Supports:
        ///   application/json
        ///   text/json
        ///   application/vnd[something]+json
        /// Matches are case insentitive to try and be as "accepting" as possible.
        /// </summary>
        /// <param name="contentType">Request content type</param>
        /// <returns>True if content type is JSON, false otherwise</returns>
        private static bool IsJsonType(string contentType)
        {
            if (string.IsNullOrEmpty(contentType))
            {
                return false;
            }

            var contentMimeType = contentType.Split(';')[0];

            return contentMimeType.Equals("application/json", StringComparison.OrdinalIgnoreCase) ||
                contentMimeType.StartsWith("application/json-", StringComparison.OrdinalIgnoreCase) ||
                contentMimeType.Equals("text/json", StringComparison.OrdinalIgnoreCase) ||
                (contentMimeType.StartsWith("application/vnd", StringComparison.OrdinalIgnoreCase) &&
                    contentMimeType.EndsWith("+json", StringComparison.OrdinalIgnoreCase));
        }
    }
}
namespace Nancy.Responses
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Xml.Serialization;
    using System.Text;
    using Nancy.Configuration;
    using Nancy.Responses.Negotiation;
    using Nancy.Xml;

    /// <summary>
    /// Default <see cref="ISerializer"/> implementation for XML serialization.
    /// </summary>
    public class DefaultXmlSerializer : ISerializer
    {
        private readonly XmlConfiguration configuration;
        private readonly TraceConfiguration traceConfiguration;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultXmlSerializer"/> class,
        /// with the provided <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public DefaultXmlSerializer(INancyEnvironment environment)
        {
            this.configuration = environment.GetValue<XmlConfiguration>();
            this.traceConfiguration = environment.GetValue<TraceConfiguration>();
        }

        /// <summary>
        /// Whether the serializer can serialize the content type
        /// </summary>
        /// <param name="mediaRange">Content type to serialise</param>
        /// <returns>True if supported, false otherwise</returns>
        public bool CanSerialize(MediaRange mediaRange)
        {
            return IsXmlType(mediaRange);
        }

        /// <summary>
        /// Gets the list of extensions that the serializer can handle.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> of extensions if any are available, otherwise an empty enumerable.</value>
        public IEnumerable<string> Extensions
        {
            get { yield return "xml"; }
        }

        /// <summary>
        /// Serialize the given model with the given contentType
        /// </summary>
        /// <param name="mediaRange">Content type to serialize into</param>
        /// <param name="model">Model to serialize</param>
        /// <param name="outputStream">Output stream to serialize to</param>
        /// <returns>Serialised object</returns>
        public void Serialize<TModel>(MediaRange mediaRange, TModel model, Stream outputStream)
        {
            try
            {
                var serializer = new XmlSerializer(typeof(TModel));

                if (this.configuration.EncodingEnabled)
                {
                    serializer.Serialize(new StreamWriter(outputStream, this.configuration.DefaultEncoding), model);
                }
                else
                {
                    serializer.Serialize(outputStream, model);
                }
            }
            catch (Exception exception)
            {
                if (this.traceConfiguration.DisplayErrorTraces)
                {
                    var bytes = Encoding.UTF8.GetBytes(exception.Message);
                    outputStream.Write(bytes, 0, exception.Message.Length);
                }
            }
        }

        private static bool IsXmlType(string contentType)
        {
            if (string.IsNullOrEmpty(contentType))
            {
                return false;
            }

            var contentMimeType = contentType.Split(';')[0];

            return contentMimeType.Equals("application/xml", StringComparison.OrdinalIgnoreCase)
                || contentMimeType.Equals("text/xml", StringComparison.OrdinalIgnoreCase)
                || (contentMimeType.StartsWith("application/vnd", StringComparison.OrdinalIgnoreCase)
                && contentMimeType.EndsWith("+xml", StringComparison.OrdinalIgnoreCase));
        }
    }
}
namespace Nancy.Responses
{
    using System.Collections.Generic;
    using System.Text;

    using Nancy.Cookies;

    /// <summary>
    /// Represents a text (text/plain) response
    /// </summary>
    public class TextResponse : Response
    {
        private const string TextPlainContentType = "text/plain";

        /// <summary>
        /// Creates a new instance of the TextResponse class
        /// </summary>
        /// <param name="contents">Text content - defaults to empty if null</param>
        /// <param name="contentType">Content Type - defaults to text/plain</param>
        /// <param name="encoding">String encoding - UTF8 if null</param>
        public TextResponse(string contents, string contentType = null, Encoding encoding = null)
        {
            if (encoding == null)
            {
                encoding = Encoding.UTF8;
            }

            if (string.IsNullOrEmpty(contentType))
            {
                contentType = TextPlainContentType;
            }

            this.ContentType = GetContentType(contentType, encoding);
            this.StatusCode = HttpStatusCode.OK;

            if (contents != null)
            {
                this.Contents = stream =>
                {
                    var data = encoding.GetBytes(contents);
                    stream.Write(data, 0, data.Length);
                };
            }
        }

        /// <summary>
        /// Creates a new instance of the TextResponse class
        /// </summary>
        /// <param name="statusCode">Status code - defaults to OK</param>
        /// <param name="contents">Text content - defaults to empty if null</param>
        /// <param name="encoding">String encoding - UTF8 if null</param>
        /// <param name="headers">Headers if required</param>
        /// <param name="cookies">Cookies if required</param>
        public TextResponse(HttpStatusCode statusCode = HttpStatusCode.OK, string contents = null, Encoding encoding = null, IDictionary<string, string> headers = null, IEnumerable<INancyCookie> cookies = null)
        {
            if (encoding == null)
            {
                encoding = Encoding.UTF8;
            }

            this.ContentType = GetContentType(TextPlainContentType, encoding);
            this.StatusCode = statusCode;

            if (contents != null)
            {
                this.Contents = stream =>
                {
                    var data = encoding.GetBytes(contents);
                    stream.Write(data, 0, data.Length);
                };
            }

            if (headers != null)
            {
                this.Headers = headers;
            }

            if (cookies != null)
            {
                foreach (var nancyCookie in cookies)
                {
                    this.Cookies.Add(nancyCookie);
                }
            }
        }

        private static string GetContentType(string contentType, Encoding encoding)
        {
            return !contentType.Contains("charset")
                ? string.Concat(contentType, "; charset=", encoding.WebName)
                : contentType;
        }
    }
}
namespace Nancy
{
    /// <summary>
    /// Configuration for the default routing.
    /// </summary>
    public class RouteConfiguration
    {
        /// <summary>
        /// A default instance of the <see cref="ViewConfiguration"/> class.
        /// </summary>
        public static readonly RouteConfiguration Default = new RouteConfiguration(
            disableMethodNotAllowedResponses: false,
            explicitHeadRouting: false);

        /// <summary>
        /// Initializes a new instance of the <see cref="RouteConfiguration"/> class.
        /// </summary>
        /// <param name="disableMethodNotAllowedResponses">Determins is 405 responses are allowed.</param>
        /// <param name="explicitHeadRouting">Enabled support for explicit HEAD route declarations.</param>
        public RouteConfiguration(bool disableMethodNotAllowedResponses = false, bool explicitHeadRouting = false)
        {
            this.DisableMethodNotAllowedResponses = disableMethodNotAllowedResponses;
            this.ExplicitHeadRouting = explicitHeadRouting;
        }

        /// <summary>
        /// Gets a value indicating whether or not to respond with 405 responses.
        /// </summary>
        /// <value><see langword="true"/>If 405 responses are allowed, otherwise <see langword="false"/>.</value>
        public bool DisableMethodNotAllowedResponses { get; private set; }

        /// <summary>
        /// Gets a value indicating whether or not to route HEAD requests explicitly.
        /// </summary>
        /// <value><see langword="true"/>If explicit HEAD route requests are allowed, otherwise <see langword="false"/>.</value>
        public bool ExplicitHeadRouting { get; private set; }
    }
}
namespace Nancy
{
    using Nancy.Configuration;

    /// <summary>
    /// Contains <see cref="RouteConfiguration"/> configuration extensions for <see cref="INancyEnvironment"/>.
    /// </summary>
    public static class RouteConfigurationExtensions
    {
        /// <summary>
        /// Configures <see cref="RouteConfiguration"/>.
        /// </summary>
        /// <param name="environment"><see cref="INancyEnvironment"/> that should be configured.</param>
        /// <param name="disableMethodNotAllowedResponses"><see langword="true"/>If 405 responses are allowed, otherwise <see langword="false"/>.</param>
        /// <param name="explicitHeadRouting"><see langword="true"/>If explicit HEAD route requests are allowed, otherwise <see langword="false"/>.</param>
        public static void Routing(this INancyEnvironment environment, bool? disableMethodNotAllowedResponses = false, bool? explicitHeadRouting = false)
        {
            environment.AddValue(new RouteConfiguration(
                disableMethodNotAllowedResponses: disableMethodNotAllowedResponses ?? RouteConfiguration.Default.DisableMethodNotAllowedResponses,
                explicitHeadRouting: explicitHeadRouting ?? RouteConfiguration.Default.ExplicitHeadRouting));
        }
    }
}
namespace Nancy.Routing.Constraints
{
    using System.Linq;

    /// <summary>
    /// Constraint for alphabetical route segments.
    /// </summary>
    public class AlphaRouteSegmentConstraint : RouteSegmentConstraintBase<string>
    {
        public override string Name
        {
            get { return "alpha"; }
        }

        protected override bool TryMatch(string constraint, string segment, out string matchedValue)
        {
            if (!segment.All(char.IsLetter))
            {
                matchedValue = null;
                return false;
            }

            matchedValue = segment;
            return true;
        }
    }
}
namespace Nancy.Routing.Constraints
{
    /// <summary>
    /// Constraint for <see cref="bool"/> route segments.
    /// </summary>
    public class BoolRouteSegmentConstraint : RouteSegmentConstraintBase<bool>
    {
        public override string Name
        {
            get { return "bool"; }
        }

        protected override bool TryMatch(string constraint, string segment, out bool matchedValue)
        {
            return bool.TryParse(segment, out matchedValue);
        }
    }
}
namespace Nancy.Routing.Constraints
{
    using System;
    using System.Globalization;

    /// <summary>
    /// Constraint for <see cref="DateTime"/> route segments with custom format.
    /// </summary>
    public class CustomDateTimeRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase<DateTime>
    {
        public override string Name
        {
            get { return "datetime"; }
        }

        protected override bool TryMatch(string segment, string[] parameters, out DateTime matchedValue)
        {
            return DateTime.TryParseExact(segment,
                parameters[0],
                CultureInfo.InvariantCulture,
                DateTimeStyles.None,
                out matchedValue);
        }
    }
}
namespace Nancy.Routing.Constraints
{
    using System;

    /// <summary>
    /// Constraint for <see cref="DateTime"/> route segments.
    /// </summary>
    public class DateTimeRouteSegmentConstraint : RouteSegmentConstraintBase<DateTime>
    {
        public override string Name
        {
            get { return "datetime"; }
        }

        protected override bool TryMatch(string constraint, string segment, out DateTime matchedValue)
        {
            return DateTime.TryParse(segment, out matchedValue);
        }
    }
}
namespace Nancy.Routing.Constraints
{
    using System.Globalization;

    /// <summary>
    /// Constraint for <see cref="decimal"/> route segments.
    /// </summary>
    public class DecimalRouteSegmentConstraint : RouteSegmentConstraintBase<decimal>
    {
        public override string Name
        {
            get { return "decimal"; }
        }

        protected override bool TryMatch(string constraint, string segment, out decimal matchedValue)
        {
            return decimal.TryParse(segment, NumberStyles.Number, CultureInfo.InvariantCulture, out matchedValue);
        }
    }
}
namespace Nancy.Routing.Constraints
{
    using System;

    /// <summary>
    /// Constraint for <see cref="Guid"/> route segments.
    /// </summary>
    public class GuidRouteSegmentConstraint : RouteSegmentConstraintBase<Guid>
    {
        public override string Name
        {
            get { return "guid"; }
        }

        protected override bool TryMatch(string constraint, string segment, out Guid matchedValue)
        {
            return Guid.TryParse(segment, out matchedValue);
        }
    }
}
namespace Nancy.Routing.Constraints
{
    using System.Globalization;

    /// <summary>
    /// Constraint for <see cref="long"/> route segments.
    /// </summary>
    public class LongRouteSegmentConstraint : RouteSegmentConstraintBase<long>
    {
        public override string Name
        {
            get { return "long"; }
        }

        protected override bool TryMatch(string constraint, string segment, out long matchedValue)
        {
            return long.TryParse(segment, NumberStyles.Integer, CultureInfo.InvariantCulture, out matchedValue);
        }
    }
}
namespace Nancy.Routing.Constraints
{
    using System.Globalization;

    /// <summary>
    /// Constraint for <see cref="int"/> route segments.
    /// </summary>
    public class IntRouteSegmentConstraint : RouteSegmentConstraintBase<int>
    {
        public override string Name
        {
            get { return "int"; }
        }

        protected override bool TryMatch(string constraint, string segment, out int matchedValue)
        {
            return int.TryParse(segment, NumberStyles.Integer, CultureInfo.InvariantCulture, out matchedValue);
        }
    }
}
namespace Nancy.Routing.Constraints
{
    using Nancy.Routing.Trie;

    /// <summary>
    /// Defines the functionality to constrain route matching.
    /// </summary>
    public interface IRouteSegmentConstraint
    {
        /// <summary>
        /// Determines whether the given constraint should be matched.
        /// </summary>
        /// <param name="constraint">The route constraint.</param>
        /// <returns><c>true</c> if the constraint matches, <c>false</c> otherwise.</returns>
        bool Matches(string constraint);

        /// <summary>
        /// Matches the segment and parameter name against the constraint.
        /// </summary>
        /// <param name="constraint">The constraint.</param>
        /// <param name="segment">The segment.</param>
        /// <param name="parameterName">Name of the parameter.</param>
        /// <returns>A <see cref="SegmentMatch"/> containing information about the captured parameters.</returns>
        SegmentMatch GetMatch(string constraint, string segment, string parameterName);
    }
}
namespace Nancy.Routing.Constraints
{
    /// <summary>
    /// Constraint for route segments with a specific length.
    /// </summary>
    public class LengthRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase<string>
    {
        public override string Name
        {
            get { return "length"; }
        }

        protected override bool TryMatch(string segment, string[] parameters, out string matchedValue)
        {
            int minLength;
            int maxLength;

            if (parameters.Length == 2)
            {
                if (!this.TryParseInt(parameters[0], out minLength) ||
                    !this.TryParseInt(parameters[1], out maxLength))
                {
                    matchedValue = null;
                    return false;
                }
            }
            else if (parameters.Length == 1)
            {
                minLength = 0;

                if (!this.TryParseInt(parameters[0], out maxLength))
                {
                    matchedValue = null;
                    return false;
                }
            }
            else
            {
                matchedValue = null;
                return false;
            }

            if (segment.Length < minLength || segment.Length > maxLength)
            {
                matchedValue = null;
                return false;
            }

            matchedValue = segment;
            return true;
        }
    }
}
namespace Nancy.Routing.Constraints
{
    /// <summary>
    /// Constraint for route segments with a maximum length.
    /// </summary>
    public class MaxLengthRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase<string>
    {
        public override string Name
        {
            get { return "maxlength"; }
        }

        protected override bool TryMatch(string segment, string[] parameters, out string matchedValue)
        {
            int maxLength;

            if (!this.TryParseInt(parameters[0], out maxLength))
            {
                matchedValue = null;
                return false;
            }

            if (segment.Length > maxLength)
            {
                matchedValue = null;
                return false;
            }

            matchedValue = segment;
            return true;
        }
    }
}
namespace Nancy.Routing.Constraints
{
    /// <summary>
    /// Constraint for <see cref="int"/> route segments with a maximum value.
    /// </summary>
    public class MaxRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase<int>
    {
        public override string Name
        {
            get { return "max"; }
        }

        protected override bool TryMatch(string segment, string[] parameters, out int matchedValue)
        {
            int minValue;
            int intValue;

            if (!this.TryParseInt(parameters[0], out minValue) ||
                !this.TryParseInt(segment, out intValue))
            {
                matchedValue = default(int);
                return false;
            }

            if (intValue > minValue)
            {
                matchedValue = default(int);
                return false;
            }

            matchedValue = intValue;
            return true;
        }
    }
}
namespace Nancy.Routing.Constraints
{
    /// <summary>
    /// Constraint for route segments with a minimum length.
    /// </summary>
    public class MinLengthRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase<string>
    {
        public override string Name
        {
            get { return "minlength"; }
        }

        protected override bool TryMatch(string segment, string[] parameters, out string matchedValue)
        {
            int minLength;

            if (!this.TryParseInt(parameters[0], out minLength))
            {
                matchedValue = null;
                return false;
            }

            if (segment.Length < minLength)
            {
                matchedValue = null;
                return false;
            }

            matchedValue = segment;
            return true;
        }
    }
}
namespace Nancy.Routing.Constraints
{
    /// <summary>
    /// Constraint for <see cref="int"/> route segments with a minimum length.
    /// </summary>
    public class MinRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase<int>
    {
        public override string Name
        {
            get { return "min"; }
        }

        protected override bool TryMatch(string segment, string[] parameters, out int matchedValue)
        {
            int minValue;
            int intValue;

            if (!this.TryParseInt(parameters[0], out minValue) ||
                !this.TryParseInt(segment, out intValue))
            {
                matchedValue = default(int);
                return false;
            }

            if (intValue < minValue)
            {
                matchedValue = default(int);
                return false;
            }

            matchedValue = intValue;
            return true;
        }
    }
}
namespace Nancy.Routing.Constraints
{
    /// <summary>
    /// Constraint for <see cref="int"/> route segments with value within a specified range.
    /// </summary>
    public class RangeRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase<int>
    {
        public override string Name
        {
            get { return "range"; }
        }

        protected override bool TryMatch(string segment, string[] parameters, out int matchedValue)
        {
            int minRange;
            int maxRange;
            int intValue;

            if (parameters.Length == 2)
            {
                if (!this.TryParseInt(parameters[0], out minRange) ||
                    !this.TryParseInt(parameters[1], out maxRange) ||
                    !this.TryParseInt(segment, out intValue))
                {
                    matchedValue = default(int);
                    return false;
                }
            }
            else
            {
                matchedValue = default(int);
                return false;
            }

            if (intValue < minRange || intValue > maxRange)
            {
                matchedValue = default(int);
                return false;
            }

            matchedValue = intValue;
            return true;
        }
    }
}
namespace Nancy.Routing.Constraints
{
    using System;

    using Nancy.Routing.Trie;

    /// <summary>
    /// Convenience class for implementing a route segment constraint.
    /// </summary>
    /// <typeparam name="T">The type of parameter to capture.</typeparam>
    public abstract class RouteSegmentConstraintBase<T> : IRouteSegmentConstraint
    {
        /// <summary>
        /// Gets the name of the constraint, i.e. "int".
        /// </summary>
        /// <value>The constraint's name.</value>
        public abstract string Name { get; }

        public virtual bool Matches(string constraint)
        {
            return constraint.Equals(Name, StringComparison.OrdinalIgnoreCase);
        }

        public SegmentMatch GetMatch(string constraint, string segment, string parameterName)
        {
            T value;
            if (this.TryMatch(constraint, segment, out value))
            {
                return CreateMatch(parameterName, value);
            }

            return SegmentMatch.NoMatch;
        }

        /// <summary>
        /// Tries to match the given segment against the constraint.
        /// </summary>
        /// <param name="constraint">The constraint.</param>
        /// <param name="segment">The segment to match.</param>
        /// <param name="matchedValue">The matched value.</param>
        /// <returns><c>true</c> if the segment matches the constraint, <c>false</c> otherwise.</returns>
        protected abstract bool TryMatch(string constraint, string segment, out T matchedValue);

        private static SegmentMatch CreateMatch(string parameterName, object matchedValue)
        {
            var match = new SegmentMatch(true);
            match.CapturedParameters.Add(parameterName, matchedValue);
            return match;
        }
    }
}
namespace Nancy.Routing.Constraints
{
    using System.Globalization;
    using System.Linq;

    /// <summary>
    /// Convenience class for implementing a route segment constraint that expects parameters.
    /// </summary>
    /// <typeparam name="T">The type of parameter to capture.</typeparam>
    public abstract class ParameterizedRouteSegmentConstraintBase<T> : RouteSegmentConstraintBase<T>
    {
        public override bool Matches(string constraint)
        {
            return constraint.Contains('(') && constraint.Contains(')') && base.Matches(constraint.Substring(0, constraint.IndexOf('(')));
        }

        protected override bool TryMatch(string constraint, string segment, out T matchedValue)
        {
            var parameters = constraint.Substring(constraint.IndexOf('(')).Trim('(', ')').Split(',');

            return TryMatch(segment, parameters, out matchedValue);
        }

        /// <summary>
        /// Tries to parse an integer using <see cref="CultureInfo.InvariantCulture"/>.
        /// </summary>
        /// <param name="string">The string value.</param>
        /// <param name="result">The resulting integer.</param>
        /// <returns><c>true</c> if the parsing was successful, <c>false</c> otherwise.</returns>
        protected bool TryParseInt(string @string, out int result)
        {
            return int.TryParse(@string, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
        }

        /// <summary>
        /// Tries to match the given segment and parameters against the constraint.
        /// </summary>
        /// <param name="segment">The segment to match.</param>
        /// <param name="parameters">The parameters to match.</param>
        /// <param name="matchedValue">The matched value.</param>
        /// <returns><c>true</c> if the segment and parameters matches the constraint, <c>false</c> otherwise.</returns>
        protected abstract bool TryMatch(string segment, string[] parameters, out T matchedValue);
    }
}
namespace Nancy.Routing.Constraints
{
    using System;

    /// <summary>
    /// Constraint for version route segments.
    /// </summary>
    public class VersionRouteSegmentConstraint : RouteSegmentConstraintBase<Version>
    {
        public override string Name
        {
            get { return "version"; }
        }

        protected override bool TryMatch(string constraint, string segment, out Version matchedValue)
        {
            return Version.TryParse(segment, out matchedValue);
        }
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;
    using Helpers;
    using Responses.Negotiation;

    /// <summary>
    /// Default implementation of a request dispatcher.
    /// </summary>
    public class DefaultRequestDispatcher : IRequestDispatcher
    {
        private readonly IRouteResolver routeResolver;
        private readonly IEnumerable<IResponseProcessor> responseProcessors;
        private readonly IRouteInvoker routeInvoker;
        private readonly IResponseNegotiator negotiator;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultRequestDispatcher"/> class, with
        /// the provided <paramref name="routeResolver"/>, <paramref name="responseProcessors"/> and <paramref name="routeInvoker"/>.
        /// </summary>
        /// <param name="routeResolver"></param>
        /// <param name="responseProcessors"></param>
        /// <param name="routeInvoker"></param>
        /// <param name="negotiator"></param>
        public DefaultRequestDispatcher(IRouteResolver routeResolver,
            IEnumerable<IResponseProcessor> responseProcessors,
            IRouteInvoker routeInvoker,
            IResponseNegotiator negotiator)
        {
            this.routeResolver = routeResolver;
            this.responseProcessors = responseProcessors;
            this.routeInvoker = routeInvoker;
            this.negotiator = negotiator;
        }

        /// <summary>
        /// Dispatches a requests.
        /// </summary>
        /// <param name="context">The <see cref="NancyContext"/> for the current request.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        public async Task<Response> Dispatch(NancyContext context, CancellationToken cancellationToken)
        {
            // TODO - May need to make this run off context rather than response .. seems a bit icky currently
            var resolveResult = this.Resolve(context);

            context.Parameters = resolveResult.Parameters;
            context.ResolvedRoute = resolveResult.Route;

            try
            {
                context.Response = await ExecuteRoutePreReq(context, cancellationToken, resolveResult.Before)
                    .ConfigureAwait(false);

                if (context.Response == null)
                {
                    context.Response = await this.routeInvoker.Invoke(resolveResult.Route, cancellationToken,
                        resolveResult.Parameters, context)
                        .ConfigureAwait(false);

                    if (context.Request.Method.Equals("HEAD", StringComparison.OrdinalIgnoreCase))
                    {
                        context.Response = new HeadResponse(context.Response);
                    }
                }

                await this.ExecutePost(context, cancellationToken, resolveResult.After, resolveResult.OnError)
                    .ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                context.Response = this.ResolveErrorResult(context, resolveResult.OnError, ex);

                if (context.Response == null)
                {
                    throw;
                }
            }

            return context.Response;
        }

        private async Task ExecutePost(NancyContext context, CancellationToken cancellationToken, AfterPipeline postHook, Func<NancyContext, Exception, dynamic> onError)
        {
            if (postHook == null)
            {
                return;
            }

            try
            {
                await postHook.Invoke(context, cancellationToken)
                    .ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                context.Response = this.ResolveErrorResult(context, onError, ex);

                if (context.Response == null)
                {
                    throw;
                }
            }
        }

        private static Task<Response> ExecuteRoutePreReq(NancyContext context, CancellationToken cancellationToken, BeforePipeline resolveResultPreReq)
        {
            if (resolveResultPreReq == null)
            {
                return Task.FromResult<Response>(null);
            }

            return resolveResultPreReq.Invoke(context, cancellationToken);
        }

        private Response ResolveErrorResult(NancyContext context, Func<NancyContext, Exception, dynamic> resolveResultOnError, Exception exception)
        {
            if (resolveResultOnError != null)
            {
                var flattenedException = exception.FlattenInnerExceptions();

                var result = resolveResultOnError.Invoke(context, flattenedException);
                if (result != null)
                {
                    return this.negotiator.NegotiateResponse(result, context);
                }
            }

            return null;
        }

        private ResolveResult Resolve(NancyContext context)
        {
            var extension = context.Request.Path.IndexOfAny(Path.GetInvalidPathChars()) >= 0 ? null
               : Path.GetExtension(context.Request.Path);

            var originalAcceptHeaders = context.Request.Headers.Accept;
            var originalRequestPath = context.Request.Path;

            if (!string.IsNullOrEmpty(extension))
            {
                var mappedMediaRanges = this.GetMediaRangesForExtension(extension.Substring(1))
                    .ToArray();

                if (mappedMediaRanges.Any())
                {
                    var newMediaRanges =
                        mappedMediaRanges.Where(x => !context.Request.Headers.Accept.Any(header => header.Equals(x)));

                    var index = context.Request.Path.LastIndexOf(extension, StringComparison.Ordinal);

                    var modifiedRequestPath =
                        context.Request.Path.Remove(index, extension.Length);

                    var match =
                        this.InvokeRouteResolver(context, modifiedRequestPath, newMediaRanges);

                    if (!(match.Route is NotFoundRoute))
                    {
                        return match;
                    }
                }
            }

            return this.InvokeRouteResolver(context, originalRequestPath, originalAcceptHeaders);
        }

        private IEnumerable<Tuple<string, decimal>> GetMediaRangesForExtension(string extension)
        {
            return this.responseProcessors
                .SelectMany(processor => processor.ExtensionMappings)
                .Where(mapping => mapping != null)
                .Where(mapping => mapping.Item1.Equals(extension, StringComparison.OrdinalIgnoreCase))
                .Select(mapping => new Tuple<string, decimal>(mapping.Item2, Decimal.MaxValue))
                .Distinct();
        }

        private ResolveResult InvokeRouteResolver(NancyContext context, string path, IEnumerable<Tuple<string, decimal>> acceptHeaders)
        {
            context.Request.Headers.Accept = acceptHeaders.ToList();
            context.Request.Url.Path = path;

            return this.routeResolver.Resolve(context);
        }
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Linq;
    using System.Resources;

    /// <summary>
    /// Default implementation of the <see cref="IRouteDescriptionProvider"/> interface. Will look for
    /// route descriptions in resource files. The resource files should have the same name as the module
    /// for which it defines routes.
    /// </summary>
    public class DefaultRouteDescriptionProvider : IRouteDescriptionProvider
    {
        /// <summary>
        /// Get the description for a route.
        /// </summary>
        /// <param name="module">The module that the route is defined in.</param>
        /// <param name="path">The path of the route that the description should be retrieved for.</param>
        /// <returns>A <see cref="string"/> containing the description of the route if it could be found, otherwise <see cref="string.Empty"/>.</returns>
        public string GetDescription(INancyModule module, string path)
        {
            var assembly =
                module.GetType().Assembly;

            if (assembly.IsDynamic)
            {
                return string.Empty;
            }

            var moduleName =
                string.Concat(module.GetType().FullName, ".resources");

            var resourceName = assembly
                .GetManifestResourceNames()
                .FirstOrDefault(x => x.Equals(moduleName, StringComparison.OrdinalIgnoreCase));

            if (resourceName != null)
            {
                var manager =
                    new ResourceManager(resourceName.Replace(".resources", string.Empty), assembly);

                return manager.GetString(path);
            }

            return string.Empty;
        }
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Threading;
    using System.Threading.Tasks;

    using Nancy.ErrorHandling;
    using Nancy.Extensions;
    using Nancy.Helpers;
    using Nancy.Responses.Negotiation;

    /// <summary>
    /// Default route invoker implementation.
    /// </summary>
    public class DefaultRouteInvoker : IRouteInvoker
    {
        private readonly IResponseNegotiator negotiator;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultRouteInvoker"/> class.
        /// </summary>
        /// <param name="negotiator">The response negotiator.</param>
        public DefaultRouteInvoker(IResponseNegotiator negotiator)
        {
            this.negotiator = negotiator;
        }

        /// <summary>
        /// Invokes the specified <paramref name="route"/> with the provided <paramref name="parameters"/>.
        /// </summary>
        /// <param name="route">The route that should be invoked.</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <param name="parameters">The parameters that the route should be invoked with.</param>
        /// <param name="context">The context of the route that is being invoked.</param>
        /// <returns>A <see cref="Response"/> instance that represents the result of the invoked route.</returns>
        public async Task<Response> Invoke(Route route, CancellationToken cancellationToken, DynamicDictionary parameters, NancyContext context)
        {
            dynamic result;

            try
            {
                result = await route.Invoke(parameters, cancellationToken).ConfigureAwait(false);
            }
            catch (RouteExecutionEarlyExitException earlyExitException)
            {
                context.WriteTraceLog(
                    sb => sb.AppendFormat(
                            "[DefaultRouteInvoker] Caught RouteExecutionEarlyExitException - reason {0}",
                            earlyExitException.Reason));
                return earlyExitException.Response;
            }

            if (!(result is ValueType) && result == null)
            {
                context.WriteTraceLog(
                    sb => sb.AppendLine("[DefaultRouteInvoker] Invocation of route returned null"));

                result = new Response();
            }

            return this.negotiator.NegotiateResponse(result, context);
        }
    }
}
namespace Nancy.Routing
{
    using System.Collections.Generic;

    /// <summary>
    /// Default implementation of the <see cref="IRouteSegmentExtractor"/> interface.
    /// </summary>
    public class DefaultRouteSegmentExtractor : IRouteSegmentExtractor
    {
        /// <summary>
        /// Extracts the segments from the <paramref name="path"/>;
        /// </summary>
        /// <param name="path">The path that the segments should be extracted from.</param>
        /// <returns>An <see cref="IEnumerable{T}"/>, containing the extracted segments.</returns>
        public IEnumerable<string> Extract(string path)
        {
            var currentSegment = string.Empty;
            var openingParenthesesCount = 0;

            for (var index = 0; index < path.Length; index++)
            {
                var token =
                    path[index];

                if (token.Equals('('))
                {
                    openingParenthesesCount++;
                }

                if (token.Equals(')'))
                {
                    openingParenthesesCount--;
                }

                if (!token.Equals('/') || openingParenthesesCount > 0)
                {
                    currentSegment += token;
                }

                if ((token.Equals('/') || index == path.Length - 1) && currentSegment.Length > 0 && openingParenthesesCount == 0)
                {
                    yield return currentSegment;
                    currentSegment = string.Empty;
                }
            }
        }
    }
}
namespace Nancy.Routing
{
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Functionality for processing an incoming request.
    /// </summary>
    public interface IRequestDispatcher
    {
        /// <summary>
        /// Dispatches a requests.
        /// </summary>
        /// <param name="context">The <see cref="NancyContext"/> for the current request.</param>
        /// <param name="cancellationToken">Cancellation token</param>
        Task<Response> Dispatch(NancyContext context, CancellationToken cancellationToken);
    }
}
namespace Nancy.Routing
{
    /// <summary>
    /// Defines the functionality for retrieving a description for a specific route.
    /// </summary>
    public interface IRouteDescriptionProvider
    {
        /// <summary>
        /// Get the description for a route.
        /// </summary>
        /// <param name="module">The module that the route is defined in.</param>
        /// <param name="path">The path of the route that the description should be retrieved for.</param>
        /// <returns>A <see cref="string"/> containing the description of the route if it could be found, otherwise <see cref="string.Empty"/>.</returns>
        string GetDescription(INancyModule module, string path);
    }
}
namespace Nancy.Routing
{
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Defines the functionality for invoking a <see cref="Route"/> and returning a <see cref="Response"/>
    /// </summary>
    public interface IRouteInvoker
    {
        /// <summary>
        /// Invokes the specified <paramref name="route"/> with the provided <paramref name="parameters"/>.
        /// </summary>
        /// <param name="route">The route that should be invoked.</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <param name="parameters">The parameters that the route should be invoked with.</param>
        /// <param name="context">The context of the route that is being invoked.</param>
        /// <returns>A <see cref="Response"/> instance that represents the result of the invoked route.</returns>
        Task<Response> Invoke(Route route, CancellationToken cancellationToken, DynamicDictionary parameters, NancyContext context);
    }
}
namespace Nancy.Routing
{
    using System;

    /// <summary>
    /// Defines the functionality for retrieving metadata for routes.
    /// </summary>
    public interface IRouteMetadataProvider
    {
        /// <summary>
        /// Gets the <see cref="Type"/> of the metadata that is created by the provider.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> instance that the route is declared in.</param>
        /// <param name="routeDescription">A <see cref="RouteDescription"/> for the route.</param>
        /// <returns>A <see cref="Type"/> instance, or <see langword="null" /> if nothing is found.</returns>
        Type GetMetadataType(INancyModule module, RouteDescription routeDescription);

        /// <summary>
        /// Gets the metadata for the provided route.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> instance that the route is declared in.</param>
        /// <param name="routeDescription">A <see cref="RouteDescription"/> for the route.</param>
        /// <returns>An object representing the metadata for the given route, or <see langword="null" /> if nothing is found.</returns>
        object GetMetadata(INancyModule module, RouteDescription routeDescription);
    }
}
namespace Nancy.Routing
{
    using System.Collections.Generic;

    /// <summary>
    /// Defines the functionality for extracting the individual segments from a route path.
    /// </summary>
    public interface IRouteSegmentExtractor
    {
        /// <summary>
        /// Extracts the segments from the <paramref name="path"/>;
        /// </summary>
        /// <param name="path">The path that the segments should be extracted from.</param>
        /// <returns>An <see cref="IEnumerable{T}"/>, containing the extracted segments.</returns>
        IEnumerable<string> Extract(string path);
    }
}
namespace Nancy.Routing
{
    /// <summary>
    /// Information about a segment parameter.
    /// </summary>
    public class ParameterSegmentInformation
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ParameterSegmentInformation"/> class.
        /// </summary>
        /// <param name="name">The name of the parameter</param>
        /// <param name="defaultValue">The default value, if any, of the parameter.</param>
        /// <param name="isOptional"><see langword="true"/> if the parameter is optional, otherwise <see langword="false" />.</param>
        public ParameterSegmentInformation(string name, string defaultValue, bool isOptional)
        {
            this.Name = name;
            this.DefaultValue = defaultValue;
            this.IsOptional = isOptional;
        }

        /// <summary>
        /// Gets the default value for the parameter.
        /// </summary>
        public string DefaultValue { get; private set; }

        /// <summary>
        /// Gets the full name of the segment.
        /// </summary>
        /// <remarks>Returns a string in one of the formats: {name}, {name?}, {name?defaultValue} depending on the kind of parameter.</remarks>
        public string FullSegmentName
        {
            get
            {
                return (this.IsOptional) ?
                    string.Concat(this.Name, "?", this.DefaultValue) :
                    this.Name;
            }
        }

        /// <summary>
        /// Gets whether or not the parameter is optional.
        /// </summary>
        /// <value><see langword="true"/> if the parameter is optional, otherwise <see langword="false" />.</value>
        public bool IsOptional { get; private set; }

        /// <summary>
        /// Gets the name of the parameter.
        /// </summary>
        public string Name { get; private set; }
    }
}
namespace Nancy.Routing
{
    using System;

    /// <summary>
    /// A class representing a route resolution result
    /// </summary>
    public class ResolveResult
    {
        /// <summary>
        /// Gets or sets the route
        /// </summary>
        public Route Route { get; set; }

        /// <summary>
        /// Gets or sets the captured parameters
        /// </summary>
        public DynamicDictionary Parameters { get; set; }

        /// <summary>
        /// Gets or sets the before module pipeline
        /// </summary>
        public BeforePipeline Before { get; set; }

        /// <summary>
        /// Gets or sets the after module pipeline
        /// </summary>
        public AfterPipeline After { get; set; }

        /// <summary>
        /// Gets or sets the on error module pipeline
        /// </summary>
        public Func<NancyContext, Exception, dynamic> OnError { get; set; }

        public ResolveResult()
        {
        }

        public ResolveResult(Route route, DynamicDictionary parameters, BeforePipeline before, AfterPipeline after, Func<NancyContext, Exception, dynamic> onError)
        {
            this.Route = route;
            this.Parameters = parameters;
            this.Before = before;
            this.After = after;
            this.OnError = onError;
        }
    }
}
namespace Nancy.Routing
{
    using System.Collections.Generic;
    using System.Threading.Tasks;

    using Nancy.Helpers;

    /// <summary>
    /// Route that is returned when the path could be matched but, the method was OPTIONS and there was no user defined handler for OPTIONS.
    /// </summary>
    public class OptionsRoute : Route
    {
        public OptionsRoute(string path, IEnumerable<string> allowedMethods)
            : base("OPTIONS", path, null, (x, c) => CreateMethodOptionsResponse(allowedMethods))
        {
        }

        private static Task<dynamic> CreateMethodOptionsResponse(IEnumerable<string> allowedMethods)
        {
            var response = new Response();
            response.Headers["Allow"] = string.Join(", ", allowedMethods);
            response.StatusCode = HttpStatusCode.OK;

            return Task.FromResult<dynamic>(response);
        }
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Contains extensions for the <see cref="IRouteCache"/> type.
    /// </summary>
    public static class RouteCacheExtensions
    {
        /// <summary>
        /// Retrieves metadata for all declared routes.
        /// </summary>
        /// <typeparam name="TMetadata">The type of the metadata to retrieve.</typeparam>
        /// <param name="cache">The <see cref="IRouteCache"/> to retrieve the metadata.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> containing instances of the <typeparamref name="TMetadata"/> type.</returns>
        public static IEnumerable<TMetadata> RetrieveMetadata<TMetadata>(this IDictionary<Type, List<Tuple<int, RouteDescription>>> cache)
        {
            return cache.Values.SelectMany(x => x.Select(y => y.Item2.Metadata.Retrieve<TMetadata>()));
        }
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Stores metadata created by <see cref="IRouteMetadataProvider"/> instances.
    /// </summary>
    public class RouteMetadata
    {
        /// <summary>
        /// Creates a new instance of the <see cref="RouteMetadata"/> class.
        /// </summary>
        /// <param name="metadata">An <see cref="IDictionary{TKey,TValue}"/> containing the metadata, organised by the type that it is stored in.</param>
        public RouteMetadata(IDictionary<Type, object> metadata)
        {
            this.Raw = metadata;
        }

        /// <summary>
        /// Gets the raw metadata <see cref="IDictionary{TKey,TValue}"/>.
        /// </summary>
        /// <value>An <see cref="IDictionary{TKey,TValue}"/> instance.</value>
        public IDictionary<Type, object> Raw { get; private set; }

        /// <summary>
        /// Gets a boolean that indicates if the specific type of metadata is stored.
        /// </summary>
        /// <typeparam name="TMetadata">The type of the metadata to check for.</typeparam>
        /// <returns><see langword="true"/> if metadata, of the requested type is stored, otherwise <see langword="false"/>.</returns>
        public bool Has<TMetadata>()
        {
            return this.Raw.ContainsKey(typeof(TMetadata));
        }

        /// <summary>
        /// Retrieves metadata of the provided type.
        /// </summary>
        /// <typeparam name="TMetadata">The type of the metadata to retrieve.</typeparam>
        /// <returns>The metadata instance if available, otherwise <see langword="null"/>.</returns>
        public TMetadata Retrieve<TMetadata>()
        {
            var key =
                typeof(TMetadata);

            return (this.Raw.ContainsKey(key)) ?
                (TMetadata)this.Raw[key] :
                default(TMetadata);
        }
    }
}
namespace Nancy.Routing
{
    using System;

    /// <summary>
    /// Defines the functionality for retrieving metadata for routes.
    /// </summary>
    /// <typeparam name="TMetadata">The metadata type.</typeparam>
    public abstract class RouteMetadataProvider<TMetadata> : IRouteMetadataProvider
    {
        /// <summary>
        /// Gets the <see cref="Type"/> of the metadata that is created by the provider.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> instance that the route is declared in.</param>
        /// <param name="routeDescription">A <see cref="RouteDescription"/> for the route.</param>
        /// <returns>A <see cref="Type"/> instance, or null if none are found.</returns>
        public Type GetMetadataType(INancyModule module, RouteDescription routeDescription)
        {
            return typeof(TMetadata);
        }

        /// <summary>
        /// Gets the metadata for the provided route.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule" /> instance that the route is declared in.</param>
        /// <param name="routeDescription">A <see cref="RouteDescription" /> for the route.</param>
        /// <returns>An instance of <typeparamref name="TMetadata"/>.</returns>
        public object GetMetadata(INancyModule module, RouteDescription routeDescription)
        {
            return this.GetRouteMetadata(module, routeDescription);
        }

        /// <summary>
        /// Gets the metadata for the provided route.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> instance that the route is declared in.</param>
        /// <param name="routeDescription">A <see cref="RouteDescription"/> for the route.</param>
        /// <returns>An instance of <typeparamref name="TMetadata"/>.</returns>
        protected abstract TMetadata GetRouteMetadata(INancyModule module, RouteDescription routeDescription);
    }
}
namespace Nancy.Routing.Trie
{
    using System.Collections.Generic;

    /// <summary>
    /// Trie structure for resolving routes
    /// </summary>
    public interface IRouteResolverTrie
    {
        /// <summary>
        /// Build the trie from the route cache
        /// </summary>
        /// <param name="cache">The route cache</param>
        void BuildTrie(IRouteCache cache);

        /// <summary>
        /// Get all matches for the given method and path
        /// </summary>
        /// <param name="method">HTTP method</param>
        /// <param name="path">Requested path</param>
        /// <param name="context">Current Nancy context</param>
        /// <returns>An array of <see cref="MatchResult"/> elements</returns>
        MatchResult[] GetMatches(string method, string path, NancyContext context);

        /// <summary>
        /// Get all method options for the given path
        /// </summary>
        /// <param name="path">Requested path</param>
        /// <param name="context">Current Nancy context</param>
        /// <returns>A collection of strings, each representing an allowed method</returns>
        IEnumerable<string> GetOptions(string path, NancyContext context);
    }
}
namespace Nancy.Routing.Trie
{
    using Nancy.Routing.Trie.Nodes;

    /// <summary>
    /// Factory for creating trie nodes from route definition segments
    /// </summary>
    public interface ITrieNodeFactory
    {
        /// <summary>
        /// Gets the correct Trie node type for the given segment
        /// </summary>
        /// <param name="parent">Parent node</param>
        /// <param name="segment">Segment</param>
        /// <returns>Corresponding TrieNode instance</returns>
        TrieNode GetNodeForSegment(TrieNode parent, string segment);
    }
}
namespace Nancy.Routing.Trie
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Match result for a matched route
    /// </summary>
    public class MatchResult : NodeData, IComparable<MatchResult>
    {
        private static readonly MatchResult noMatch = new MatchResult();

        private static readonly MatchResult[] noMatches = ArrayCache.Empty<MatchResult>();

        /// <summary>
        /// Gets or sets the captured parameters
        /// </summary>
        public IDictionary<string, object> Parameters { get; set; }

        /// <summary>
        /// Gets the "no match" <see cref="MatchResult"/>
        /// </summary>
        public static MatchResult NoMatch
        {
            get
            {
                return noMatch;
            }
        }

        /// <summary>
        /// Gets the "no matches" <see cref="MatchResult"/> collection
        /// </summary>
        public static MatchResult[] NoMatches
        {
            get
            {
                return noMatches;
            }
        }

        public MatchResult(IDictionary<string, object> parameters)
        {
            this.Parameters = parameters;
        }

        public MatchResult()
            : this(new Dictionary<string, object>())
        {
        }

        /// <summary>
        /// Compares the current object with another object of the same type.
        /// </summary>
        /// <returns>
        /// A value that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other"/> parameter.Zero This object is equal to <paramref name="other"/>. Greater than zero This object is greater than <paramref name="other"/>. 
        /// </returns>
        /// <param name="other">An object to compare with this object.</param>
        public int CompareTo(MatchResult other)
        {
            // Length of the route takes precedence over score
            if (this.RouteLength < other.RouteLength)
            {
                return -1;
            }

            if (this.RouteLength > other.RouteLength)
            {
                return 1;
            }

            if (this.Score < other.Score)
            {
                return -1;
            }

            if (this.Score > other.Score)
            {
                return 1;
            }

            if (Equals(this.ModuleType, other.ModuleType))
            {
                if (this.RouteIndex < other.RouteIndex)
                {
                    return -1;
                }

                if (this.RouteIndex > other.RouteIndex)
                {
                    return 1;
                }
            }

            return 0;
        }
    }
}
namespace Nancy.Routing.Trie
{
    using System;

    /// <summary>
    /// Represents a route that ends at a particular node.
    /// We store/calculate as much as we can at build time to save
    /// time during route matching.
    /// </summary>
    public class NodeData
    {
        /// <summary>
        /// Gets or sets the module type from the matching module
        /// </summary>
        public Type ModuleType { get; set; }

        /// <summary>
        /// Gets or sets the route method
        /// </summary>
        public string Method { get; set; }

        /// <summary>
        /// Gets or sets the index in the module routing table
        /// </summary>
        public int RouteIndex { get; set; }

        /// <summary>
        /// Gets or sets the number of segments in the route
        /// </summary>
        public int RouteLength { get; set; }

        /// <summary>
        /// Gets or sets the route score
        /// </summary>
        public int Score { get; set; }

        /// <summary>
        /// Gets or sets the route condition delegate
        /// </summary>
        public Func<NancyContext, bool> Condition { get; set; }
    }
}
namespace Nancy.Routing.Trie
{
    using System.Collections.Generic;

    /// <summary>
    /// Helpers methods for NodeData
    /// </summary>
    public static class NodeDataExtensions
    {
        /// <summary>
        /// Converts a <see cref="NodeData"/> instance into a <see cref="MatchResult"/>
        /// </summary>
        /// <param name="data">Node data</param>
        /// <param name="parameters">Captured parameters</param>
        /// <returns>A <see cref="MatchResult"/> instance</returns>
        public static MatchResult ToResult(this NodeData data, IDictionary<string, object> parameters)
        {
            return new MatchResult(parameters)
            {
                ModuleType = data.ModuleType,
                Method = data.Method,
                RouteIndex = data.RouteIndex,
                RouteLength = data.RouteLength,
                Condition = data.Condition,
                Score = data.Score
            };
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    /// <summary>
    /// A node for standard captures e.g. {foo}
    /// </summary>
    public class CaptureNode : TrieNode
    {
        private string parameterName;

        /// <summary>
        /// Score for this node
        /// </summary>
        public override int Score
        {
            get { return 1000; }
        }

        public CaptureNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory)
            : base(parent, segment, nodeFactory)
        {
            this.ExtractParameterName();
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public override SegmentMatch Match(string segment)
        {
            var match = new SegmentMatch(true);
            match.CapturedParameters.Add(this.parameterName, segment);
            return match;
        }

        private void ExtractParameterName()
        {
            this.parameterName = this.RouteDefinitionSegment.Trim('{', '}');
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    using System.Collections.Generic;
    using System.Linq;

    using Nancy.Routing.Constraints;

    /// <summary>
    /// A node for constraint captures e.g. {foo:alpha}, {foo:datetime}
    /// </summary>
    public class CaptureNodeWithConstraint : TrieNode
    {
        private readonly IEnumerable<IRouteSegmentConstraint> routeSegmentConstraints;
        private string parameterName;
        private string constraint;

        /// <summary>
        /// Score for this node
        /// </summary>
        public override int Score
        {
            get { return 2000; }
        }

        public CaptureNodeWithConstraint(TrieNode parent, string segment, ITrieNodeFactory nodeFactory, IEnumerable<IRouteSegmentConstraint> routeSegmentConstraints)
            : base(parent, segment, nodeFactory)
        {
            this.routeSegmentConstraints = routeSegmentConstraints;
            this.ExtractParameterName();
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public override SegmentMatch Match(string segment)
        {
            var routeSegmentConstraint = routeSegmentConstraints.FirstOrDefault(x => x.Matches(constraint));
            if (routeSegmentConstraint == null)
            {
                return SegmentMatch.NoMatch;
            }

            return routeSegmentConstraint.GetMatch(this.constraint, segment, this.parameterName);
        }

        private void ExtractParameterName()
        {
            var segmentSplit = this.RouteDefinitionSegment.Trim('{', '}').Split(':');

            this.parameterName = segmentSplit[0];
            this.constraint = segmentSplit[1];
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    using System;

    /// <summary>
    /// A capture node with a default value e.g. {foo?default}
    /// </summary>
    public class CaptureNodeWithDefaultValue : CaptureNode
    {
        private string parameterName;

        private string defaultValue;

        /// <summary>
        /// Score for this node
        /// </summary>
        public override int Score
        {
            get { return 1000; }
        }

        public CaptureNodeWithDefaultValue(TrieNode parent, string segment, ITrieNodeFactory nodeFactory)
            : base(parent, segment, nodeFactory)
        {
            this.ExtractParameterNameAndDefaultValue();
        }

        /// <summary>
        /// Add a new route to the trie
        /// Adds itself as a normal capture node, but also sets a default capture
        /// on the parent and adds this node's children as children of the parent
        /// too (so it can effectively be "skipped" during matching)
        /// </summary>
        /// <param name="segments">The segments of the route definition</param>
        /// <param name="currentIndex">Current index in the segments array</param>
        /// <param name="currentScore">Current score for this route</param>
        /// <param name="nodeCount">Number of nodes added for this route</param>
        /// <param name="moduleType">The module key the route comes from</param>
        /// <param name="routeIndex">The route index in the module</param>
        /// <param name="routeDescription">The route description</param>
        public override void Add(string[] segments, int currentIndex, int currentScore, int nodeCount, Type moduleType, int routeIndex, RouteDescription routeDescription)
        {
            base.Add(segments, currentIndex, currentScore, nodeCount, moduleType, routeIndex, routeDescription);

            this.Parent.AdditionalParameters[this.parameterName] = this.defaultValue;

            // Keep the same index, reduce the node count and the score
            this.Parent.Add(segments, currentIndex, currentScore - this.Parent.Score, nodeCount - 1, moduleType, routeIndex, routeDescription);
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public override SegmentMatch Match(string segment)
        {
            var match = new SegmentMatch(true);
            match.CapturedParameters[this.parameterName] = segment;
            return match;
        }

        private void ExtractParameterNameAndDefaultValue()
        {
            var elements = this.RouteDefinitionSegment.Trim('{', '}').Split('?');

            if (elements.Length != 2)
            {
                throw new InvalidOperationException(string.Format("Invalid capture route: {0}", this.RouteDefinitionSegment));
            }

            this.parameterName = elements[0];
            this.defaultValue = elements[1];
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Text.RegularExpressions;

    using Nancy.Routing.Constraints;

    /// <summary>
    /// A node multiple standard captures combined with a literal e.g. {id}.png.{thing}.{otherthing}
    /// </summary>
    public class CaptureNodeWithMultipleParameters : TrieNode
    {
        private static readonly Regex MatchRegex = new Regex(@"({?[^{}]*}?)", RegexOptions.Compiled);


        private readonly List<string> parameterNames = new List<string>();
        private readonly List<string> constraints = new List<string>();

        private string builtRegex = string.Empty;
        private IEnumerable<IRouteSegmentConstraint> routeSegmentConstraints;

        private const string AssertStart = "^";
        private const string MatchParameter = "(.*)";
        private const string AssertEnd = "$";

        /// <summary>
        /// Captures parameters within segments that contain literals.
        ///     i.e:
        ///         /{file}.{name}
        ///         /{file}.html
        ///         /{major}.{minor}.{revision}B{build}
        /// </summary>
        /// <param name="parent">The parent node</param>
        /// <param name="segment">The segment to match upon</param>
        /// <param name="nodeFactory">The factory</param>
        /// <param name="routeSegmentConstraints"></param>
        public CaptureNodeWithMultipleParameters(TrieNode parent, string segment, ITrieNodeFactory nodeFactory, IEnumerable<IRouteSegmentConstraint> routeSegmentConstraints)
            : base(parent, segment, nodeFactory)
        {
            this.routeSegmentConstraints = routeSegmentConstraints;
            this.ExtractParameterNames();
        }

        /// <summary>
        /// Determines whether this TrieNode should be used for the given segment.
        /// </summary>
        /// <param name="segment">The route segment</param>
        /// <returns>a boolean</returns>
        public static bool IsMatch(string segment)
        {
            return MatchRegex.Matches(segment).Cast<Group>().Count(g => g.Value != string.Empty) > 1;
        }

        private static bool IsParameterCapture(Capture match)
        {
            return match.Value.StartsWith("{") && match.Value.EndsWith("}");
        }

        /// <summary>
        /// Score for this node
        /// </summary>
        public override int Score
        {
            get { return 100; }
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public override SegmentMatch Match(string segment)
        {
            var match = SegmentMatch.NoMatch;
            var regex = new Regex(this.builtRegex, StaticConfiguration.CaseSensitive ? RegexOptions.None : RegexOptions.IgnoreCase);

            if (regex.IsMatch(segment))
            {
                match = new SegmentMatch(true);
                var regexMatch = regex.Match(segment);
                for (var i = 1; i < regexMatch.Groups.Count; i++)
                {
                    match.CapturedParameters.Add(this.parameterNames[i - 1], regexMatch.Groups[i].Value);
                    if (!string.IsNullOrEmpty(this.constraints[i - 1]))
                    {
                        var routeSegmentConstraint = this.routeSegmentConstraints.FirstOrDefault(x => x.Matches(constraints[i - 1]));
                        if (routeSegmentConstraint == null || !routeSegmentConstraint.GetMatch(this.constraints[i - 1], regexMatch.Groups[i].Value, this.parameterNames[i - 1]).Matches)
                        {
                            return SegmentMatch.NoMatch;
                        }
                    }
                }
            }
            return match;
        }

        /// <summary>
        /// Extracts the parameter name and the literals for the segment
        /// </summary>
        private void ExtractParameterNames()
        {
            var matches = MatchRegex.Matches(this.RouteDefinitionSegment);
            this.BuildRegex(AssertStart);
            foreach (Match match in matches)
            {
                if (IsParameterCapture(match))
                {
                    if (match.Value.Contains(":"))
                    {
                        var segmentSplit = match.Value.Trim('{', '}').Split(':');
                        this.parameterNames.Add(segmentSplit[0]);
                        this.constraints.Add(segmentSplit[1]);
                    }
                    else
                    {
                        this.parameterNames.Add(match.Value.Trim('{', '}'));
                        this.constraints.Add(string.Empty);
                    }
                    this.BuildRegex(MatchParameter);
                }
                else
                {
                    this.BuildRegex(Regex.Escape(match.Value));
                }
            }
            this.BuildRegex(AssertEnd);
        }

        private void BuildRegex(string regexSegment)
        {
            this.builtRegex += regexSegment;
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text.RegularExpressions;

    /// <summary>
    /// A greedy regular expression capture node e.g. ^(?&lt;id>\d{0,100})$
    /// For use on an entire route path, regular expression must be surrounded by ^( )$
    /// e.g. @"^(?:(?&lt;id>videos/\d{1,10})(?:/{0,1}(?&lt;slug>.*)))$"
    /// This will match for a Url like /videos/123/some-random-slug
    /// and capture 'videos/123' and 'some-random-slug'
    /// </summary>
    public class GreedyRegExCaptureNode : TrieNode
    {
        private Regex expression;
        private string[] groupNames;

        /// <summary>
        /// Score for this node
        /// </summary>
        public override int Score
        {
            get { return 100; }
        }

        public GreedyRegExCaptureNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory)
            : base(parent, segment, nodeFactory)
        {
            this.BuildRegEx();
        }

        /// <summary>
        /// Gets all matches for a given requested route
        /// Overridden to handle greedy capturing
        /// </summary>
        /// <param name="segments">Requested route segments</param>
        /// <param name="currentIndex">Current index in the route segments</param>
        /// <param name="capturedParameters">Currently captured parameters</param>
        /// <param name="context">Current Nancy context</param>
        /// <returns>A collection of <see cref="MatchResult"/> objects</returns>
        public override IEnumerable<MatchResult> GetMatches(string[] segments, int currentIndex, IDictionary<string, object> capturedParameters, NancyContext context)
        {
            var value = segments.Skip(currentIndex).Aggregate((seg1, seg2) => seg1 + "/" + seg2);
            var match = this.expression.Match(value);

            if (!match.Success)
            {
                return ArrayCache.Empty<MatchResult>();
            }

            foreach (var groupName in this.groupNames)
            {
                var group = match.Groups[groupName];

                if (group.Success)
                {
                    capturedParameters.Add(groupName, group.Value);
                }
            }

            return this.NodeData.Select(nd => nd.ToResult(capturedParameters));
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// Not-required or called for this node type
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public override SegmentMatch Match(string segment)
        {
            throw new NotSupportedException();
        }

        private void BuildRegEx()
        {
            this.expression = new Regex(this.RouteDefinitionSegment, RegexOptions.Compiled);
            this.groupNames = this.expression.GetGroupNames();
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// A greedy capture node e.g. {greedy*}
    /// e.g. /foo/bar/{greedy*} - this node will be hit for /foo/bar/[anything that doesn't match another route], but
    /// not for just /foo/bar
    /// e.g. /foo/{greedy*}/bar - this node will be hit for /foo/[anything that doesn't match another route]/bar
    /// </summary>
    public class GreedyCaptureNode : TrieNode
    {
        private string parameterName;

        /// <summary>
        /// Score for this node
        /// </summary>
        public override int Score
        {
            get { return 0; }
        }

        public GreedyCaptureNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory)
            : base(parent, segment, nodeFactory)
        {
            this.GetParameterName();
        }

        /// <summary>
        /// Gets all matches for a given requested route
        /// Overridden to handle greedy capturing
        /// </summary>
        /// <param name="segments">Requested route segments</param>
        /// <param name="currentIndex">Current index in the route segments</param>
        /// <param name="capturedParameters">Currently captured parameters</param>
        /// <param name="context">Current Nancy context</param>
        /// <returns>A collection of <see cref="MatchResult"/> objects</returns>
        public override IEnumerable<MatchResult> GetMatches(string[] segments, int currentIndex, IDictionary<string, object> capturedParameters, NancyContext context)
        {
            var fullGreedy = this.GetFullGreedy(segments, currentIndex, capturedParameters);
            if (!this.Children.Any())
            {
                return fullGreedy;
            }

            var sb = new StringBuilder(segments[currentIndex]);
            var results = new List<MatchResult>();
            currentIndex++;

            while (!this.NoMoreSegments(segments, currentIndex - 1))
            {
                var currentSegment = segments[currentIndex];

                TrieNode matchingChild;
                if (this.Children.TryGetValue(currentSegment, out matchingChild))
                {
                    var parameters = new Dictionary<string, object>(capturedParameters);
                    parameters[this.parameterName] = sb.ToString();
                    results.AddRange(matchingChild.GetMatches(segments, currentIndex, parameters, context));
                }

                sb.AppendFormat("/{0}", currentSegment);
                currentIndex++;
            }

            if (!results.Any())
            {
                results.AddRange(fullGreedy);
            }

            return results;
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// Not-required or called for this node type
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public override SegmentMatch Match(string segment)
        {
            throw new NotSupportedException();
        }

        private IEnumerable<MatchResult> GetFullGreedy(string[] segments, int currentIndex, IDictionary<string, object> capturedParameters)
        {
            if (!this.NodeData.Any())
            {
                return ArrayCache.Empty<MatchResult>();
            }

            var value = segments.Skip(currentIndex).Aggregate((seg1, seg2) => seg1 + "/" + seg2);
            capturedParameters[this.parameterName] = value;

            return this.NodeData.Select(nd => nd.ToResult(capturedParameters));
        }

        private void GetParameterName()
        {
            this.parameterName = this.RouteDefinitionSegment.Trim('{', '}').TrimEnd('*');
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    using System;

    /// <summary>
    /// Literal string node e.g. goo
    /// </summary>
    public class LiteralNode : TrieNode
    {
        /// <summary>
        /// Score for this node
        /// </summary>
        public override int Score
        {
            get { return 10000; }
        }

        public LiteralNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory)
            : base(parent, segment, nodeFactory)
        {
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public override SegmentMatch Match(string segment)
        {
            var comparisonType = StaticConfiguration.CaseSensitive ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;

            if (string.Equals(
                    segment,
                    this.RouteDefinitionSegment,
                    comparisonType))
            {
                return new SegmentMatch(true);
            }

            return SegmentMatch.NoMatch;
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    using System;

    /// <summary>
    /// An optional capture node e.g. {foo?}
    /// </summary>
    public class OptionalCaptureNode : TrieNode
    {
        private string parameterName;

        /// <summary>
        /// Score for this node
        /// </summary>
        public override int Score
        {
            get { return 1000; }
        }

        public OptionalCaptureNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory)
            : base(parent, segment, nodeFactory)
        {
            this.ExtractParameterName();
        }

        /// <summary>
        /// Add a new route to the trie
        /// Adds itself as a normal capture node, but also adds this node's
        /// children as children of the parent too
        /// (so it can effectively be "skipped" during matching)
        /// </summary>
        /// <param name="segments">The segments of the route definition</param>
        /// <param name="currentIndex">Current index in the segments array</param>
        /// <param name="currentScore">Current score for this route</param>
        /// <param name="nodeCount">Number of nodes added for this route</param>
        /// <param name="moduleType">The module key the route comes from</param>
        /// <param name="routeIndex">The route index in the module</param>
        /// <param name="routeDescription">The route description</param>
        public override void Add(string[] segments, int currentIndex, int currentScore, int nodeCount, Type moduleType, int routeIndex, RouteDescription routeDescription)
        {
            base.Add(segments, currentIndex, currentScore, nodeCount, moduleType, routeIndex, routeDescription);

            // Keep the same index, reduce the node count and the score
            this.Parent.Add(segments, currentIndex, currentScore - this.Parent.Score, nodeCount - 1, moduleType, routeIndex, routeDescription);
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public override SegmentMatch Match(string segment)
        {
            var match = new SegmentMatch(true);
            match.CapturedParameters[this.parameterName] = segment;
            return match;
        }

        private void ExtractParameterName()
        {
            this.parameterName = this.RouteDefinitionSegment.Trim('{', '}').TrimEnd('?');
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    using System.Text.RegularExpressions;

    /// <summary>
    /// A regular expression capture node e.g. (?&lt;foo>\d{2,4})
    /// </summary>
    public class RegExNode : TrieNode
    {
        private Regex expression;

        private string[] groupNames;

        /// <summary>
        /// Score for this node
        /// </summary>
        public override int Score
        {
            get { return 1000; }
        }

        public RegExNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory)
            : base(parent, segment, nodeFactory)
        {
            this.BuildRegEx();
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public override SegmentMatch Match(string segment)
        {
            var match = this.expression.Match(segment);

            if (!match.Success)
            {
                return SegmentMatch.NoMatch;
            }

            var result = new SegmentMatch(true);
            foreach (var groupName in this.groupNames)
            {
                var group = match.Groups[groupName];
                if (group.Success)
                {
                    result.CapturedParameters[groupName] = group.Value;
                }
            }

            return result;
        }

        private void BuildRegEx()
        {
            this.expression = new Regex(this.RouteDefinitionSegment, RegexOptions.Compiled);
            this.groupNames = this.expression.GetGroupNames();
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    using System.Collections.Generic;

    /// <summary>
    /// Root node of a trie
    /// </summary>
    public class RootNode : TrieNode
    {
        private SegmentMatch segmentMatch = new SegmentMatch(true);

        private readonly Dictionary<string, object> localCaptures = new Dictionary<string, object>();

        /// <summary>
        /// Score for this node
        /// </summary>
        public override int Score
        {
            get { return 0; }
        }

        public RootNode(ITrieNodeFactory nodeFactory)
            : base(null, null, nodeFactory)
        {
        }

        /// <summary>
        /// Gets all matches for a given requested route
        /// </summary>
        /// <param name="segments">Requested route segments</param>
        /// <param name="currentIndex">Current index in the route segments</param>
        /// <param name="capturedParameters">Currently captured parameters</param>
        /// <param name="context">Current Nancy context</param>
        /// <returns>A collection of <see cref="MatchResult"/> objects</returns>
        public override IEnumerable<MatchResult> GetMatches(string[] segments, int currentIndex, IDictionary<string, object> capturedParameters, NancyContext context)
        {
            if (segments.Length == 0)
            {
                return this.BuildResults(capturedParameters, this.localCaptures);
            }

            return this.GetMatchingChildren(segments, currentIndex, capturedParameters, this.localCaptures, context);
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public override SegmentMatch Match(string segment)
        {
            return this.segmentMatch;
        }
    }
}
namespace Nancy.Routing.Trie.Nodes
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// A base class representing a node in the route trie
    /// </summary>
    public abstract class TrieNode
    {
        private readonly ITrieNodeFactory nodeFactory;

        /// <summary>
        /// Gets or sets the parent node
        /// </summary>
        public TrieNode Parent { get; protected set; }

        /// <summary>
        /// Gets or sets the segment from the route definition that this node represents
        /// </summary>
        public string RouteDefinitionSegment { get; protected set; }

        /// <summary>
        /// Gets or sets the children of this node
        /// </summary>
        public IDictionary<string, TrieNode> Children { get; protected set; }

        /// <summary>
        /// Gets or sets the node data stored at this node, which will be converted
        /// into the <see cref="MatchResult"/> if a match is found
        /// </summary>
        public IList<NodeData> NodeData { get; protected set; }

        /// <summary>
        /// Additional parameters to set that can be determined at trie build time
        /// </summary>
        public IDictionary<string, object> AdditionalParameters { get; protected set; }

        /// <summary>
        /// Score for this node
        /// </summary>
        public abstract int Score { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="TrieNode"/> class
        /// </summary>
        /// <param name="parent">Parent node</param>
        /// <param name="segment">Segment of the route definition</param>
        /// <param name="nodeFactory">Factory for creating new nodes</param>
        protected TrieNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory)
        {
            this.nodeFactory = nodeFactory;
            this.Parent = parent;
            this.RouteDefinitionSegment = segment;

            this.Children = new Dictionary<string, TrieNode>(StaticConfiguration.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
            this.AdditionalParameters = new Dictionary<string, object>();
            this.NodeData = new List<NodeData>();
        }

        /// <summary>
        /// Add a new route to the trie
        /// </summary>
        /// <param name="segments">The segments of the route definition</param>
        /// <param name="moduleType">The module key the route comes from</param>
        /// <param name="routeIndex">The route index in the module</param>
        /// <param name="routeDescription">The route description</param>
        public void Add(string[] segments, Type moduleType, int routeIndex, RouteDescription routeDescription)
        {
            this.Add(segments, -1, 0, 0, moduleType, routeIndex, routeDescription);
        }

        /// <summary>
        /// Add a new route to the trie
        /// </summary>
        /// <param name="segments">The segments of the route definition</param>
        /// <param name="currentIndex">Current index in the segments array</param>
        /// <param name="currentScore">Current score for this route</param>
        /// <param name="nodeCount">Number of nodes added for this route</param>
        /// <param name="moduleType">The module key the route comes from</param>
        /// <param name="routeIndex">The route index in the module</param>
        /// <param name="routeDescription">The route description</param>
        public virtual void Add(string[] segments, int currentIndex, int currentScore, int nodeCount, Type moduleType, int routeIndex, RouteDescription routeDescription)
        {
            if (this.NoMoreSegments(segments, currentIndex))
            {
                this.NodeData.Add(this.BuildNodeData(nodeCount, currentScore + this.Score, moduleType, routeIndex, routeDescription));
                return;
            }

            nodeCount++;
            currentIndex++;
            TrieNode child;

            if (!this.Children.TryGetValue(segments[currentIndex], out child))
            {
                child = this.nodeFactory.GetNodeForSegment(this, segments[currentIndex]);
                this.Children.Add(segments[currentIndex], child);
            }

            child.Add(segments, currentIndex, currentScore + this.Score, nodeCount, moduleType, routeIndex, routeDescription);
        }

        /// <summary>
        /// Gets all matches for a given requested route
        /// </summary>
        /// <param name="segments">Requested route segments</param>
        /// <param name="context">Current Nancy context</param>
        /// <returns>A collection of <see cref="MatchResult"/> objects</returns>
        public virtual IEnumerable<MatchResult> GetMatches(string[] segments, NancyContext context)
        {
            return this.GetMatches(segments, 0, new Dictionary<string, object>(this.AdditionalParameters), context);
        }

        /// <summary>
        /// Gets all matches for a given requested route
        /// </summary>
        /// <param name="segments">Requested route segments</param>
        /// <param name="currentIndex">Current index in the route segments</param>
        /// <param name="capturedParameters">Currently captured parameters</param>
        /// <param name="context">Current Nancy context</param>
        /// <returns>A collection of <see cref="MatchResult"/> objects</returns>
        public virtual IEnumerable<MatchResult> GetMatches(string[] segments, int currentIndex, IDictionary<string, object> capturedParameters, NancyContext context)
        {
            var segmentMatch = this.Match(segments[currentIndex]);
            if (segmentMatch == SegmentMatch.NoMatch)
            {
                return MatchResult.NoMatches;
            }

            if (this.NoMoreSegments(segments, currentIndex))
            {
                return this.BuildResults(capturedParameters, segmentMatch.CapturedParameters) ?? MatchResult.NoMatches;
            }

            currentIndex++;

            return this.GetMatchingChildren(segments, currentIndex, capturedParameters, segmentMatch.CapturedParameters, context);
        }

        /// <summary>
        /// Gets a string representation of all routes
        /// </summary>
        /// <returns>Collection of strings, each representing a route</returns>
        public virtual IEnumerable<string> GetRoutes()
        {
            var routeList = new List<string>(this.Children.Values.SelectMany(c => c.GetRoutes())
                             .Select(s => (this.RouteDefinitionSegment ?? string.Empty) + "/" + s));

            if (this.NodeData.Any())
            {
                var node = this.NodeData.First();
                var resultData = string.Format("{0} (Segments: {1} Score: {2})", this.RouteDefinitionSegment ?? "/", node.RouteLength, node.Score);
                routeList.Add(resultData);
            }

            return routeList;
        }

        /// <summary>
        /// Build the node data that will be used to create the <see cref="MatchResult"/>
        /// We calculate/store as much as possible at build time to reduce match time.
        /// </summary>
        /// <param name="nodeCount">Number of nodes in the route</param>
        /// <param name="score">Score for the route</param>
        /// <param name="moduleType">The module key the route comes from</param>
        /// <param name="routeIndex">The route index in the module</param>
        /// <param name="routeDescription">The route description</param>
        /// <returns>A NodeData instance</returns>
        protected virtual NodeData BuildNodeData(int nodeCount, int score, Type moduleType, int routeIndex, RouteDescription routeDescription)
        {
            return new NodeData
            {
                Method = routeDescription.Method,
                RouteIndex = routeIndex,
                RouteLength = nodeCount,
                Score = score,
                Condition = routeDescription.Condition,
                ModuleType = moduleType,
            };
        }

        /// <summary>
        /// Returns whether we are at the end of the segments
        /// </summary>
        /// <param name="segments">Route segments</param>
        /// <param name="currentIndex">Current index</param>
        /// <returns>True if no more segments left, false otherwise</returns>
        protected bool NoMoreSegments(string[] segments, int currentIndex)
        {
            return currentIndex >= segments.Length - 1;
        }

        /// <summary>
        /// Build the results collection from the captured parameters if
        /// this node is the end result
        /// </summary>
        /// <param name="capturedParameters">Currently captured parameters</param>
        /// <param name="localCaptures">Parameters captured by the local matching</param>
        /// <returns>Array of <see cref="MatchResult"/> objects corresponding to each set of <see cref="NodeData"/> stored at this node</returns>
        protected IEnumerable<MatchResult> BuildResults(IDictionary<string, object> capturedParameters, IDictionary<string, object> localCaptures)
        {
            if (!this.NodeData.Any())
            {
                return MatchResult.NoMatches;
            }

            var parameters = new Dictionary<string, object>(capturedParameters);

            if (this.AdditionalParameters.Any())
            {
                foreach (var additionalParameter in this.AdditionalParameters)
                {
                    if (!parameters.ContainsKey(additionalParameter.Key))
                    {
                        parameters[additionalParameter.Key] = additionalParameter.Value;
                    }
                }
            }

            if (localCaptures.Any())
            {
                foreach (var localCapture in localCaptures)
                {
                    parameters[localCapture.Key] = localCapture.Value;
                }
            }

            return this.NodeData.Select(n => n.ToResult(parameters));
        }

        /// <summary>
        /// Gets all the matches from this node's children
        /// </summary>
        /// <param name="segments">Requested route segments</param>
        /// <param name="currentIndex">Current index</param>
        /// <param name="capturedParameters">Currently captured parameters</param>
        /// <param name="localCaptures">Parameters captured by the local matching</param>
        /// <param name="context">Current Nancy context</param>
        /// <returns>Collection of <see cref="MatchResult"/> objects</returns>
        protected IEnumerable<MatchResult> GetMatchingChildren(string[] segments, int currentIndex, IDictionary<string, object> capturedParameters, IDictionary<string, object> localCaptures, NancyContext context)
        {
            var parameters = capturedParameters;
            if (localCaptures.Any() || this.AdditionalParameters.Any())
            {
                parameters = new Dictionary<string, object>(parameters);

                foreach (var localParameter in localCaptures)
                {
                    parameters[localParameter.Key] = localParameter.Value;
                }

                foreach (var additionalParameter in this.AdditionalParameters)
                {
                    parameters[additionalParameter.Key] = additionalParameter.Value;
                }
            }

            foreach (var childNode in this.Children.Values)
            {
                foreach (var match in childNode.GetMatches(segments, currentIndex, parameters, context))
                {
                    yield return match;
                }
            }
        }

        /// <summary>
        /// Matches the segment for a requested route
        /// </summary>
        /// <param name="segment">Segment string</param>
        /// <returns>A <see cref="SegmentMatch"/> instance representing the result of the match</returns>
        public abstract SegmentMatch Match(string segment);
    }
}
namespace Nancy.Routing.Trie
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Nodes;

    /// <summary>
    /// The default route resolution trie
    /// </summary>
    public class RouteResolverTrie : IRouteResolverTrie
    {
        private readonly ITrieNodeFactory nodeFactory;

        private readonly IDictionary<string, TrieNode> routeTries = new Dictionary<string, TrieNode>(StringComparer.OrdinalIgnoreCase);

        private static char[] splitSeparators = new[] { '/' };

        public RouteResolverTrie(ITrieNodeFactory nodeFactory)
        {
            this.nodeFactory = nodeFactory;
        }

        /// <summary>
        /// Build the trie from the route cache
        /// </summary>
        /// <param name="cache">The route cache</param>
        public void BuildTrie(IRouteCache cache)
        {
            foreach (var cacheItem in cache)
            {
                var moduleKey = cacheItem.Key;
                var routeDefinitions = cacheItem.Value;

                foreach (var routeDefinition in routeDefinitions)
                {
                    var routeIndex = routeDefinition.Item1;
                    var routeDescription = routeDefinition.Item2;

                    TrieNode trieNode;
                    if (!this.routeTries.TryGetValue(routeDescription.Method, out trieNode))
                    {
                        trieNode = this.nodeFactory.GetNodeForSegment(null, null);

                        this.routeTries.Add(routeDefinition.Item2.Method, trieNode);
                    }

                    var segments = routeDefinition.Item2.Segments.ToArray();

                    trieNode.Add(segments, moduleKey, routeIndex, routeDescription);
                }
            }
        }

        /// <summary>
        /// Get all matches for the given method and path
        /// </summary>
        /// <param name="method">HTTP method</param>
        /// <param name="path">Requested path</param>
        /// <param name="context">Current Nancy context</param>
        /// <returns>An array of <see cref="MatchResult"/> elements</returns>
        public MatchResult[] GetMatches(string method, string path, NancyContext context)
        {
            TrieNode result;

            if (!this.routeTries.TryGetValue(method, out result))
            {
                return MatchResult.NoMatches;
            }

            return result.GetMatches(path.Split(splitSeparators, StringSplitOptions.RemoveEmptyEntries), context)
                         .ToArray();
        }

        /// <summary>
        /// Get all method options for the given path
        /// </summary>
        /// <param name="path">Requested path</param>
        /// <param name="context">Current Nancy context</param>
        /// <returns>A collection of strings, each representing an allowed method</returns>
        public IEnumerable<string> GetOptions(string path, NancyContext context)
        {
            foreach (var method in this.routeTries.Keys)
            {
                if (this.GetMatches(method, path, context).Any())
                {
                    yield return method;
                }
            }
        }

        /// <summary>
        /// Returns a string that represents the current object.
        /// </summary>
        /// <returns>
        /// A string that represents the current object.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        public override string ToString()
        {
            var sb = new StringBuilder();

            foreach (var kvp in this.routeTries)
            {
                var method = kvp.Key;
                sb.Append(
                    kvp.Value.GetRoutes().Select(s => method + " " + s)
                             .Aggregate((r1, r2) => r1 + "\n" + r2));
            }

            return sb.ToString();
        }
    }
}
namespace Nancy.Routing.Trie
{
    using System.Collections.Generic;

    /// <summary>
    /// A segment match result
    /// </summary>
    public class SegmentMatch
    {
        private static SegmentMatch noMatch = new SegmentMatch(false);

        /// <summary>
        /// Gets a value indicating whether the match was successful or not
        /// </summary>
        public bool Matches { get; private set; }

        /// <summary>
        /// Gets a <see cref="SegmentMatch"/> representing "no match"
        /// </summary>
        public static SegmentMatch NoMatch { get { return noMatch; } }

        /// <summary>
        /// Gets the captured parameters from the match, if the match was successful
        /// </summary>
        public IDictionary<string, object> CapturedParameters { get; private set; }

        public SegmentMatch(bool matches)
        {
            this.Matches = matches;

            if (matches)
            {
                this.CapturedParameters = new Dictionary<string, object>();
            }
        }

    }
}
namespace Nancy.Routing.Trie
{
    using System.Collections.Generic;
    using System.Linq;

    using Nancy.Routing.Constraints;
    using Nancy.Routing.Trie.Nodes;

    /// <summary>
    /// Factory for creating the correct type of TrieNode
    /// </summary>
    public class TrieNodeFactory : ITrieNodeFactory
    {
        private readonly IEnumerable<IRouteSegmentConstraint> routeSegmentConstraints;

        public TrieNodeFactory(IEnumerable<IRouteSegmentConstraint> routeSegmentConstraints)
        {
            this.routeSegmentConstraints = routeSegmentConstraints;
        }

        /// <summary>
        /// Gets the correct Trie node type for the given segment
        /// </summary>
        /// <param name="parent">Parent node</param>
        /// <param name="segment">Segment</param>
        /// <returns>TrieNode instance</returns>
        public virtual TrieNode GetNodeForSegment(TrieNode parent, string segment)
        {
            if (parent == null)
            {
                return new RootNode(this);
            }

            var chars = segment.ToCharArray();
            var start = chars[0];
            var end = chars[chars.Length - 1];

            if (start == '(' && end == ')')
            {
                return new RegExNode(parent, segment, this);
            }

            if (start == '{' && end == '}' && chars.Count(c => c == '{' || c == '}') == 2)
            {
                return this.GetCaptureNode(parent, segment);
            }

            if (segment.StartsWith("^(") && (segment.EndsWith(")") || segment.EndsWith(")$")))
            {
                return new GreedyRegExCaptureNode(parent, segment, this);
            }

            if (CaptureNodeWithMultipleParameters.IsMatch(segment))
            {
                return new CaptureNodeWithMultipleParameters(parent, segment, this, routeSegmentConstraints);
            }

            return new LiteralNode(parent, segment, this);
        }

        private TrieNode GetCaptureNode(TrieNode parent, string segment)
        {
            if (segment.Contains(":"))
            {
                return new CaptureNodeWithConstraint(parent, segment, this, routeSegmentConstraints);
            }

            if (segment.EndsWith("?}"))
            {
                return new OptionalCaptureNode(parent, segment, this);
            }

            if (segment.EndsWith("*}"))
            {
                return new GreedyCaptureNode(parent, segment, this);
            }

            if (segment.Contains("?"))
            {
                return new CaptureNodeWithDefaultValue(parent, segment, this);
            }

            return new CaptureNode(parent, segment, this);
        }
    }
}
namespace Nancy
{
    using System;

    /// <summary>
    /// Default <see cref="TypeResolveStrategy"/> implementations.
    /// </summary>
    public class TypeResolveStrategies
    {
        /// <summary>
        /// Resolve types from all available locations.
        /// </summary>
        public static readonly TypeResolveStrategy All = type =>
        {
            return true;
        };

        /// <summary>
        /// Resolve types that are not located in the Nancy assembly.
        /// </summary>
        public static readonly TypeResolveStrategy ExcludeNancy = type =>
        {
            return !OnlyNancy.Invoke(type);
        };

        /// <summary>
        /// Resolve types that are not located in the Nancy namespace.
        /// </summary>
        public static readonly TypeResolveStrategy ExcludeNancyNamespace = type =>
        {
            return !OnlyNancyNamespace.Invoke(type);
        };

        /// <summary>
        /// Resolve types that are located in the Nancy assembly.
        /// </summary>
        public static readonly TypeResolveStrategy OnlyNancy = type =>
        {
            return type.Assembly.Equals(typeof(INancyEngine).Assembly);
        };

        /// <summary>
        /// Resolve types that are located in the Nancy namespace.
        /// </summary>
        public static readonly TypeResolveStrategy OnlyNancyNamespace = type =>
        {
            return (type.Namespace ?? string.Empty).StartsWith("Nancy", StringComparison.OrdinalIgnoreCase);
        };
    }
}
namespace Nancy
{
    using System;

    /// <summary>
    /// Predicate used to decide if a <see cref="Type"/> should be included when resolving types.
    /// </summary>
    /// <param name="type">The <see cref="Type"/> that is being inspected.</param>
    /// <value><see langword="true"/> if the type should be included in the result, otherwise <see langword="false"/>.</value>
    public delegate bool TypeResolveStrategy(Type type);
}
namespace Nancy.Security
{
    using System;
    using System.Linq;

    using Nancy.Bootstrapper;

    /// <summary>
    /// Allows a BeforeRequest hook to change Url to HTTPS if X-Forwarded-Proto header present
    /// </summary>
    public static class SSLProxy
    {
        /// <summary>
        /// Checks for Forwarded or X-Forwarded-Proto header and if so makes current url scheme https
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        public static void RewriteSchemeUsingForwardedHeaders(IPipelines pipelines)
        {
            pipelines.BeforeRequest += ctx =>
            {
                //X-Forwarded-Proto: https
                if (ctx.Request.Headers.Keys.Any(x => x.Equals("X-Forwarded-Proto", StringComparison.OrdinalIgnoreCase)))
                {
                    if (ctx.Request.Headers["X-Forwarded-Proto"].Contains("https", StringComparer.OrdinalIgnoreCase))
                    {
                        ctx.Request.Url.Scheme = "https";
                    }
                }

                //RFC7239
                if (ctx.Request.Headers.Keys.Any(x => x.Equals("Forwarded", StringComparison.OrdinalIgnoreCase)))
                {
                    var forwardedHeader = ctx.Request.Headers["Forwarded"];
                    var protoValue = forwardedHeader.FirstOrDefault(x => x.StartsWith("proto", StringComparison.OrdinalIgnoreCase));
                    if (protoValue != null && protoValue.Equals("proto=https", StringComparison.OrdinalIgnoreCase))
                    {
                        ctx.Request.Url.Scheme = "https";
                    }
                }

                return null;
            };
        }
    }
}
namespace Nancy.Session
{
    using Nancy.Cryptography;

    /// <summary>
    /// Configuration options for cookie based sessions
    /// </summary>
    public class CookieBasedSessionsConfiguration
    {
        internal const string DefaultCookieName = "_nc";

        /// <summary>
        /// Initializes a new instance of the <see cref="CookieBasedSessionsConfiguration"/> class.
        /// </summary>
        public CookieBasedSessionsConfiguration() : this(CryptographyConfiguration.Default)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CookieBasedSessionsConfiguration"/> class.
        /// </summary>
        public CookieBasedSessionsConfiguration(CryptographyConfiguration cryptographyConfiguration)
        {
            CryptographyConfiguration = cryptographyConfiguration;
            CookieName = DefaultCookieName;
        }

        /// <summary>
        /// Gets or sets the cryptography configuration
        /// </summary>
        public CryptographyConfiguration CryptographyConfiguration { get; set; }

        /// <summary>
        /// Formatter for de/serializing the session objects
        /// </summary>
        public IObjectSerializer Serializer { get; set; }

        /// <summary>
        /// Cookie name for storing session information
        /// </summary>
        public string CookieName { get; set; }

        /// <summary>
        /// Gets or sets the domain of the session cookie
        /// </summary>
        public string Domain { get; set; }

        /// <summary>
        /// Gets or sets the path of the session cookie
        /// </summary>
        public string Path { get; set; }

        /// <summary>
        /// Gets a value indicating whether the configuration is valid or not.
        /// </summary>
        public virtual bool IsValid
        {
            get
            {
                if (string.IsNullOrEmpty(this.CookieName))
                {
                    return false;
                }

                if (this.Serializer == null)
                {
                    return false;
                }

                if (this.CryptographyConfiguration == null)
                {
                    return false;
                }

                if (this.CryptographyConfiguration.EncryptionProvider == null)
                {
                    return false;
                }

                if (this.CryptographyConfiguration.HmacProvider == null)
                {
                    return false;
                }

                return true;
            }
        }
    }
}
namespace Nancy
{
    using System;
    using System.Linq;

    using Nancy.Bootstrapper;
    using Nancy.Conventions;

    /// <summary>
    /// Registers the static contents hook in the application pipeline at startup.
    /// </summary>
    public class StaticContent : IApplicationStartup
    {
        private static IRootPathProvider rootPathProvider;
        private static StaticContentsConventions conventions;

        /// <summary>
        /// Initializes a new instance of the <see cref="StaticContent"/> class, using the
        /// provided <paramref name="rootPathProvider"/> and <paramref name="conventions"/>.
        /// </summary>
        /// <param name="rootPathProvider">The current root path provider.</param>
        /// <param name="conventions">The static content conventions.</param>
        public StaticContent(IRootPathProvider rootPathProvider, StaticContentsConventions conventions)
        {
            StaticContent.rootPathProvider = rootPathProvider;
            StaticContent.conventions = conventions;
        }

        /// <summary>
        /// Perform any initialisation tasks
        /// </summary>
        public void Initialize(IPipelines pipelines)
        {
        }

        /// <summary>
        /// Enable "manual" static content.
        /// Only use this if you want to manually configure a pipeline hook to have static
        /// content server, for example, after authentication.
        /// </summary>
        /// <param name="pipelines">The pipelines to hook into</param>
        public static void Enable(IPipelines pipelines)
        {
            var item = new PipelineItem<Func<NancyContext, Response>>("Static content", ctx =>
            {
                return conventions
                    .Select(convention => convention.Invoke(ctx, rootPathProvider.GetRootPath()))
                    .FirstOrDefault(response => response != null);
            });

            pipelines.BeforeRequest.AddItemToStartOfPipeline(item);
        }
    }
}
namespace Nancy.Conventions
{
    using System;
    using System.Collections;
    using System.Collections.Generic;

    using Nancy.ViewEngines;

    /// <summary>
    /// This is a wrapper around the type
    /// <c>IEnumerable&lt;Func&lt;string, object, ViewLocationContext, string&gt;&gt;</c> and its
    /// only purpose is to make Ninject happy which was throwing an exception
    /// when constructor injecting this type.
    /// </summary>
    public class ViewLocationConventions : IEnumerable<Func<string, object, ViewLocationContext, string>>
    {
        private readonly IEnumerable<Func<string, object, ViewLocationContext, string>> conventions;

        public ViewLocationConventions(IEnumerable<Func<string, object, ViewLocationContext, string>> conventions)
        {
            this.conventions = conventions;
        }

        public IEnumerator<Func<string, object, ViewLocationContext, string>> GetEnumerator()
        {
            return conventions.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
namespace Nancy.Cryptography
{
    using System;

    public static class Base64Helpers
    {
        /// <summary>
        /// Calculates how long a byte array of X length will be after base64 encoding
        /// </summary>
        /// <param name="normalLength">The normal, 8bit per byte, length of the byte array</param>
        /// <returns>Base64 encoded length</returns>
        public static int GetBase64Length(int normalLength)
        {
            var inputPadding = (normalLength % 3 != 0) ? (3 - (normalLength % 3)) : 0;

            return (int)Math.Ceiling((normalLength + inputPadding) * 4.0 / 3.0);
        }
    }
}
namespace Nancy.Cryptography
{
    using System;

    /// <summary>
    /// Cryptographic setup for classes that use encryption and HMAC
    /// </summary>
    public class CryptographyConfiguration
    {
        private static readonly Lazy<CryptographyConfiguration> DefaultConfiguration =
            new Lazy<CryptographyConfiguration>(() => new CryptographyConfiguration(
                                                          new RijndaelEncryptionProvider(new RandomKeyGenerator()),
                                                          new DefaultHmacProvider(new RandomKeyGenerator())));

        private static readonly Lazy<CryptographyConfiguration> NoEncryptionConfiguration =
            new Lazy<CryptographyConfiguration>(() => new CryptographyConfiguration(
                                                          new NoEncryptionProvider(),
                                                          new DefaultHmacProvider(new RandomKeyGenerator())));

        /// <summary>
        /// Creates a new instance of the CryptographyConfiguration class
        /// </summary>
        /// <param name="encryptionProvider">Encryption provider</param>
        /// <param name="hmacProvider">HMAC provider</param>
        public CryptographyConfiguration(IEncryptionProvider encryptionProvider, IHmacProvider hmacProvider)
        {
            this.EncryptionProvider = encryptionProvider;
            this.HmacProvider = hmacProvider;
        }

        /// <summary>
        /// Gets the default configuration - Rijndael encryption, HMACSHA256 HMAC, random keys
        /// </summary>
        public static CryptographyConfiguration Default
        {
            get { return DefaultConfiguration.Value; }
        }

        /// <summary>
        /// Gets configuration with no encryption and HMACSHA256 HMAC with a random key
        /// </summary>
        public static CryptographyConfiguration NoEncryption
        {
            get { return NoEncryptionConfiguration.Value; }
        }

        /// <summary>
        /// Gets the encryption provider
        /// </summary>
        public IEncryptionProvider EncryptionProvider { get; private set; }

        /// <summary>
        /// Gets the hmac provider
        /// </summary>
        public IHmacProvider HmacProvider { get; private set; }
    }
}
namespace Nancy.Cryptography
{
    using System.Security.Cryptography;
    using System.Text;

    /// <summary>
    /// Provides SHA-256 HMACs
    /// </summary>
    public class DefaultHmacProvider : IHmacProvider
    {
        /// <summary>
        /// HMAC length
        /// </summary>
        private readonly int hmacLength = new HMACSHA256().HashSize / 8;

        /// <summary>
        /// Preferred key size for HMACSHA256
        /// </summary>
        private const int PreferredKeySize = 64;

        /// <summary>
        /// Key
        /// </summary>
        private readonly byte[] key;

        /// <summary>
        /// Creates a new instance of the DefaultHmacProvider type
        /// </summary>
        /// <param name="keyGenerator">Key generator to use to generate the key</param>
        public DefaultHmacProvider(IKeyGenerator keyGenerator)
        {
            this.key = keyGenerator.GetBytes(PreferredKeySize);
        }

        /// <summary>
        /// Gets the length of the HMAC signature
        /// </summary>
        public int HmacLength
        {
            get { return this.hmacLength; }
        }

        /// <summary>
        /// Create a hmac from the given data using the given passPhrase
        /// </summary>
        /// <param name="data">Data to create hmac from</param>
        /// <returns>String representation of the hmac</returns>
        public byte[] GenerateHmac(string data)
        {
            return this.GenerateHmac(Encoding.UTF8.GetBytes(data));
        }

        /// <summary>
        /// Create a hmac from the given data
        /// </summary>
        /// <param name="data">Data to create hmac from</param>
        /// <returns>Hmac bytes</returns>
        public byte[] GenerateHmac(byte[] data)
        {
            var hmacGenerator = new HMACSHA256(this.key);

            return hmacGenerator.ComputeHash(data);
        }
    }
}
namespace Nancy.Cryptography
{
    using System;
    using System.Runtime.CompilerServices;

    public static class HmacComparer
    {
        /// <summary>
        /// Compare two hmac byte arrays without any early exits
        /// </summary>
        /// <param name="hmac1">First hmac</param>
        /// <param name="hmac2">Second hmac</param>
        /// <param name="hashLength">Expected length of the hash</param>
        /// <returns>True if equal, false otherwise</returns>
        [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
        public static bool Compare(byte[] hmac1, byte[] hmac2, int hashLength)
        {
            var hasResized = false;

            if (hmac1.Length != hashLength)
            {
                Array.Resize(ref hmac1, hashLength);
                hasResized = true;
            }

            if (hmac2.Length != hashLength)
            {
                Array.Resize(ref hmac2, hashLength);
                hasResized = true;
            }

            var isValid = true;
            for (int i = 0; i < hashLength; i++)
            {
                if (hmac1[i] != hmac2[i])
                {
                    isValid = false;
                }
            }

            return hasResized ? false : isValid;
        }
    }
}
namespace Nancy.Cryptography
{
    /// <summary>
    /// Creates Hash-based Message Authentication Codes (HMACs)
    /// </summary>
    public interface IHmacProvider
    {
        /// <summary>
        /// Gets the length of the HMAC signature in bytes
        /// </summary>
        int HmacLength { get; }

        /// <summary>
        /// Create a hmac from the given data
        /// </summary>
        /// <param name="data">Data to create hmac from</param>
        /// <returns>Hmac bytes</returns>
        byte[] GenerateHmac(string data);

        /// <summary>
        /// Create a hmac from the given data
        /// </summary>
        /// <param name="data">Data to create hmac from</param>
        /// <returns>Hmac bytes</returns>
        byte[] GenerateHmac(byte[] data);
    }
}
namespace Nancy.Cryptography
{
    /// <summary>
    /// Provides key byte generation
    /// </summary>
    public interface IKeyGenerator
    {
        /// <summary>
        /// Generate a sequence of bytes
        /// </summary>
        /// <param name="count">Number of bytes to return</param>
        /// <returns>Array <see paramref="count"/> bytes</returns>
        byte[] GetBytes(int count);
    }
}
namespace Nancy.Cryptography
{
    using System;
    using System.Text;

    /// <summary>
    /// A "no op" encryption provider
    /// Useful for debugging or performance.
    /// </summary>
    public class NoEncryptionProvider : IEncryptionProvider
    {
        /// <summary>
        /// Encrypt data
        /// </summary>
        /// <param name="data">Data to encrypt</param>
        /// <returns>Encrypted string</returns>
        public string Encrypt(string data)
        {
            return Convert.ToBase64String(Encoding.UTF8.GetBytes(data));
        }

        /// <summary>
        /// Decrypt string
        /// </summary>
        /// <param name="data">Data to decrypt</param>
        /// <returns>Decrypted string</returns>
        public string Decrypt(string data)
        {
            return Encoding.UTF8.GetString(Convert.FromBase64String(data));
        }
    }
}
namespace Nancy.Cryptography
{
    using System;
    using System.Security.Cryptography;

    /// <summary>
    /// Provides key generation using PBKDF2 / Rfc2898
    /// NOTE: the salt is static so the passphrase should be long and complex
    /// (As the bytes are generated at app startup, because it's too slow to do per
    /// request, so the salt cannot be randomly generated and stored)
    /// </summary>
    public class PassphraseKeyGenerator : IKeyGenerator
    {
        private readonly Rfc2898DeriveBytes provider;

        /// <summary>
        /// Initializes a new instance of the <see cref="PassphraseKeyGenerator"/> class, with
        /// the provided <paramref name="passphrase"/>, <paramref name="salt"/> and optional
        /// number of <paramref name="iterations"/>
        /// </summary>
        /// <param name="passphrase">The passphrase that should be used.</param>
        /// <param name="salt">The salt</param>
        /// <param name="iterations">The number of iterations. The default value is 10000.</param>
        public PassphraseKeyGenerator(string passphrase, byte[] salt, int iterations = 10000)
        {
            if (salt.Length < 8)
            {
                throw new ArgumentOutOfRangeException("salt", "salt must be at least 8 bytes in length");
            }

            this.provider = new Rfc2898DeriveBytes(passphrase, salt, iterations);
        }

        /// <summary>
        /// Generate a sequence of bytes
        /// </summary>
        /// <param name="count">Number of bytes to return</param>
        /// <returns>Array <see paramref="count"/> bytes</returns>
        public byte[] GetBytes(int count)
        {
            return provider.GetBytes(count);
        }
    }
}
namespace Nancy.Cryptography
{
    using System.Security.Cryptography;

    /// <summary>
    /// Generates random secure keys using RNGCryptoServiceProvider
    /// </summary>
    public class RandomKeyGenerator : IKeyGenerator
    {
        private readonly RNGCryptoServiceProvider provider = new RNGCryptoServiceProvider();

        public byte[] GetBytes(int count)
        {
            var buffer = new byte[count];

            this.provider.GetBytes(buffer);

            return buffer;
        }
    }
}
namespace Nancy
{
    using Nancy.Configuration;
    using Nancy.Culture;
    using Nancy.Diagnostics;
    using Nancy.Localization;

    /// <summary>
    /// Creates NancyContext instances
    /// </summary>
    public class DefaultNancyContextFactory : INancyContextFactory
    {
        private readonly ICultureService cultureService;
        private readonly IRequestTraceFactory requestTraceFactory;
        private readonly ITextResource textResource;
        private readonly INancyEnvironment environment;

        /// <summary>
        /// Creates a new instance of the <see cref="DefaultNancyContextFactory"/> class.
        /// </summary>
        /// <param name="cultureService">An <see cref="ICultureService"/> instance.</param>
        /// <param name="requestTraceFactory">An <see cref="IRequestTraceFactory"/> instance.</param>
        /// <param name="textResource">An <see cref="ITextResource"/> instance.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public DefaultNancyContextFactory(ICultureService cultureService, IRequestTraceFactory requestTraceFactory, ITextResource textResource, INancyEnvironment environment)
        {
            this.cultureService = cultureService;
            this.requestTraceFactory = requestTraceFactory;
            this.textResource = textResource;
            this.environment = environment;
        }

        /// <summary>
        /// Create a new <see cref="NancyContext"/> instance.
        /// </summary>
        /// <returns>A <see cref="NancyContext"/> instance.</returns>
        public NancyContext Create(Request request)
        {
            var context =
                new NancyContext();

            context.Trace = this.requestTraceFactory.Create(request);
            context.Request = request;
            context.Culture = this.cultureService.DetermineCurrentCulture(context);
            context.Text = new TextResourceFinder(this.textResource, context);
            context.Environment = this.environment;

            // Move this to DefaultRequestTrace.
            context.Trace.TraceLog.WriteLog(s => s.AppendLine("New Request Started"));

            return context;
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Collections.Generic;

    public class RequestTraceSession
    {
        private const int MaxSize = 500;
        private readonly ConcurrentLimitedCollection<IRequestTrace> requestTraces;

        public RequestTraceSession(Guid id)
        {
            this.Id = id;
            this.requestTraces = new ConcurrentLimitedCollection<IRequestTrace>(MaxSize);
        }

        public Guid Id { get; private set; }

        public IEnumerable<IRequestTrace> RequestTraces
        {
            get
            {
                return this.requestTraces;
            }
        }

        public void AddRequestTrace(IRequestTrace trace)
        {
            this.requestTraces.Add(trace);
        }
    }
}
namespace Nancy.Diagnostics
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Defines the functionality for request tracing.
    /// </summary>
    public interface IRequestTracing
    {
        /// <summary>
        /// Adds the <see cref="IRequestTrace"/>, of the provided, <see cref="NancyContext"/> to the trace log.
        /// </summary>
        /// <param name="sessionId">The identifier of the trace.</param>
        /// <param name="context">A <see cref="NancyContext"/> instance.</param>
        void AddRequestDiagnosticToSession(Guid sessionId, NancyContext context);

        /// <summary>
        /// Clears the trace log.
        /// </summary>
        void Clear();

        /// <summary>
        /// Creates a new trace session.
        /// </summary>
        /// <returns>A <see cref="Guid"/> which represents the identifier of the new trace session.</returns>
        Guid CreateSession();

        /// <summary>
        /// Gets all the available <see cref="RequestTraceSession"/> instances.
        /// </summary>
        /// <returns></returns>
        IEnumerable<RequestTraceSession> GetSessions();

        /// <summary>
        /// Checks if the provided <paramref name="sessionId"/> is valid or not.
        /// </summary>
        /// <param name="sessionId">A <see cref="Guid"/> representing the session to check.</param>
        /// <returns><see langword="true"/> if the session is valid, otherwise <see langword="false"/>.</returns>
        bool IsValidSessionId(Guid sessionId);
    }
}
namespace Nancy.Diagnostics
{
    using System.Collections.Generic;

    /// <summary>
    /// The default implementation of the <see cref="IRequestTrace"/> interface.
    /// </summary>
    public class DefaultRequestTrace : IRequestTrace
    {
        /// <summary>
        /// Gets the generic item store.
        /// </summary>
        /// <value>An <see cref="IDictionary{TKey,TValue}"/> instance containing the items.</value>
        public IDictionary<string, object> Items { get; set; }

        /// <summary>
        /// Gets or sets the information about the request.
        /// </summary>
        /// <value>An <see cref="RequestData"/> instance.</value>
        public RequestData RequestData { get; set; }

        /// <summary>
        /// Gets or sets the information about the response.
        /// </summary>
        /// <value>An <see cref="ResponseData"/> instance.</value>
        public ResponseData ResponseData { get; set; }

        /// <summary>
        /// Gets or sets the trace log.
        /// </summary>
        /// <value>A <see cref="ITraceLog"/> instance.</value>
        public ITraceLog TraceLog { get; set; }
    }
}
namespace Nancy
{
    using System;
    using System.ComponentModel;
    using System.Dynamic;
    using System.Globalization;
    using System.Linq.Expressions;

    using Microsoft.CSharp.RuntimeBinder;
    using Nancy.Routing.Trie.Nodes;

    public class DynamicDictionaryValue : DynamicObject, IEquatable<DynamicDictionaryValue>, IHideObjectMembers, IConvertible
    {
        private readonly object value;

        /// <summary>
        /// Initializes a new instance of the <see cref="DynamicDictionaryValue"/> class.
        /// </summary>
        /// <param name="value">The value to store in the instance</param>
        public DynamicDictionaryValue(object value)
        {
            this.value = value;
        }

        /// <summary>
        /// Gets a value indicating whether this instance has value.
        /// </summary>
        /// <value><c>true</c> if this instance has value; otherwise, <c>false</c>.</value>
        /// <remarks><see langword="null"/> is considered as not being a value.</remarks>
        public bool HasValue
        {
            get { return (this.value != null); }
        }

        /// <summary>
        /// Gets the inner value
        /// </summary>
        public object Value
        {
            get { return this.value; }
        }

        /// <summary>
        /// Returns a default value if Value is null
        /// </summary>
        /// <typeparam name="T">When no default value is supplied, required to supply the default type</typeparam>
        /// <param name="defaultValue">Optional parameter for default value, if not given it returns default of type T</param>
        /// <returns>If value is not null, value is returned, else default value is returned</returns>
        public T Default<T>(T defaultValue = default(T))
        {
            if (this.HasValue)
            {
                try
                {
                    return (T)value;
                }
                catch
                {
                    var typeName = value.GetType().Name;
                    var message = string.Format("Cannot convert value of type '{0}' to type '{1}'",
                                                typeName, typeof(T).Name);

                    throw new InvalidCastException(message);
                }
            }

            return defaultValue;
        }

        /// <summary>
        /// Attempts to convert the value to type of T, failing to do so will return the defaultValue.
        /// </summary>
        /// <typeparam name="T">When no default value is supplied, required to supply the default type</typeparam>
        /// <param name="defaultValue">Optional parameter for default value, if not given it returns default of type T</param>
        /// <returns>If value is not null, value is returned, else default value is returned</returns>
        public T TryParse<T>(T defaultValue = default(T))
        {
            if (this.HasValue)
            {
                try
                {
                    var valueType = value.GetType();
                    var parseType = typeof(T);

                    // check for direct cast
                    if (valueType.IsAssignableFrom(parseType))
                    {
                        return (T)value;
                    }

                    var stringValue = value as string;
                    if (parseType == typeof(DateTime))
                    {
                        DateTime result;

                        if (DateTime.TryParse(stringValue, CultureInfo.InvariantCulture, DateTimeStyles.None, out result))
                        {
                            return (T)((object)result);
                        }

                        return defaultValue;
                    }

                    if (stringValue != null)
                    {
                        var converter = TypeDescriptor.GetConverter(parseType);

                        if (converter.IsValid(stringValue))
                        {
                            return (T)converter.ConvertFromInvariantString(stringValue);
                        }

                        return defaultValue;
                    }

                    var underlyingType = Nullable.GetUnderlyingType(parseType) ?? parseType;

                    return (T)Convert.ChangeType(value, underlyingType, CultureInfo.InvariantCulture);
                }
                catch
                {
                    return defaultValue;
                }
            }

            return defaultValue;
        }

        public static bool operator ==(DynamicDictionaryValue dynamicValue, object compareValue)
        {
            if (ReferenceEquals(null, dynamicValue))
            {
                return false;
            }

            if (dynamicValue.value == null && compareValue == null)
            {
                return true;
            }

            return dynamicValue.value != null && dynamicValue.value.Equals(compareValue);
        }

        public static bool operator !=(DynamicDictionaryValue dynamicValue, object compareValue)
        {
            return !(dynamicValue == compareValue);
        }

        /// <summary>
        /// Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <returns><c>true</c> if the current object is equal to the <paramref name="compareValue"/> parameter; otherwise, <c>false</c>.
        /// </returns>
        /// <param name="compareValue">An <see cref="DynamicDictionaryValue"/> to compare with this instance.</param>
        public bool Equals(DynamicDictionaryValue compareValue)
        {
            if (ReferenceEquals(null, compareValue))
            {
                return false;
            }

            return ReferenceEquals(this, compareValue) || Equals(compareValue.value, this.value);
        }

        /// <summary>
        /// Determines whether the specified <see cref="object"/> is equal to the current <see cref="object"/>.
        /// </summary>
        /// <returns><c>true</c> if the specified <see cref="object"/> is equal to the current <see cref="DynamicDictionaryValue"/>; otherwise, <c>false</c>.</returns>
        /// <param name="compareValue">The <see cref="object"/> to compare with the current <see cref="DynamicDictionaryValue"/>.</param>
        public override bool Equals(object compareValue)
        {
            if (ReferenceEquals(null, compareValue))
            {
                return false;
            }

            if (ReferenceEquals(this, compareValue))
            {
                return true;
            }

            return compareValue.GetType() == typeof(DynamicDictionaryValue) && this.Equals((DynamicDictionaryValue)compareValue);
        }

        /// <summary>
        /// Serves as a hash function for a particular type.
        /// </summary>
        /// <returns>A hash code for the current instance.</returns>
        public override int GetHashCode()
        {
            return (this.value != null ? this.value.GetHashCode() : 0);
        }

        /// <summary>
        /// Provides implementation for binary operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations such as addition and multiplication.
        /// </summary>
        /// <returns><c>true</c> if the operation is successful; otherwise, <c>false</c>. If this method returns <c>false</c>, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        /// <param name="binder">Provides information about the binary operation. The binder.Operation property returns an <see cref="T:System.Linq.Expressions.ExpressionType"/> object. For example, for the sum = first + second statement, where first and second are derived from the DynamicObject class, binder.Operation returns ExpressionType.Add.</param><param name="arg">The right operand for the binary operation. For example, for the sum = first + second statement, where first and second are derived from the DynamicObject class, <paramref name="arg"/> is equal to second.</param><param name="result">The result of the binary operation.</param>
        public override bool TryBinaryOperation(BinaryOperationBinder binder, object arg, out object result)
        {
            object resultOfCast;
            result = null;

            if (binder.Operation != ExpressionType.Equal)
            {
                return false;
            }

            var convert =
                Binder.Convert(CSharpBinderFlags.None, arg.GetType(), typeof(DynamicDictionaryValue));

            if (!TryConvert((ConvertBinder)convert, out resultOfCast))
            {
                return false;
            }

            result = (resultOfCast == null) ?
                Equals(arg, resultOfCast) :
                resultOfCast.Equals(arg);

            return true;
        }

        /// <summary>
        /// Provides implementation for type conversion operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations that convert an object from one type to another.
        /// </summary>
        /// <returns><c>true</c> if the operation is successful; otherwise, <c>false</c>. If this method returns <c>false</c>, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        /// <param name="binder">Provides information about the conversion operation. The binder.Type property provides the type to which the object must be converted. For example, for the statement (String)sampleObject in C# (CType(sampleObject, Type) in Visual Basic), where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, binder.Type returns the <see cref="T:System.String"/> type. The binder.Explicit property provides information about the kind of conversion that occurs. It returns true for explicit conversion and false for implicit conversion.</param><param name="result">The result of the type conversion operation.</param>
        public override bool TryConvert(ConvertBinder binder, out object result)
        {
            result = null;

            if (value == null)
            {
                return true;
            }

            var binderType = binder.Type;
            if (binderType == typeof(String))
            {
                result = Convert.ToString(value);
                return true;
            }

            if (binderType == typeof(Guid) || binderType == typeof(Guid?))
            {
                Guid guid;
                if (Guid.TryParse(Convert.ToString(value), out guid))
                {
                    result = guid;
                    return true;
                }
            }
            else if (binderType == typeof(TimeSpan) || binderType == typeof(TimeSpan?))
            {
                TimeSpan timespan;
                if (TimeSpan.TryParse(Convert.ToString(value), out timespan))
                {
                    result = timespan;
                    return true;
                }
            }
            else if (binderType.IsEnum)
            {
                // handles enum to enum assignments
                if (value.GetType().IsEnum)
                {
                    if (binderType == value.GetType())
                    {
                        result = value;
                        return true;
                    }

                    return false;
                }

                // handles number to enum assignments
                if (Enum.GetUnderlyingType(binderType) == value.GetType())
                {
                    result = Enum.ToObject(binderType, value);
                    return true;
                }

                return false;
            }
            else
            {
                if (binderType.IsGenericType && binderType.GetGenericTypeDefinition() == typeof(Nullable<>))
                {
                    binderType = binderType.GetGenericArguments()[0];
                }

                var typeCode = Type.GetTypeCode(binderType);

                if (typeCode == TypeCode.Object)
                {
                    if (binderType.IsAssignableFrom(value.GetType()))
                    {
                        result = value;
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

                result = Convert.ChangeType(value, typeCode);

                return true;
            }
            return base.TryConvert(binder, out result);
        }

        public override string ToString()
        {
            return this.value == null ? base.ToString() : Convert.ToString(this.value);
        }

        public static implicit operator bool? (DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(bool?);
            }

            return (bool)dynamicValue;
        }

        public static implicit operator bool(DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return false;
            }

            if (dynamicValue.value.GetType().IsValueType)
            {
                return (Convert.ToBoolean(dynamicValue.value));
            }

            bool result;
            if (bool.TryParse(dynamicValue.ToString(), out result))
            {
                return result;
            }

            return true;
        }

        public static implicit operator string(DynamicDictionaryValue dynamicValue)
        {
            return dynamicValue.HasValue
                       ? Convert.ToString(dynamicValue.value)
                       : null;
        }

        public static implicit operator int? (DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(int?);
            }

            return (int)dynamicValue;
        }

        public static implicit operator int(DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(int);
            }

            if (dynamicValue.value.GetType().IsValueType)
            {
                return Convert.ToInt32(dynamicValue.value);
            }

            return int.Parse(dynamicValue.ToString());
        }

        public static implicit operator Guid? (DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(Guid?);
            }

            return (Guid)dynamicValue;
        }

        public static implicit operator Guid(DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(Guid);
            }

            if (dynamicValue.value is Guid)
            {
                return (Guid)dynamicValue.value;
            }

            return Guid.Parse(dynamicValue.ToString());
        }

        public static implicit operator DateTime? (DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(DateTime?);
            }

            return (DateTime)dynamicValue;
        }

        public static implicit operator DateTime(DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(DateTime);
            }

            if (dynamicValue.value is DateTime)
            {
                return (DateTime)dynamicValue.value;
            }

            return DateTime.Parse(dynamicValue.ToString());
        }

        public static implicit operator TimeSpan? (DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(TimeSpan?);
            }

            return (TimeSpan)dynamicValue;
        }

        public static implicit operator TimeSpan(DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(TimeSpan);
            }

            if (dynamicValue.value is TimeSpan)
            {
                return (TimeSpan)dynamicValue.value;
            }

            return TimeSpan.Parse(dynamicValue.ToString());
        }

        public static implicit operator long? (DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(long?);
            }

            return (long)dynamicValue;
        }

        public static implicit operator long(DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(long);
            }

            if (dynamicValue.value.GetType().IsValueType)
            {
                return Convert.ToInt64(dynamicValue.value);
            }

            return long.Parse(dynamicValue.ToString());
        }

        public static implicit operator float? (DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(float?);
            }

            return (float)dynamicValue;
        }

        public static implicit operator float(DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(float);
            }

            if (dynamicValue.value.GetType().IsValueType)
            {
                return Convert.ToSingle(dynamicValue.value);
            }

            return float.Parse(dynamicValue.ToString());
        }

        public static implicit operator decimal? (DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(decimal?);
            }

            return (decimal)dynamicValue;
        }

        public static implicit operator decimal(DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(decimal);
            }

            if (dynamicValue.value.GetType().IsValueType)
            {
                return Convert.ToDecimal(dynamicValue.value);
            }

            return decimal.Parse(dynamicValue.ToString());
        }

        public static implicit operator double? (DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(double?);
            }

            return (double)dynamicValue;
        }

        public static implicit operator double(DynamicDictionaryValue dynamicValue)
        {
            if (!dynamicValue.HasValue)
            {
                return default(double);
            }

            if (dynamicValue.value.GetType().IsValueType)
            {
                return Convert.ToDouble(dynamicValue.value);
            }

            return double.Parse(dynamicValue.ToString());
        }

        #region Implementation of IConvertible

        /// <summary>
        /// Returns the <see cref="T:System.TypeCode"/> for this instance.
        /// </summary>
        /// <returns>
        /// The enumerated constant that is the <see cref="T:System.TypeCode"/> of the class or value type that implements this interface.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        public TypeCode GetTypeCode()
        {
            if (value == null) return TypeCode.Empty;
            return Type.GetTypeCode(value.GetType());
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent Boolean value using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// A Boolean value equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent Unicode character using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// A Unicode character equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent 8-bit signed integer using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// An 8-bit signed integer equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent 8-bit unsigned integer using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// An 8-bit unsigned integer equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent 16-bit signed integer using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// An 16-bit signed integer equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent 16-bit unsigned integer using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// An 16-bit unsigned integer equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent 32-bit signed integer using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// An 32-bit signed integer equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent 32-bit unsigned integer using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// An 32-bit unsigned integer equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent 64-bit signed integer using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// An 64-bit signed integer equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public long ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent 64-bit unsigned integer using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// An 64-bit unsigned integer equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent single-precision floating-point number using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// A single-precision floating-point number equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public float ToSingle(IFormatProvider provider)
        {
            return Convert.ToSingle(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent double-precision floating-point number using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// A double-precision floating-point number equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public double ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent <see cref="T:System.Decimal"/> number using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.Decimal"/> number equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public decimal ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent <see cref="T:System.DateTime"/> using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.DateTime"/> instance equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public DateTime ToDateTime(IFormatProvider provider)
        {
            return Convert.ToDateTime(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an equivalent <see cref="T:System.String"/> using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> instance equivalent to the value of this instance.
        /// </returns>
        /// <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public string ToString(IFormatProvider provider)
        {
            return Convert.ToString(value, provider);
        }

        /// <summary>
        /// Converts the value of this instance to an <see cref="T:System.Object"/> of the specified <see cref="T:System.Type"/> that has an equivalent value, using the specified culture-specific formatting information.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Object"/> instance of type <paramref name="conversionType"/> whose value is equivalent to the value of this instance.
        /// </returns>
        /// <param name="conversionType">The <see cref="T:System.Type"/> to which the value of this instance is converted. </param><param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(value, conversionType, provider);
        }

        #endregion
    }
}
namespace Nancy.ErrorHandling
{
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;
    using Nancy.Configuration;
    using Nancy.Extensions;
    using Nancy.IO;
    using Nancy.Responses.Negotiation;
    using Nancy.ViewEngines;

    /// <summary>
    /// Default error handler
    /// </summary>
    public class DefaultStatusCodeHandler : IStatusCodeHandler
    {
        private const string DisableErrorTracesTrueMessage = "Error details are currently disabled. Please set <code>StaticConfiguration.DisableErrorTraces = false;</code> to enable.";

        private readonly IDictionary<HttpStatusCode, string> errorMessages;
        private readonly IDictionary<HttpStatusCode, string> errorPages;
        private readonly IResponseNegotiator responseNegotiator;
        private readonly HttpStatusCode[] supportedStatusCodes = { HttpStatusCode.NotFound, HttpStatusCode.InternalServerError };
        private readonly TraceConfiguration configuration;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultStatusCodeHandler"/> type.
        /// </summary>
        /// <param name="responseNegotiator">The response negotiator.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public DefaultStatusCodeHandler(IResponseNegotiator responseNegotiator, INancyEnvironment environment)
        {
            this.errorMessages = new Dictionary<HttpStatusCode, string>
            {
                { HttpStatusCode.NotFound, "The resource you have requested cannot be found." },
                { HttpStatusCode.InternalServerError, "Something went horribly, horribly wrong while servicing your request." }
            };

            this.errorPages = new Dictionary<HttpStatusCode, string>
            {
                { HttpStatusCode.NotFound, LoadResource("404.html") },
                { HttpStatusCode.InternalServerError, LoadResource("500.html") }
            };

            this.responseNegotiator = responseNegotiator;
            this.configuration = environment.GetValue<TraceConfiguration>();
        }

        /// <summary>
        /// Whether the status code is handled
        /// </summary>
        /// <param name="statusCode">Status code</param>
        /// <param name="context">The <see cref="NancyContext"/> instance of the current request.</param>
        /// <returns>True if handled, false otherwise</returns>
        public bool HandlesStatusCode(HttpStatusCode statusCode, NancyContext context)
        {
            return this.supportedStatusCodes.Any(s => s == statusCode);
        }

        /// <summary>
        /// Handle the error code
        /// </summary>
        /// <param name="statusCode">Status code</param>
        /// <param name="context">The <see cref="NancyContext"/> instance of the current request.</param>
        /// <returns>Nancy Response</returns>
        public void Handle(HttpStatusCode statusCode, NancyContext context)
        {
            if (context.Response != null && context.Response.Contents != null && !ReferenceEquals(context.Response.Contents, Response.NoBody))
            {
                return;
            }

            if (!this.errorMessages.ContainsKey(statusCode) || !this.errorPages.ContainsKey(statusCode))
            {
                return;
            }

            Response existingResponse = null;

            if (context.Response != null)
            {
                existingResponse = context.Response;
            }

            // Reset negotiation context to avoid any downstream cast exceptions
            // from swapping a view model with a `DefaultStatusCodeHandlerResult`
            context.NegotiationContext = new NegotiationContext();

            var result = new DefaultStatusCodeHandlerResult(statusCode, this.errorMessages[statusCode], !this.configuration.DisplayErrorTraces ? DisableErrorTracesTrueMessage : context.GetExceptionDetails());
            try
            {
                context.Response = this.responseNegotiator.NegotiateResponse(result, context);
                context.Response.StatusCode = statusCode;

                if (existingResponse != null)
                {
                    context.Response.ReasonPhrase = existingResponse.ReasonPhrase;
                }
                return;
            }
            catch (ViewNotFoundException)
            {
                // No view will be found for `DefaultStatusCodeHandlerResult`
                // because it is rendered from embedded resources below
            }

            this.ModifyResponse(statusCode, context, result);
        }

        private void ModifyResponse(HttpStatusCode statusCode, NancyContext context, DefaultStatusCodeHandlerResult result)
        {
            if (context.Response == null)
            {
                context.Response = new Response { StatusCode = statusCode };
            }

            var contents = this.errorPages[statusCode];

            if (!string.IsNullOrEmpty(contents))
            {
                contents = contents.Replace("[DETAILS]", result.Details);
            }

            context.Response.ContentType = "text/html";
            context.Response.Contents = s =>
            {
                using (var writer = new StreamWriter(new UnclosableStreamWrapper(s), Encoding.UTF8))
                {
                    writer.Write(contents);
                }
            };
        }

        private static string LoadResource(string filename)
        {
            var resourceStream = typeof(INancyEngine).Assembly.GetManifestResourceStream(string.Format("Nancy.ErrorHandling.Resources.{0}", filename));

            if (resourceStream == null)
            {
                return string.Empty;
            }

            using (var reader = new StreamReader(resourceStream))
            {
                return reader.ReadToEnd();
            }
        }

        internal class DefaultStatusCodeHandlerResult
        {
            public DefaultStatusCodeHandlerResult(HttpStatusCode statusCode, string message, string details)
            {
                this.StatusCode = statusCode;
                this.Message = message;
                this.Details = details;
            }

            public HttpStatusCode StatusCode { get; private set; }

            public string Message { get; private set; }

            public string Details { get; private set; }
        }
    }
}
namespace Nancy.ErrorHandling
{
    /// <summary>
    /// Provides informative responses for particular HTTP status codes
    /// </summary>
    public interface IStatusCodeHandler
    {
        /// <summary>
        /// Check if the error handler can handle errors of the provided status code.
        /// </summary>
        /// <param name="statusCode">Status code</param>
        /// <param name="context">The <see cref="NancyContext"/> instance of the current request.</param>
        /// <returns>True if handled, false otherwise</returns>
        bool HandlesStatusCode(HttpStatusCode statusCode, NancyContext context);

        /// <summary>
        /// Handle the error code
        /// </summary>
        /// <param name="statusCode">Status code</param>
        /// <param name="context">Current context</param>
        void Handle(HttpStatusCode statusCode, NancyContext context);
    }
}
namespace Nancy
{
    using System;

    /// <summary>
    /// <para>
    /// A simple pipeline for on-error hooks.
    /// Hooks will be executed until either a hook returns a response, or every
    /// hook has been executed.
    /// </para>
    /// <para>
    /// Can be implictly cast to/from the on-error hook delegate signature
    /// (Func NancyContext, Exception, Response) for assigning to NancyEngine or for building
    /// composite pipelines.
    /// </para>
    /// </summary>
    public class ErrorPipeline : NamedPipelineBase<Func<NancyContext, Exception, dynamic>>
    {
        public ErrorPipeline()
        {
        }

        public ErrorPipeline(int capacity) : base(capacity)
        {
        }

        public static implicit operator Func<NancyContext, Exception, dynamic>(ErrorPipeline pipeline)
        {
            return pipeline.Invoke;
        }

        public static implicit operator ErrorPipeline(Func<NancyContext, Exception, dynamic> func)
        {
            var pipeline = new ErrorPipeline();
            pipeline.AddItemToEndOfPipeline(func);
            return pipeline;
        }

        public static ErrorPipeline operator +(ErrorPipeline pipeline, Func<NancyContext, Exception, dynamic> func)
        {
            pipeline.AddItemToEndOfPipeline(func);
            return pipeline;
        }

        public static ErrorPipeline operator +(ErrorPipeline pipelineToAddTo, ErrorPipeline pipelineToAdd)
        {
            foreach (var pipelineItem in pipelineToAdd.PipelineItems)
            {
                pipelineToAddTo.AddItemToEndOfPipeline(pipelineItem);
            }

            return pipelineToAddTo;
        }

        /// <summary>
        /// Invoke the pipeline. Each item will be invoked in turn until either an
        /// item returns a Response, or all items have been invoked.
        /// </summary>
        /// <param name="context">
        /// The current context to pass to the items.
        /// </param>
        /// <param name="ex">
        /// The exception currently being handled by the error pipeline
        /// </param>
        /// <returns>
        /// Response from an item invocation, or null if no response was generated.
        /// </returns>
        public dynamic Invoke(NancyContext context, Exception ex)
        {
            dynamic returnValue = null;

            using (var enumerator = this.PipelineDelegates.GetEnumerator())
            {
                while (returnValue == null && enumerator.MoveNext())
                {
                    returnValue = enumerator.Current.Invoke(context, ex);
                }
            }

            return returnValue;
        }
    }
}
namespace Nancy.Extensions
{
    using System;
    using System.IO;
    using System.Reflection;

    /// <summary>
    /// Assembly extension methods
    /// </summary>
    public static class AssemblyExtensions
    {
        /// <summary>
        /// Gets exported types from an assembly and catches common errors
        /// that occur when running under test runners.
        /// </summary>
        /// <param name="assembly">Assembly to retrieve from</param>
        /// <returns>An array of types</returns>
        public static Type[] SafeGetExportedTypes(this Assembly assembly)
        {
            Type[] types;

            try
            {
                types = assembly.GetExportedTypes();
            }
            catch (FileNotFoundException)
            {
                types = ArrayCache.Empty<Type>();
            }
            catch (NotSupportedException)
            {
                types = ArrayCache.Empty<Type>();
            }
            catch (FileLoadException)
            {
                // probably assembly version conflict
                types = ArrayCache.Empty<Type>();
            }
            return types;
        }
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using Nancy.Configuration;

    /// <summary>
    /// Bootstrapper for the Nancy Engine
    /// </summary>
    public interface INancyBootstrapper : IDisposable
    {
        /// <summary>
        /// Initialise the bootstrapper.
        /// </summary>
        /// <remarks>Must be called prior to <see cref="GetEngine"/> and <see cref="GetEnvironment"/>.</remarks>
        void Initialise();

        /// <summary>
        /// Gets the configured <see cref="INancyEngine"/>.
        /// </summary>
        /// <returns>An configured <see cref="INancyEngine"/> instance.</returns>
        /// <remarks>The boostrapper must be initialised (<see cref="Initialise"/>) prior to calling this.</remarks>
        INancyEngine GetEngine();

        /// <summary>
        /// Get the <see cref="INancyEnvironment"/> instance.
        /// </summary>
        /// <returns>An configured <see cref="INancyEnvironment"/> instance.</returns>
        /// <remarks>The boostrapper must be initialised (<see cref="Initialise"/>) prior to calling this.</remarks>
        INancyEnvironment GetEnvironment();
    }
}
namespace Nancy.Bootstrapper
{
    using System;

    public sealed class ModuleRegistration
    {
        /// <summary>
        /// Represents a module type for registration into a container
        /// </summary>
        /// <param name="moduleType">Type of the module</param>
        public ModuleRegistration(Type moduleType)
        {
            ModuleType = moduleType;
        }

        public Type ModuleType { get; private set; }
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Linq;

    using Nancy.Configuration;
    using Nancy.Conventions;
    using Nancy.Cryptography;
    using Nancy.Diagnostics;
    using Nancy.Extensions;
    using Nancy.ModelBinding;
    using Nancy.Validation;
    using Nancy.ViewEngines;

    /// <summary>
    /// Nancy bootstrapper base class
    /// </summary>
    /// <typeparam name="TContainer">IoC container type</typeparam>
    [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1623:PropertySummaryDocumentationMustMatchAccessors", Justification = "Abstract base class - properties are described differently for overriding.")]
    public abstract class NancyBootstrapperBase<TContainer> : INancyBootstrapper, INancyModuleCatalog, IDisposable
        where TContainer : class
    {
        /// <summary>
        /// Stores whether the bootstrapper has been initialised
        /// prior to calling GetEngine.
        /// </summary>
        private bool initialised;

        /// <summary>
        /// Stores whether the bootstrapper is in the process of
        /// being disposed.
        /// </summary>
        private bool disposing;

        /// <summary>
        /// Stores the <see cref="IRootPathProvider"/> used by Nancy
        /// </summary>
        private IRootPathProvider rootPathProvider;

        /// <summary>
        /// Default Nancy conventions
        /// </summary>
        private NancyConventions conventions;

        /// <summary>
        /// Internal configuration
        /// </summary>
        private Func<ITypeCatalog, NancyInternalConfiguration> internalConfigurationFactory;
        private NancyInternalConfiguration internalConfiguration;

        /// <summary>
        /// Application pipelines.
        /// Pipelines are "cloned" per request so they can be modified
        /// at the request level.
        /// </summary>
        protected IPipelines ApplicationPipelines { get; private set; }

        /// <summary>
        /// Nancy modules - built on startup from the app domain scanner
        /// </summary>
        private ModuleRegistration[] modules;

        /// <summary>
        /// Cache of request startup task types
        /// </summary>
        protected Type[] RequestStartupTaskTypeCache { get; private set; }

        private IAssemblyCatalog assemblyCatalog;
        private ITypeCatalog typeCatalog;

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyBootstrapperBase{TContainer}"/> class.
        /// </summary>
        protected NancyBootstrapperBase()
        {
            this.ApplicationPipelines = new Pipelines();
        }

        /// <summary>
        /// Gets the Container instance - automatically set during initialise.
        /// </summary>
        protected TContainer ApplicationContainer { get; private set; }

        /// <summary>
        /// Gets the <see cref="IAssemblyCatalog"/> that should be used by the application.
        /// </summary>
        /// <value>An <see cref="IAssemblyCatalog"/> instance.</value>
        protected virtual IAssemblyCatalog AssemblyCatalog
        {
            get
            {
                return this.assemblyCatalog ?? (
#if !DNX
                    this.assemblyCatalog = new AppDomainAssemblyCatalog()
#else
                    this.assemblyCatalog = new LibraryManagerAssemblyCatalog()
#endif
                );
            }
        }

        /// <summary>
        /// Gets the <see cref="ITypeCatalog"/> that should be used by the application.
        /// </summary>
        /// <value>An <see cref="ITypeCatalog"/> instance.</value>
        protected virtual ITypeCatalog TypeCatalog
        {
            get { return this.typeCatalog ?? (this.typeCatalog = new DefaultTypeCatalog(this.AssemblyCatalog)); }
        }

        /// <summary>
        /// Nancy internal configuration
        /// </summary>
        protected virtual Func<ITypeCatalog, NancyInternalConfiguration> InternalConfiguration
        {
            get { return this.internalConfigurationFactory ?? (this.internalConfigurationFactory = NancyInternalConfiguration.Default); }
        }

        /// <summary>
        /// Nancy conventions
        /// </summary>
        protected virtual NancyConventions Conventions
        {
            get
            {
                return this.conventions ?? (this.conventions = new NancyConventions(this.TypeCatalog));
            }
        }

        /// <summary>
        /// Gets all available module types
        /// </summary>
        protected virtual IEnumerable<ModuleRegistration> Modules
        {
            get
            {
                return this.modules ?? (this.modules = this.TypeCatalog
                    .GetTypesAssignableTo<INancyModule>(TypeResolveStrategies.ExcludeNancy)
                    .NotOfType<DiagnosticModule>()
                    .Select(t => new ModuleRegistration(t))
                    .ToArray());
            }
        }

        /// <summary>
        /// Gets the available view engine types
        /// </summary>
        protected virtual IEnumerable<Type> ViewEngines
        {
            get { return this.TypeCatalog.GetTypesAssignableTo<IViewEngine>(); }
        }

        /// <summary>
        /// Gets the available custom model binders
        /// </summary>
        protected virtual IEnumerable<Type> ModelBinders
        {
            get { return this.TypeCatalog.GetTypesAssignableTo<IModelBinder>(); }
        }

        /// <summary>
        /// Gets the available custom type converters
        /// </summary>
        protected virtual IEnumerable<Type> TypeConverters
        {
            get { return this.TypeCatalog.GetTypesAssignableTo<ITypeConverter>(TypeResolveStrategies.ExcludeNancy); }
        }

        /// <summary>
        /// Gets the available custom body deserializers
        /// </summary>
        protected virtual IEnumerable<Type> BodyDeserializers
        {
            get { return this.TypeCatalog.GetTypesAssignableTo<IBodyDeserializer>(TypeResolveStrategies.ExcludeNancy); }
        }

        /// <summary>
        /// Gets all application startup tasks
        /// </summary>
        protected virtual IEnumerable<Type> ApplicationStartupTasks
        {
            get { return this.TypeCatalog.GetTypesAssignableTo<IApplicationStartup>(); }
        }

        /// <summary>
        /// Gets all request startup tasks
        /// </summary>
        protected virtual IEnumerable<Type> RequestStartupTasks
        {
            get { return this.TypeCatalog.GetTypesAssignableTo<IRequestStartup>(); }
        }

        /// <summary>
        /// Gets all registration tasks
        /// </summary>
        protected virtual IEnumerable<Type> RegistrationTasks
        {
            get { return this.TypeCatalog.GetTypesAssignableTo<IRegistrations>(); }
        }

        /// <summary>
        /// Gets the root path provider
        /// </summary>
        protected virtual IRootPathProvider RootPathProvider
        {
            get { return this.rootPathProvider ?? (this.rootPathProvider = this.GetRootPathProvider()); }
        }

        /// <summary>
        /// Gets the validator factories.
        /// </summary>
        protected virtual IEnumerable<Type> ModelValidatorFactories
        {
            get { return this.TypeCatalog.GetTypesAssignableTo<IModelValidatorFactory>(); }
        }

        /// <summary>
        /// Gets the default favicon
        /// </summary>
        protected virtual byte[] FavIcon
        {
            get { return FavIconApplicationStartup.FavIcon; }
        }

        /// <summary>
        /// Gets the cryptography configuration
        /// </summary>
        protected virtual CryptographyConfiguration CryptographyConfiguration
        {
            get { return CryptographyConfiguration.Default; }
        }

        private NancyInternalConfiguration GetInitializedInternalConfiguration()
        {
            return this.internalConfiguration ?? (this.internalConfiguration = this.InternalConfiguration.Invoke(this.TypeCatalog));
        }

        /// <summary>
        /// Initialise the bootstrapper. Must be called prior to GetEngine.
        /// </summary>
        public void Initialise()
        {
            var configuration =
                this.GetInitializedInternalConfiguration();

            if (configuration == null)
            {
                throw new InvalidOperationException("Configuration cannot be null");
            }

            if (!configuration.IsValid)
            {
                throw new InvalidOperationException("Configuration is invalid");
            }

            this.ApplicationContainer = this.GetApplicationContainer();

            this.RegisterBootstrapperTypes(this.ApplicationContainer);

            this.ConfigureApplicationContainer(this.ApplicationContainer);

            var typeRegistrations = configuration
                .GetTypeRegistrations()
                .Concat(this.GetAdditionalTypes());

            var collectionTypeRegistrations = configuration
                .GetCollectionTypeRegistrations()
                .Concat(this.GetApplicationCollections());

            // TODO - should this be after initialiseinternal?
            this.ConfigureConventions(this.Conventions);
            var conventionValidationResult = this.Conventions.Validate();
            if (!conventionValidationResult.Item1)
            {
                throw new InvalidOperationException(string.Format("Conventions are invalid:\n\n{0}", conventionValidationResult.Item2));
            }

            var instanceRegistrations = this.Conventions.GetInstanceRegistrations()
                                            .Concat(this.GetAdditionalInstances());

            this.RegisterTypes(this.ApplicationContainer, typeRegistrations);
            this.RegisterCollectionTypes(this.ApplicationContainer, collectionTypeRegistrations);
            this.RegisterInstances(this.ApplicationContainer, instanceRegistrations);
            this.RegisterRegistrationTasks(this.GetRegistrationTasks());

            var environment = this.GetEnvironmentConfigurator().ConfigureEnvironment(this.Configure);
            this.RegisterNancyEnvironment(this.ApplicationContainer, environment);

            this.RegisterModules(this.ApplicationContainer, this.Modules);

            foreach (var applicationStartupTask in this.GetApplicationStartupTasks().ToList())
            {
                applicationStartupTask.Initialize(this.ApplicationPipelines);
            }

            this.ApplicationStartup(this.ApplicationContainer, this.ApplicationPipelines);

            this.RequestStartupTaskTypeCache = this.RequestStartupTasks.ToArray();

            if (this.FavIcon != null)
            {
                this.ApplicationPipelines.BeforeRequest.AddItemToStartOfPipeline(ctx =>
                {
                    if (ctx.Request == null || string.IsNullOrEmpty(ctx.Request.Path))
                    {
                        return null;
                    }

                    if (String.Equals(ctx.Request.Path, "/favicon.ico", StringComparison.InvariantCultureIgnoreCase))
                    {
                        var response = new Response
                        {
                            ContentType = "image/vnd.microsoft.icon",
                            StatusCode = HttpStatusCode.OK,
                            Contents = s => s.Write(this.FavIcon, 0, this.FavIcon.Length)
                        };

                        response.Headers["Cache-Control"] = "public, max-age=604800, must-revalidate";

                        return response;
                    }

                    return null;
                });
            }

            this.GetDiagnostics().Initialize(this.ApplicationPipelines);

            this.initialised = true;
        }

        /// <summary>
        /// Configures the Nancy environment
        /// </summary>
        /// <param name="environment">The <see cref="INancyEnvironment"/> instance to configure</param>
        public virtual void Configure(INancyEnvironment environment)
        {
        }

        /// <summary>
        /// Gets the <see cref="INancyEnvironmentConfigurator"/> used by th.
        /// </summary>
        /// <returns>An <see cref="INancyEnvironmentConfigurator"/> instance.</returns>
        protected abstract INancyEnvironmentConfigurator GetEnvironmentConfigurator();

        /// <summary>
        /// Gets the diagnostics for initialisation
        /// </summary>
        /// <returns>IDiagnostics implementation</returns>
        protected abstract IDiagnostics GetDiagnostics();

        /// <summary>
        /// Gets all registered application startup tasks
        /// </summary>
        /// <returns>An <see cref="IEnumerable{T}"/> instance containing <see cref="IApplicationStartup"/> instances.</returns>
        protected abstract IEnumerable<IApplicationStartup> GetApplicationStartupTasks();

        /// <summary>
        /// Registers and resolves all request startup tasks
        /// </summary>
        /// <param name="container">Container to use</param>
        /// <param name="requestStartupTypes">Types to register</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance containing <see cref="IRequestStartup"/> instances.</returns>
        protected abstract IEnumerable<IRequestStartup> RegisterAndGetRequestStartupTasks(TContainer container, Type[] requestStartupTypes);

        /// <summary>
        /// Gets all registered application registration tasks
        /// </summary>
        /// <returns>An <see cref="IEnumerable{T}"/> instance containing <see cref="IRegistrations"/> instances.</returns>
        protected abstract IEnumerable<IRegistrations> GetRegistrationTasks();

        /// <summary>
        /// Get all NancyModule implementation instances
        /// </summary>
        /// <param name="context">The current context</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance containing <see cref="INancyModule"/> instances.</returns>
        public abstract IEnumerable<INancyModule> GetAllModules(NancyContext context);

        /// <summary>
        /// Retrieves a specific <see cref="INancyModule"/> implementation - should be per-request lifetime
        /// </summary>
        /// <param name="moduleType">Module type</param>
        /// <param name="context">The current context</param>
        /// <returns>The <see cref="INancyModule"/> instance</returns>
        public abstract INancyModule GetModule(Type moduleType, NancyContext context);

        /// <summary>
        /// Gets the configured INancyEngine
        /// </summary>
        /// <returns>Configured INancyEngine</returns>
        public INancyEngine GetEngine()
        {
            if (!this.initialised)
            {
                throw new InvalidOperationException("Bootstrapper is not initialised. Call Initialise before GetEngine");
            }

            var engine = this.SafeGetNancyEngineInstance();

            engine.RequestPipelinesFactory = this.InitializeRequestPipelines;

            return engine;
        }

        /// <summary>
        /// Get the <see cref="INancyEnvironment"/> instance.
        /// </summary>
        /// <returns>An configured <see cref="INancyEnvironment"/> instance.</returns>
        /// <remarks>The boostrapper must be initialised (<see cref="INancyBootstrapper.Initialise"/>) prior to calling this.</remarks>
        public abstract INancyEnvironment GetEnvironment();

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        /// <filterpriority>2</filterpriority>
        public void Dispose()
        {
            // Prevent StackOverflowException if ApplicationContainer.Dispose re-triggers this Dispose
            if (this.disposing)
            {
                return;
            }

            // Only dispose if we're initialised, prevents possible issue with recursive disposing.
            if (!this.initialised)
            {
                return;
            }

            this.disposing = true;

            var container = this.ApplicationContainer as IDisposable;

            if (container != null)
            {
                try
                {
                    container.Dispose();
                }
                catch (ObjectDisposedException)
                {
                }
            }


            Dispose(true);
        }

        /// <summary>
        /// Hides Equals from the overrides list
        /// </summary>
        /// <param name="obj">Object to compare</param>
        /// <returns>Boolean indicating equality</returns>
        public override sealed bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        /// <summary>
        /// Hides GetHashCode from the overrides list
        /// </summary>
        /// <returns>Hash code integer</returns>
        public override sealed int GetHashCode()
        {
            return base.GetHashCode();
        }

        /// <summary>
        /// Creates and initializes the request pipelines.
        /// </summary>
        /// <param name="context">The <see cref="NancyContext"/> used by the request.</param>
        /// <returns>An <see cref="IPipelines"/> instance.</returns>
        protected virtual IPipelines InitializeRequestPipelines(NancyContext context)
        {
            var requestPipelines =
                new Pipelines(this.ApplicationPipelines);

            if (this.RequestStartupTaskTypeCache.Any())
            {
                var startupTasks = this.RegisterAndGetRequestStartupTasks(this.ApplicationContainer, this.RequestStartupTaskTypeCache);

                foreach (var requestStartup in startupTasks)
                {
                    requestStartup.Initialize(requestPipelines, context);
                }
            }

            this.RequestStartup(this.ApplicationContainer, requestPipelines, context);

            return requestPipelines;
        }

        /// <summary>
        /// Hides ToString from the overrides list
        /// </summary>
        /// <returns>String representation</returns>
        public override sealed string ToString()
        {
            return base.ToString();
        }

        /// <summary>
        /// Initialise the bootstrapper - can be used for adding pre/post hooks and
        /// any other initialisation tasks that aren't specifically container setup
        /// related
        /// </summary>
        /// <param name="container">Container instance for resolving types if required.</param>
        protected virtual void ApplicationStartup(TContainer container, IPipelines pipelines)
        {
        }

        /// <summary>
        /// Initialise the request - can be used for adding pre/post hooks and
        /// any other per-request initialisation tasks that aren't specifically container setup
        /// related
        /// </summary>
        /// <param name="container">Container</param>
        /// <param name="pipelines">Current pipelines</param>
        /// <param name="context">Current context</param>
        protected virtual void RequestStartup(TContainer container, IPipelines pipelines, NancyContext context)
        {
        }

        /// <summary>
        /// Configure the application level container with any additional registrations.
        /// </summary>
        /// <param name="existingContainer">Container instance</param>
        protected virtual void ConfigureApplicationContainer(TContainer existingContainer)
        {
        }

        /// <summary>
        /// Overrides/configures Nancy's conventions
        /// </summary>
        /// <param name="nancyConventions">Convention object instance</param>
        protected virtual void ConfigureConventions(NancyConventions nancyConventions)
        {
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources.
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
        }

        /// <summary>
        /// Resolve INancyEngine
        /// </summary>
        /// <returns>INancyEngine implementation</returns>
        protected abstract INancyEngine GetEngineInternal();

        /// <summary>
        /// Gets the application level container
        /// </summary>
        /// <returns>Container instance</returns>
        protected abstract TContainer GetApplicationContainer();

        /// <summary>
        /// Registers an <see cref="INancyEnvironment"/> instance in the container.
        /// </summary>
        /// <param name="container">The container to register into.</param>
        /// <param name="environment">The <see cref="INancyEnvironment"/> instance to register.</param>
        protected abstract void RegisterNancyEnvironment(TContainer container, INancyEnvironment environment);

        /// <summary>
        /// Register the bootstrapper's implemented types into the container.
        /// This is necessary so a user can pass in a populated container but not have
        /// to take the responsibility of registering things like INancyModuleCatalog manually.
        /// </summary>
        /// <param name="applicationContainer">Application container to register into</param>
        protected abstract void RegisterBootstrapperTypes(TContainer applicationContainer);

        /// <summary>
        /// Register the default implementations of internally used types into the container as singletons
        /// </summary>
        /// <param name="container">Container to register into</param>
        /// <param name="typeRegistrations">Type registrations to register</param>
        protected abstract void RegisterTypes(TContainer container, IEnumerable<TypeRegistration> typeRegistrations);

        /// <summary>
        /// Register the various collections into the container as singletons to later be resolved
        /// by IEnumerable{Type} constructor dependencies.
        /// </summary>
        /// <param name="container">Container to register into</param>
        /// <param name="collectionTypeRegistrationsn">Collection type registrations to register</param>
        protected abstract void RegisterCollectionTypes(TContainer container, IEnumerable<CollectionTypeRegistration> collectionTypeRegistrationsn);

        /// <summary>
        /// Register the given module types into the container
        /// </summary>
        /// <param name="container">Container to register into</param>
        /// <param name="moduleRegistrationTypes">NancyModule types</param>
        protected abstract void RegisterModules(TContainer container, IEnumerable<ModuleRegistration> moduleRegistrationTypes);

        /// <summary>
        /// Register the given instances into the container
        /// </summary>
        /// <param name="container">Container to register into</param>
        /// <param name="instanceRegistrations">Instance registration types</param>
        protected abstract void RegisterInstances(TContainer container, IEnumerable<InstanceRegistration> instanceRegistrations);

        /// <summary>
        /// Gets additional required type registrations
        /// that don't form part of the core Nancy configuration
        /// </summary>
        /// <returns>Collection of TypeRegistration types</returns>
        private IEnumerable<TypeRegistration> GetAdditionalTypes()
        {
            return new[] {
                new TypeRegistration(typeof(IViewRenderer), typeof(DefaultViewRenderer)),
            };
        }

        /// <summary>
        /// Gets any additional instance registrations that need to
        /// be registered into the container
        /// </summary>
        /// <returns>Collection of InstanceRegistration types</returns>
        private IEnumerable<InstanceRegistration> GetAdditionalInstances()
        {
            return new[] {
                new InstanceRegistration(typeof(CryptographyConfiguration), this.CryptographyConfiguration),
                new InstanceRegistration(typeof(NancyInternalConfiguration), this.GetInitializedInternalConfiguration()),
                new InstanceRegistration(typeof(IRootPathProvider), this.RootPathProvider),
                new InstanceRegistration(typeof(IAssemblyCatalog), this.AssemblyCatalog),
                new InstanceRegistration(typeof(ITypeCatalog), this.TypeCatalog),
            };
        }

        /// <summary>
        /// Creates a list of types for the collection types that are
        /// required to be registered in the application scope.
        /// </summary>
        /// <returns>Collection of CollectionTypeRegistration types</returns>
        private IEnumerable<CollectionTypeRegistration> GetApplicationCollections()
        {
            return new[] {
                new CollectionTypeRegistration(typeof(IViewEngine), this.ViewEngines),
                new CollectionTypeRegistration(typeof(IModelBinder), this.ModelBinders),
                new CollectionTypeRegistration(typeof(ITypeConverter), this.TypeConverters),
                new CollectionTypeRegistration(typeof(IBodyDeserializer), this.BodyDeserializers),
                new CollectionTypeRegistration(typeof(IApplicationStartup), this.ApplicationStartupTasks),
                new CollectionTypeRegistration(typeof(IRegistrations), this.RegistrationTasks),
                new CollectionTypeRegistration(typeof(IModelValidatorFactory), this.ModelValidatorFactories)
            };
        }

        private INancyEngine SafeGetNancyEngineInstance()
        {
            try
            {
                return this.GetEngineInternal();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(
                    "Something went wrong when trying to satisfy one of the dependencies during composition, make sure that you've registered all new dependencies in the container and inspect the innerexception for more details.",
                    ex);
            }
        }

        /// <summary>
        /// Takes the registration tasks and calls the relevant methods to register them
        /// </summary>
        /// <param name="registrationTasks">Registration tasks</param>
        protected virtual void RegisterRegistrationTasks(IEnumerable<IRegistrations> registrationTasks)
        {
            foreach (var registrationTask in registrationTasks.ToList())
            {
                var applicationTypeRegistrations = registrationTask.TypeRegistrations;

                if (applicationTypeRegistrations != null)
                {
                    this.RegisterTypes(this.ApplicationContainer, applicationTypeRegistrations);
                }

                var applicationCollectionRegistrations = registrationTask.CollectionTypeRegistrations;

                if (applicationCollectionRegistrations != null)
                {
                    this.RegisterCollectionTypes(this.ApplicationContainer, applicationCollectionRegistrations);
                }

                var applicationInstanceRegistrations = registrationTask.InstanceRegistrations;

                if (applicationInstanceRegistrations != null)
                {
                    this.RegisterInstances(this.ApplicationContainer, applicationInstanceRegistrations);
                }
            }
        }

        private IRootPathProvider GetRootPathProvider()
        {
            var providerTypes = this.TypeCatalog
                .GetTypesAssignableTo<IRootPathProvider>(TypeResolveStrategies.ExcludeNancy)
                .ToArray();

            if (providerTypes.Length > 1)
            {
                throw new MultipleRootPathProvidersLocatedException(providerTypes);
            }

            var providerType =
                providerTypes.SingleOrDefault() ?? typeof(DefaultRootPathProvider);

            return Activator.CreateInstance(providerType) as IRootPathProvider;
        }
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using Nancy.Extensions;

    /// <summary>
    /// Class for locating an INancyBootstrapper implementation.
    ///
    /// Will search the app domain for a non-abstract one, and if it can't find one
    /// it will use the default nancy one that uses TinyIoC.
    /// </summary>
    public static class NancyBootstrapperLocator
    {
        private static INancyBootstrapper instance;
        private static readonly AssemblyName NancyAssemblyName = typeof(INancyEngine).GetTypeInfo().Assembly.GetName();

        /// <summary>
        /// Gets the located bootstrapper
        /// </summary>
        public static INancyBootstrapper Bootstrapper
        {
            get { return instance ?? (instance = LocateBootstrapper()); }
            set { instance = value; }
        }

        private static INancyBootstrapper LocateBootstrapper()
        {
            var bootstrapperType = GetBootstrapperType();

            try
            {
                return Activator.CreateInstance(bootstrapperType) as INancyBootstrapper;
            }
            catch (Exception ex)
            {
                var errorMessage = string.Format("Could not initialize bootstrapper of type '{0}'.", bootstrapperType.FullName);
                throw new BootstrapperException(errorMessage, ex);
            }
        }

        private static IReadOnlyCollection<Type> GetAvailableBootstrapperTypes()
        {
            var assemblies = GetNancyReferencingAssemblies()
                .Where(x => !x.IsDynamic && !x.ReflectionOnly)
                .ToArray();

            return assemblies
                .SelectMany(x => x.SafeGetExportedTypes())
                .Where(x => !x.IsAbstract && x.IsPublic)
                .Where(x => typeof(INancyBootstrapper).IsAssignableFrom(x))
                .ToArray();
        }

        private static IEnumerable<Assembly> GetNancyReferencingAssemblies()
        {
#if DNX
            var libraryManager = Microsoft.Extensions.PlatformAbstractions.PlatformServices.Default.LibraryManager;

            var results = new HashSet<Assembly>
            {
                typeof (INancyEngine).Assembly
            };

            var referencingLibraries = libraryManager.GetReferencingLibraries(NancyAssemblyName.Name);

            foreach (var assemblyName in referencingLibraries.SelectMany(referencingLibrary => referencingLibrary.Assemblies))
            {
                try
                {
                    results.Add(Assembly.Load(assemblyName));
                }
                catch
                {
                }
            }

            return results.ToArray();
#else
            return AppDomain.CurrentDomain.GetAssemblies().Where(IsNancyReferencing);
#endif
        }

#if !DNX
        private static bool IsNancyReferencing(Assembly assembly)
        {
            if (AssemblyName.ReferenceMatchesDefinition(assembly.GetName(), NancyAssemblyName))
            {
                return true;
            }

            foreach (var referencedAssemblyName in assembly.GetReferencedAssemblies())
            {
                if (AssemblyName.ReferenceMatchesDefinition(referencedAssemblyName, NancyAssemblyName))
                {
                    return true;
                }
            }

            return false;
        }
#endif

        private static Type GetBootstrapperType()
        {
            var customBootstrappers = GetAvailableBootstrapperTypes();

            if (!customBootstrappers.Any())
            {
                return typeof(DefaultNancyBootstrapper);
            }

            if (customBootstrappers.Count == 1)
            {
                return customBootstrappers.Single();
            }

            Type bootstrapper;
            if (TryFindMostDerivedType(customBootstrappers, out bootstrapper))
            {
                return bootstrapper;
            }

            var errorMessage = GetMultipleBootstrappersMessage(customBootstrappers);

            throw new BootstrapperException(errorMessage);
        }

        internal static bool TryFindMostDerivedType(IReadOnlyCollection<Type> customBootstrappers, out Type bootstrapper)
        {
            var set = new HashSet<Type>();
            bootstrapper = null;

            if (customBootstrappers.All(b => set.Add(b.BaseType)))
            {
                var except = customBootstrappers.Except(set).ToList();
                bootstrapper = except.Count == 1 ? except[0] : null;
            }

            return bootstrapper != null;
        }

        private static string GetMultipleBootstrappersMessage(IEnumerable<Type> customBootstrappers)
        {
            var bootstrapperNames = customBootstrappers.Select(x => string.Concat(" - ", x.FullName));

            var bootstrapperList = string.Join(Environment.NewLine, bootstrapperNames);

            return string.Join(Environment.NewLine, new[]
            {
                "Located multiple bootstrappers:",
                bootstrapperList,
                string.Empty,
                "Either remove unused bootstrapper types or specify which type to use."
            });
        }
    }
}
namespace Nancy.Bootstrapper
{
    using System;

    /// <summary>
    /// Represents a type to be registered into the container
    /// </summary>
    public sealed class TypeRegistration : ContainerRegistration
    {
        /// <summary>
        /// Represents a type to be registered into the container
        /// </summary>
        /// <param name="registrationType">Registration type i.e. IMyInterface</param>
        /// <param name="implementationType">Implementation type i.e. MyClassThatImplementsIMyInterface</param>
        /// <param name="lifetime">Lifetime to register the type as</param>
        public TypeRegistration(Type registrationType, Type implementationType, Lifetime lifetime = Lifetime.Singleton)
        {
            if (registrationType == null)
            {
                throw new ArgumentNullException("registrationType");
            }

            if (implementationType == null)
            {
                throw new ArgumentNullException("implementationType");
            }

            this.RegistrationType = registrationType;
            this.ImplementationType = implementationType;
            this.Lifetime = lifetime;

            this.ValidateTypeCompatibility(implementationType);
        }

        /// <summary>
        /// Implementation type i.e. MyClassThatImplementsIMyInterface
        /// </summary>
        public Type ImplementationType { get; private set; }
    }
}
namespace Nancy.Cookies
{
    using System;
    using System.Globalization;
    using System.Text;

    using Nancy.Helpers;

    /// <summary>
    /// Default cookie implementation for Nancy.
    /// </summary>
    public class NancyCookie : INancyCookie
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NancyCookie"/> class.
        /// </summary>
        /// <param name="name">The name of the cookie.</param>
        /// <param name="value">The value of the cookie.</param>
        public NancyCookie(string name, string value)
            : this(name, value, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyCookie"/> class.
        /// </summary>
        /// <param name="name">The name of the cookie.</param>
        /// <param name="value">The value of the cookie.</param>
        /// <param name="expires">The expiration date of the cookie. Can be <see langword="null" /> if it should expire at the end of the session.</param>
        public NancyCookie(string name, string value, DateTime expires)
            : this(name, value, false, false, expires)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyCookie"/> class.
        /// </summary>
        /// <param name="name">The name of the cookie.</param>
        /// <param name="value">The value of the cookie.</param>
        /// <param name="httpOnly">Whether the cookie is http only.</param>
        public NancyCookie(string name, string value, bool httpOnly)
            : this(name, value, httpOnly, false, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyCookie"/> class.
        /// </summary>
        /// <param name="name">The name of the cookie.</param>
        /// <param name="value">The value of the cookie.</param>
        /// <param name="httpOnly">Whether the cookie is http only.</param>
        /// <param name="secure">Whether the cookie is secure (i.e. HTTPS only).</param>
        public NancyCookie(string name, string value, bool httpOnly, bool secure)
            : this(name, value, httpOnly, secure, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyCookie"/> class.
        /// </summary>
        /// <param name="name">The name of the cookie.</param>
        /// <param name="value">The value of the cookie.</param>
        /// <param name="httpOnly">Whether the cookie is http only.</param>
        /// <param name="secure">Whether the cookie is secure (i.e. HTTPS only).</param>
        /// <param name="expires">The expiration date of the cookie. Can be <see langword="null" /> if it should expire at the end of the session.</param>
        public NancyCookie(string name, string value, bool httpOnly, bool secure, DateTime? expires)
        {
            this.Name = name;
            this.Value = value;
            this.HttpOnly = httpOnly;
            this.Secure = secure;
            this.Expires = expires;
        }

        /// <summary>
        /// The domain to restrict the cookie to
        /// </summary>
        public string Domain { get; set; }

        /// <summary>
        /// When the cookie should expire
        /// </summary>
        /// <value>A <see cref="DateTime"/> instance containing the date and time when the cookie should expire; otherwise <see langword="null"/> if it should expire at the end of the session.</value>
        public DateTime? Expires { get; set; }

        /// <summary>
        /// The name of the cookie
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Gets the encoded name of the cookie
        /// </summary>
        public string EncodedName
        {
            get
            {
                return HttpUtility.UrlEncode(this.Name);
            }
        }

        /// <summary>
        /// The path to restrict the cookie to
        /// </summary>
        public string Path { get; set; }

        /// <summary>
        /// The value of the cookie
        /// </summary>
        public string Value { get; private set; }

        /// <summary>
        /// Gets the encoded value of the cookie
        /// </summary>
        public string EncodedValue
        {
            get
            {
                return HttpUtility.UrlEncode(this.Value);
            }
        }

        /// <summary>
        /// Whether the cookie is http only
        /// </summary>
        public bool HttpOnly { get; private set; }

        /// <summary>
        /// Whether the cookie is secure (i.e. HTTPS only)
        /// </summary>
        public bool Secure { get; private set; }

        public override string ToString()
        {
            var sb = new StringBuilder(50);
            sb.AppendFormat("{0}={1}; path={2}", this.EncodedName, this.EncodedValue, Path ?? "/");

            if (Expires != null)
            {
                sb.Append("; expires=");
                sb.Append(Expires.Value.ToUniversalTime().ToString("ddd, dd-MMM-yyyy HH:mm:ss", DateTimeFormatInfo.InvariantInfo));
                sb.Append(" GMT");
            }

            if (Domain != null)
            {
                sb.Append("; domain=");
                sb.Append(Domain);
            }

            if (Secure)
            {
                sb.Append("; Secure");
            }

            if (HttpOnly)
            {
                sb.Append("; HttpOnly");
            }

            return sb.ToString();
        }
    }
}
namespace Nancy.Cookies
{
    using System;

    public interface INancyCookie
    {
        /// <summary>
        /// The domain to restrict the cookie to
        /// </summary>
        string Domain { get; set; }

        /// <summary>
        /// When the cookie should expire
        /// </summary>
        /// <value>A <see cref="DateTime"/> instance containing the date and time when the cookie should expire; otherwise <see langword="null"/> if it should expire at the end of the session.</value>
        DateTime? Expires { get; set; }

        /// <summary>
        /// The name of the cookie
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Gets the encoded name of the cookie
        /// </summary>
        string EncodedName { get; }

        /// <summary>
        /// The path to restrict the cookie to
        /// </summary>
        string Path { get; set; }

        /// <summary>
        /// The value of the cookie
        /// </summary>
        string Value { get; }

        /// <summary>
        /// Gets the encoded value of the cookie
        /// </summary>
        string EncodedValue { get; }

        /// <summary>
        /// Whether the cookie is http only
        /// </summary>
        bool HttpOnly { get; }

        /// <summary>
        /// Whether the cookie is secure (i.e. HTTPS only)
        /// </summary>
        bool Secure { get; }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using Nancy.Bootstrapper;
    using Nancy.Configuration;
    using Nancy.Diagnostics;
    using Nancy.TinyIoc;

    /// <summary>
    /// TinyIoC bootstrapper - registers default route resolver and registers itself as
    /// INancyModuleCatalog for resolving modules but behavior can be overridden if required.
    /// </summary>
    public class DefaultNancyBootstrapper : NancyBootstrapperWithRequestContainerBase<TinyIoCContainer>
    {
        /// <summary>
        /// Default assemblies that are ignored for autoregister
        /// </summary>
        public static IEnumerable<Func<Assembly, bool>> DefaultAutoRegisterIgnoredAssemblies = new Func<Assembly, bool>[]
            {
                asm => asm.FullName.StartsWith("Microsoft.", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("System.", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("System,", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("CR_ExtUnitTest", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("mscorlib,", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("CR_VSTest", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("DevExpress.CodeRush", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("IronPython", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("IronRuby", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("xunit", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("Nancy.Testing", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("MonoDevelop.NUnit", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("SMDiagnostics", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("CppCodeProvider", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("WebDev.WebHost40", StringComparison.Ordinal),
            };

        /// <summary>
        /// Gets the assemblies to ignore when autoregistering the application container
        /// Return true from the delegate to ignore that particular assembly, returning false
        /// does not mean the assembly *will* be included, a true from another delegate will
        /// take precedence.
        /// </summary>
        protected virtual IEnumerable<Func<Assembly, bool>> AutoRegisterIgnoredAssemblies
        {
            get { return DefaultAutoRegisterIgnoredAssemblies; }
        }

        /// <summary>
        /// Configures the container using AutoRegister followed by registration
        /// of default INancyModuleCatalog and IRouteResolver.
        /// </summary>
        /// <param name="container">Container instance</param>
        protected override void ConfigureApplicationContainer(TinyIoCContainer container)
        {
            AutoRegister(container, this.AutoRegisterIgnoredAssemblies);
        }

        /// <summary>
        /// Resolve INancyEngine
        /// </summary>
        /// <returns>INancyEngine implementation</returns>
        protected override sealed INancyEngine GetEngineInternal()
        {
            return this.ApplicationContainer.Resolve<INancyEngine>();
        }

        /// <summary>
        /// Create a default, unconfigured, container
        /// </summary>
        /// <returns>Container instance</returns>
        protected override TinyIoCContainer GetApplicationContainer()
        {
            return new TinyIoCContainer();
        }

        /// <summary>
        /// Registers an <see cref="INancyEnvironment"/> instance in the container.
        /// </summary>
        /// <param name="container">The container to register into.</param>
        /// <param name="environment">The <see cref="INancyEnvironment"/> instance to register.</param>
        protected override void RegisterNancyEnvironment(TinyIoCContainer container, INancyEnvironment environment)
        {
            container.Register(environment);
        }

        /// <summary>
        /// Register the bootstrapper's implemented types into the container.
        /// This is necessary so a user can pass in a populated container but not have
        /// to take the responsibility of registering things like INancyModuleCatalog manually.
        /// </summary>
        /// <param name="applicationContainer">Application container to register into</param>
        protected override sealed void RegisterBootstrapperTypes(TinyIoCContainer applicationContainer)
        {
            applicationContainer.Register<INancyModuleCatalog>(this);
        }

        /// <summary>
        /// Register the default implementations of internally used types into the container as singletons
        /// </summary>
        /// <param name="container">Container to register into</param>
        /// <param name="typeRegistrations">Type registrations to register</param>
        protected override sealed void RegisterTypes(TinyIoCContainer container, IEnumerable<TypeRegistration> typeRegistrations)
        {
            foreach (var typeRegistration in typeRegistrations)
            {
                switch (typeRegistration.Lifetime)
                {
                    case Lifetime.Transient:
                        container.Register(typeRegistration.RegistrationType, typeRegistration.ImplementationType).AsMultiInstance();
                        break;
                    case Lifetime.Singleton:
                        container.Register(typeRegistration.RegistrationType, typeRegistration.ImplementationType).AsSingleton();
                        break;
                    case Lifetime.PerRequest:
                        throw new InvalidOperationException("Unable to directly register a per request lifetime.");
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        /// <summary>
        /// Register the various collections into the container as singletons to later be resolved
        /// by IEnumerable{Type} constructor dependencies.
        /// </summary>
        /// <param name="container">Container to register into</param>
        /// <param name="collectionTypeRegistrations">Collection type registrations to register</param>
        protected override sealed void RegisterCollectionTypes(TinyIoCContainer container, IEnumerable<CollectionTypeRegistration> collectionTypeRegistrations)
        {
            foreach (var collectionTypeRegistration in collectionTypeRegistrations)
            {
                switch (collectionTypeRegistration.Lifetime)
                {
                    case Lifetime.Transient:
                        container.RegisterMultiple(collectionTypeRegistration.RegistrationType, collectionTypeRegistration.ImplementationTypes).AsMultiInstance();
                        break;
                    case Lifetime.Singleton:
                        container.RegisterMultiple(collectionTypeRegistration.RegistrationType, collectionTypeRegistration.ImplementationTypes).AsSingleton();
                        break;
                    case Lifetime.PerRequest:
                        throw new InvalidOperationException("Unable to directly register a per request lifetime.");
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        /// <summary>
        /// Register the given module types into the container
        /// </summary>
        /// <param name="container">Container to register into</param>
        /// <param name="moduleRegistrationTypes">NancyModule types</param>
        protected override sealed void RegisterRequestContainerModules(TinyIoCContainer container, IEnumerable<ModuleRegistration> moduleRegistrationTypes)
        {
            foreach (var moduleRegistrationType in moduleRegistrationTypes)
            {
                container.Register(
                    typeof(INancyModule),
                    moduleRegistrationType.ModuleType,
                    moduleRegistrationType.ModuleType.FullName).
                    AsSingleton();
            }
        }

        /// <summary>
        /// Register the given instances into the container
        /// </summary>
        /// <param name="container">Container to register into</param>
        /// <param name="instanceRegistrations">Instance registration types</param>
        protected override void RegisterInstances(TinyIoCContainer container, IEnumerable<InstanceRegistration> instanceRegistrations)
        {
            foreach (var instanceRegistration in instanceRegistrations)
            {
                container.Register(
                    instanceRegistration.RegistrationType,
                    instanceRegistration.Implementation);
            }
        }

        /// <summary>
        /// Creates a per request child/nested container
        /// </summary>
        /// <param name="context">Current context</param>
        /// <returns>Request container instance</returns>
        protected override TinyIoCContainer CreateRequestContainer(NancyContext context)
        {
            return this.ApplicationContainer.GetChildContainer();
        }

        /// <summary>
        /// Gets the <see cref="INancyEnvironmentConfigurator"/> used by th.
        /// </summary>
        /// <returns>An <see cref="INancyEnvironmentConfigurator"/> instance.</returns>
        protected override INancyEnvironmentConfigurator GetEnvironmentConfigurator()
        {
            return this.ApplicationContainer.Resolve<INancyEnvironmentConfigurator>();
        }

        /// <summary>
        /// Gets the diagnostics for initialization
        /// </summary>
        /// <returns>IDiagnostics implementation</returns>
        protected override IDiagnostics GetDiagnostics()
        {
            return this.ApplicationContainer.Resolve<IDiagnostics>();
        }

        /// <summary>
        /// Gets all registered startup tasks
        /// </summary>
        /// <returns>An <see cref="IEnumerable{T}"/> instance containing <see cref="IApplicationStartup"/> instances. </returns>
        protected override IEnumerable<IApplicationStartup> GetApplicationStartupTasks()
        {
            return this.ApplicationContainer.ResolveAll<IApplicationStartup>(false);
        }

        /// <summary>
        /// Gets all registered request startup tasks
        /// </summary>
        /// <returns>An <see cref="IEnumerable{T}"/> instance containing <see cref="IRequestStartup"/> instances.</returns>
        protected override IEnumerable<IRequestStartup> RegisterAndGetRequestStartupTasks(TinyIoCContainer container, Type[] requestStartupTypes)
        {
            container.RegisterMultiple(typeof(IRequestStartup), requestStartupTypes);

            return container.ResolveAll<IRequestStartup>(false);
        }

        /// <summary>
        /// Gets all registered application registration tasks
        /// </summary>
        /// <returns>An <see cref="IEnumerable{T}"/> instance containing <see cref="IRegistrations"/> instances.</returns>
        protected override IEnumerable<IRegistrations> GetRegistrationTasks()
        {
            return this.ApplicationContainer.ResolveAll<IRegistrations>(false);
        }

        /// <summary>
        /// Get the <see cref="INancyEnvironment"/> instance.
        /// </summary>
        /// <returns>An configured <see cref="INancyEnvironment"/> instance.</returns>
        /// <remarks>The boostrapper must be initialised (<see cref="INancyBootstrapper.Initialise"/>) prior to calling this.</remarks>
        public override INancyEnvironment GetEnvironment()
        {
            return this.ApplicationContainer.Resolve<INancyEnvironment>();
        }

        /// <summary>
        /// Retrieve all module instances from the container
        /// </summary>
        /// <param name="container">Container to use</param>
        /// <returns>Collection of NancyModule instances</returns>
        protected override sealed IEnumerable<INancyModule> GetAllModules(TinyIoCContainer container)
        {
            var nancyModules = container.ResolveAll<INancyModule>(false);
            return nancyModules;
        }

        /// <summary>
        /// Retrieve a specific module instance from the container
        /// </summary>
        /// <param name="container">Container to use</param>
        /// <param name="moduleType">Type of the module</param>
        /// <returns>NancyModule instance</returns>
        protected override sealed INancyModule GetModule(TinyIoCContainer container, Type moduleType)
        {
            container.Register(typeof(INancyModule), moduleType);

            return container.Resolve<INancyModule>();
        }

        /// <summary>
        /// Executes auto registration with the given container.
        /// </summary>
        /// <param name="container">Container instance</param>
        private static void AutoRegister(TinyIoCContainer container, IEnumerable<Func<Assembly, bool>> ignoredAssemblies)
        {
            var assembly = typeof(NancyEngine).Assembly;

            container.AutoRegister(AppDomain.CurrentDomain.GetAssemblies().Where(a => !ignoredAssemblies.Any(ia => ia(a))), DuplicateImplementationActions.RegisterMultiple, t => t.Assembly != assembly);
        }
    }
}
namespace Nancy.Extensions
{
    using System;
    using System.Text;

    using Nancy.Responses;

    /// <summary>
    /// Containing extensions for the <see cref="NancyContext"/> object
    /// </summary>
    public static class ContextExtensions
    {
        /// <summary>
        /// Ascertains if a request originated from an Ajax request or not.
        /// </summary>
        /// <param name="context">The current nancy context</param>
        /// <returns>True if the request was done using ajax, false otherwise</returns>
        public static bool IsAjaxRequest(this NancyContext context)
        {
            return context.Request != null && context.Request.IsAjaxRequest();
        }

        /// <summary>
        /// Expands a path to take into account a base path (if any)
        /// </summary>
        /// <param name="context">Nancy context</param>
        /// <param name="path">Path to expand</param>
        /// <returns>Expanded path</returns>
        public static string ToFullPath(this NancyContext context, string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                return path;
            }

            if (context.Request == null)
            {
                return path.TrimStart('~');
            }

            if (string.IsNullOrEmpty(context.Request.Url.BasePath))
            {
                return path.TrimStart('~');
            }

            if (!path.StartsWith("~/"))
            {
                return path;
            }

            return string.Format("{0}{1}", context.Request.Url.BasePath, path.TrimStart('~'));
        }

        /// <summary>
        /// Returns a redirect response with the redirect path expanded to take into
        /// account a base path (if any)
        /// </summary>
        /// <param name="context">Nancy context</param>
        /// <param name="path">Path to redirect to</param>
        /// <returns>Redirect response</returns>
        public static RedirectResponse GetRedirect(this NancyContext context, string path)
        {
            return new RedirectResponse(context.ToFullPath(path));
        }

        /// <summary>
        /// Retrieves exception details from the context, if any exist
        /// </summary>
        /// <param name="context">Nancy context</param>
        /// <returns>Exception details</returns>
        public static string GetExceptionDetails(this NancyContext context)
        {
            object errorObject;
            context.Items.TryGetValue(NancyEngine.ERROR_KEY, out errorObject);

            return (errorObject as string) ?? string.Empty;
        }

        /// <summary>
        /// Get a thrown exception from the context.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <returns>The thrown exception or <c>null</c> if not exception has been thrown.</returns>
        public static Exception GetException(this NancyContext context)
        {
            return GetException<Exception>(context);
        }

        /// <summary>
        /// Get a thrown exception of the given type from the context.
        /// </summary>
        /// <typeparam name="T">The type of exception to get.</typeparam>
        /// <param name="context">The context.</param>
        /// <returns>The thrown exception or <c>null</c> if not exception has been thrown.</returns>
        public static T GetException<T>(this NancyContext context) where T : Exception
        {
            T exception;
            return TryGetException(context, out exception) ? exception : null;
        }

        /// <summary>
        /// Tries to get a thrown exception from the context.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="exception">The thrown exception.</param>
        /// <returns><c>true</c> if an exception has been thrown during the request, <c>false</c> otherwise.</returns>
        public static bool TryGetException(this NancyContext context, out Exception exception)
        {
            return TryGetException<Exception>(context, out exception);
        }

        /// <summary>
        /// Tries to get a thrown exception of the given type from the context.
        /// </summary>
        /// <typeparam name="T">The type of exception to get.</typeparam>
        /// <param name="context">The context.</param>
        /// <param name="exception">The thrown exception.</param>
        /// <returns><c>true</c> if an exception of the given type has been thrown during the request, <c>false</c> otherwise.</returns>
        public static bool TryGetException<T>(this NancyContext context, out T exception) where T : Exception
        {
            object exceptionObject;
            if (context.Items.TryGetValue(NancyEngine.ERROR_EXCEPTION, out exceptionObject) && exceptionObject is T)
            {
                exception = exceptionObject as T;
                return true;
            }

            exception = null;
            return false;
        }

        /// <summary>
        /// Shortcut extension method for writing trace information
        /// </summary>
        /// <param name="context">Nancy context</param>
        /// <param name="logDelegate">Log delegate</param>
        public static void WriteTraceLog(this NancyContext context, Action<StringBuilder> logDelegate)
        {
            context.Trace.TraceLog.WriteLog(logDelegate);
        }

        /// <summary>
        /// Returns a boolean indicating whether a given url string is local or not
        /// </summary>
        /// <param name="context">Nancy context</param>
        /// <param name="url">Url string (relative or absolute)</param>
        /// <returns>True if local, false otherwise</returns>
        public static bool IsLocalUrl(this NancyContext context, string url)
        {
            if (string.IsNullOrEmpty(url))
            {
                return false;
            }

            if (!Uri.IsWellFormedUriString(url, UriKind.RelativeOrAbsolute))
            {
                return false;
            }

            Uri uri;
            if (Uri.TryCreate(url, UriKind.Absolute, out uri))
            {
                var currentHostName = context.Request.Url.HostName;

                // Mono does not populate the uri.Host correctly when url
                // is in //hostname format causing the simple check to fail.
                if (uri.Scheme.Equals("file"))
                {
                    var localFormat = string.Format("//{0}", currentHostName);
                    return !url.StartsWith("//") || url.StartsWith(localFormat);
                }

                return uri.Host == currentHostName;
            }

            return Uri.TryCreate(url, UriKind.Relative, out uri);
        }
    }
}
namespace Nancy.Extensions
{
    using System;
    using Nancy.ErrorHandling;

    /// <summary>
    /// Containing extensions for <see cref="INancyModule"/> implementations.
    /// </summary>
    public static class ModuleExtensions
    {
        /// <summary>
        /// Extracts the friendly name of a Nancy module given its type.
        /// </summary>
        /// <param name="module">The module instance</param>
        /// <returns>A string containing the name of the parameter.</returns>
        public static string GetModuleName(this INancyModule module)
        {
            var typeName = module.GetType().Name;

            var offset = typeName.LastIndexOf("Module", StringComparison.Ordinal);

            if (offset <= 0)
            {
                return typeName;
            }

            return typeName.Substring(0, offset);
        }

        /// <summary>
        /// Returns a boolean indicating whether the route is executing, or whether the module is
        /// being constructed.
        /// </summary>
        /// <param name="module">The module instance</param>
        /// <returns>True if the route is being executed, false if the module is being constructed</returns>
        public static bool RouteExecuting(this INancyModule module)
        {
            return module.Context != null;
        }

        /// <summary>
        /// Adds the before delegate to the Before pipeline if the module is not currently executing,
        /// or executes the delegate directly and returns any response returned if it is.
        /// Uses <see cref="RouteExecutionEarlyExitException"/>
        /// </summary>
        /// <param name="module">Current module</param>
        /// <param name="beforeDelegate">Delegate to add or execute</param>
        /// <param name="earlyExitReason">Optional reason for the early exit (if necessary)</param>
        public static void AddBeforeHookOrExecute(this INancyModule module, Func<NancyContext, Response> beforeDelegate, string earlyExitReason = null)
        {
            if (module.RouteExecuting())
            {
                var result = beforeDelegate.Invoke(module.Context);

                if (result != null)
                {
                    throw new RouteExecutionEarlyExitException(result, earlyExitReason);
                }
            }
            else
            {
                module.Before.AddItemToEndOfPipeline(beforeDelegate);
            }
        }
    }
}
namespace Nancy.Extensions
{
    using System;
    using System.Linq;

    /// <summary>
    /// Containing extensions for the <see cref="Request"/> object
    /// </summary>
    public static class RequestExtensions
    {
        /// <summary>
        /// An extension method making it easy to check if the request was done using ajax
        /// </summary>
        /// <param name="request">The request made by client</param>
        /// <returns><see langword="true" /> if the request was done using ajax, otherwise <see langword="false"/>.</returns>
        public static bool IsAjaxRequest(this Request request)
        {
            const string ajaxRequestHeaderKey = "X-Requested-With";
            const string ajaxRequestHeaderValue = "XMLHttpRequest";

            return request.Headers[ajaxRequestHeaderKey].Contains(ajaxRequestHeaderValue);
        }
        /// <summary>
        /// Gets a value indicating whether the request is local.
        /// </summary>
        /// <param name="request">The request made by client</param>
        /// <returns><see langword="true" /> if the request is local, otherwise <see langword="false"/>.</returns>
        public static bool IsLocal(this Request request)
        {
            if (string.IsNullOrEmpty(request.UserHostAddress) || string.IsNullOrEmpty(request.Url))
            {
                return false;
            }

            Uri uri = null;
            if (Uri.TryCreate(request.Url, UriKind.Absolute, out uri))
            {
                return uri.IsLoopback;
            }
            else
            {
                // Invalid or relative Request.Url string
                return false;
            }
        }
    }
}
namespace Nancy.Extensions
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Text.RegularExpressions;

    using Nancy.Helpers;
    using Nancy.Routing;

    /// <summary>
    /// Containing extensions for the <see cref="string"/> object.
    /// </summary>
    public static class StringExtensions
    {
        /// <summary>
        /// A regular expression used to manipulate parameterized route segments.
        /// </summary>
        /// <value>A <see cref="Regex"/> object.</value>
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static readonly Regex ParameterExpression =
            new Regex(@"{(?<name>[A-Za-z0-9_]*)(?:\?(?<default>[A-Za-z0-9_-]*))?}", RegexOptions.Compiled);

        /// <summary>
        /// Extracts information about the parameters in the <paramref name="segment"/>.
        /// </summary>
        /// <param name="segment">The segment that the information should be extracted from.</param>
        /// <returns>An <see cref="IEnumerable{T}"/>, containing <see cref="ParameterSegmentInformation"/> instances for the parameters in the segment.</returns>
        public static IEnumerable<ParameterSegmentInformation> GetParameterDetails(this string segment)
        {
            var matches = ParameterExpression
                .Matches(segment);

            var nameMatch = matches
                .Cast<Match>()
                .ToList();

            return nameMatch.Select(x => new ParameterSegmentInformation(x.Groups["name"].Value, x.Groups["default"].Value, x.Groups["default"].Success));
        }

        /// <summary>
        /// Checks if a segment contains any parameters.
        /// </summary>
        /// <param name="segment">The segment to check for parameters.</param>
        /// <returns>true if the segment contains a parameter; otherwise false.</returns>
        /// <remarks>A parameter is defined as a string which is surrounded by a pair of curly brackets.</remarks>
        /// <exception cref="ArgumentException">The provided value for the segment parameter was null or empty.</exception>
        public static bool IsParameterized(this string segment)
        {
            var parameterMatch =
                ParameterExpression.Match(segment);

            return parameterMatch.Success;
        }

        /// <summary>
        /// Gets a dynamic dictionary back from a Uri query string
        /// </summary>
        /// <param name="queryString">The query string to extract values from</param>
        /// <returns>A dynamic dictionary containing the query string values</returns>
        public static DynamicDictionary AsQueryDictionary(this string queryString)
        {
            var coll = HttpUtility.ParseQueryString(queryString);
            var ret = new DynamicDictionary();

            var found = 0;
            foreach (var key in coll.AllKeys.Where(key => key != null))
            {
                ret[key] = coll[key];

                found++;

                if (found >= StaticConfiguration.RequestQueryFormMultipartLimit)
                {
                    break;
                }
            }

            return ret;
        }

        /// <summary>
        /// Converts the value from PascalCase to camelCase.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>System.String.</returns>
        public static string ToCamelCase(this string value)
        {
            return value.ConvertFirstCharacter(x => x.ToLowerInvariant());
        }

        /// <summary>
        /// Converts the value from camelCase to PascalCase.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>System.String.</returns>
        public static string ToPascalCase(this string value)
        {
            return value.ConvertFirstCharacter(x => x.ToUpperInvariant());
        }

        private static string ConvertFirstCharacter(this string value, Func<string, string> converter)
        {
            if (string.IsNullOrEmpty(value))
            {
                return string.Empty;
            }

            return string.Concat(converter(value.Substring(0, 1)), value.Substring(1));
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public abstract class NamedPipelineBase<TDelegate>
    {
        /// <summary>
        /// Pipeline items to execute
        /// </summary>
        protected readonly List<PipelineItem<TDelegate>> pipelineItems;

        protected NamedPipelineBase()
        {
            this.pipelineItems = new List<PipelineItem<TDelegate>>();
        }

        protected NamedPipelineBase(int capacity)
        {
            this.pipelineItems = new List<PipelineItem<TDelegate>>(capacity);
        }

        /// <summary>
        /// Gets the current pipeline items
        /// </summary>
        public IEnumerable<PipelineItem<TDelegate>> PipelineItems
        {
            get { return this.pipelineItems.AsReadOnly(); }
        }

        /// <summary>
        /// Gets the current pipeline item delegates
        /// </summary>
        public IEnumerable<TDelegate> PipelineDelegates
        {
            get { return this.pipelineItems.Select(pipelineItem => pipelineItem.Delegate); }
        }

        /// <summary>
        /// Add an item to the start of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        public virtual void AddItemToStartOfPipeline(TDelegate item)
        {
            this.AddItemToStartOfPipeline((PipelineItem<TDelegate>)item);
        }

        /// <summary>
        /// Add an item to the start of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        /// <param name="replaceInPlace">
        /// Whether to replace an existing item with the same name in its current place,
        /// rather than at the position requested. Defaults to false.
        /// </param>
        public virtual void AddItemToStartOfPipeline(PipelineItem<TDelegate> item, bool replaceInPlace = false)
        {
            this.InsertItemAtPipelineIndex(0, item, replaceInPlace);
        }

        /// <summary>
        /// Add an item to the end of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        public virtual void AddItemToEndOfPipeline(TDelegate item)
        {
            this.AddItemToEndOfPipeline((PipelineItem<TDelegate>)item);
        }

        /// <summary>
        /// Add an item to the end of the pipeline
        /// </summary>
        /// <param name="item">Item to add</param>
        /// <param name="replaceInPlace">
        /// Whether to replace an existing item with the same name in its current place,
        /// rather than at the position requested. Defaults to false.
        /// </param>
        public virtual void AddItemToEndOfPipeline(PipelineItem<TDelegate> item, bool replaceInPlace = false)
        {
            var existingIndex = this.RemoveByName(item.Name);

            if (replaceInPlace && existingIndex != -1)
            {
                this.InsertItemAtPipelineIndex(existingIndex, item);
            }
            else
            {
                this.pipelineItems.Add(item);
            }
        }

        /// <summary>
        /// Add an item to a specific place in the pipeline.
        /// </summary>
        /// <param name="index">Index to add at</param>
        /// <param name="item">Item to add</param>
        public virtual void InsertItemAtPipelineIndex(int index, TDelegate item)
        {
            this.InsertItemAtPipelineIndex(index, (PipelineItem<TDelegate>)item);
        }

        /// <summary>
        /// Add an item to a specific place in the pipeline.
        /// </summary>
        /// <param name="index">Index to add at</param>
        /// <param name="item">Item to add</param>
        /// <param name="replaceInPlace">
        /// Whether to replace an existing item with the same name in its current place,
        /// rather than at the position requested. Defaults to false.
        /// </param>
        public virtual void InsertItemAtPipelineIndex(int index, PipelineItem<TDelegate> item, bool replaceInPlace = false)
        {
            var existingIndex = this.RemoveByName(item.Name);

            var newIndex = (replaceInPlace && existingIndex != -1) ? existingIndex : index;

            this.pipelineItems.Insert(newIndex, item);
        }

        /// <summary>
        /// Insert an item before a named item.
        /// If the named item does not exist the item is inserted at the start of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert before</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertBefore(string name, TDelegate item)
        {
            this.InsertBefore(name, (PipelineItem<TDelegate>)item);
        }

        /// <summary>
        /// Insert an item before a named item.
        /// If the named item does not exist the item is inserted at the start of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert before</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertBefore(string name, PipelineItem<TDelegate> item)
        {
            var existingIndex =
                this.pipelineItems.FindIndex(i => String.Equals(name, i.Name, StringComparison.Ordinal));

            if (existingIndex == -1)
            {
                existingIndex = 0;
            }

            this.InsertItemAtPipelineIndex(existingIndex, item);
        }

        /// <summary>
        /// Insert an item after a named item.
        /// If the named item does not exist the item is inserted at the end of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert after</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertAfter(string name, TDelegate item)
        {
            this.InsertAfter(name, (PipelineItem<TDelegate>)item);
        }

        /// <summary>
        /// Insert an item after a named item.
        /// If the named item does not exist the item is inserted at the end of the pipeline.
        /// </summary>
        /// <param name="name">Name of the item to insert after</param>
        /// <param name="item">Item to insert</param>
        public virtual void InsertAfter(string name, PipelineItem<TDelegate> item)
        {
            var existingIndex =
                this.pipelineItems.FindIndex(i => String.Equals(name, i.Name, StringComparison.Ordinal));

            if (existingIndex == -1)
            {
                existingIndex = this.pipelineItems.Count;
            }

            existingIndex++;

            if (existingIndex > this.pipelineItems.Count)
            {
                this.AddItemToEndOfPipeline(item);
            }
            else
            {
                this.InsertItemAtPipelineIndex(existingIndex, item);
            }
        }

        /// <summary>
        /// Remove a named pipeline item
        /// </summary>
        /// <param name="name">Name</param>
        /// <returns>Index of item that was removed or -1 if nothing removed</returns>
        public virtual int RemoveByName(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                return -1;
            }

            var existingIndex =
                this.pipelineItems.FindIndex(i => String.Equals(name, i.Name, StringComparison.Ordinal));

            if (existingIndex != -1)
            {
                this.pipelineItems.RemoveAt(existingIndex);
            }

            return existingIndex;
        }
    }
}
namespace Nancy
{
    public class PipelineItem<TDelegate>
    {
        public string Name { get; protected set; }

        public TDelegate Delegate { get; protected set; }

        public PipelineItem(string name, TDelegate @delegate)
        {
            this.Name = name;
            this.Delegate = @delegate;
        }

        public static implicit operator PipelineItem<TDelegate>(TDelegate action)
        {
            return new PipelineItem<TDelegate>(null, action);
        }

        public static implicit operator TDelegate(PipelineItem<TDelegate> pipelineItem)
        {
            return pipelineItem.Delegate;
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;

    using Nancy.Cookies;

    /// <summary>
    /// Provides strongly-typed access to HTTP request headers.
    /// </summary>
    public class RequestHeaders : IEnumerable<KeyValuePair<string, IEnumerable<string>>>
    {
        private readonly IDictionary<string, IEnumerable<string>> headers;
        private readonly ConcurrentDictionary<string, IEnumerable<Tuple<string, decimal>>> cache;

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestHeaders"/> class.
        /// </summary>
        /// <param name="headers">The headers.</param>
        public RequestHeaders(IDictionary<string, IEnumerable<string>> headers)
        {
            this.headers = new Dictionary<string, IEnumerable<string>>(headers, StringComparer.OrdinalIgnoreCase);
            this.cache = new ConcurrentDictionary<string, IEnumerable<Tuple<string, decimal>>>(StringComparer.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Content-types that are acceptable.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains the header values if they are available; otherwise it will be empty.</value>
        public IEnumerable<Tuple<string, decimal>> Accept
        {
            get { return this.GetWeightedValues("Accept"); }
            set { this.SetHeaderValues("Accept", value, GetWeightedValuesAsStrings); }
        }

        /// <summary>
        /// Character sets that are acceptable.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains the header values if they are available; otherwise it will be empty.</value>
        public IEnumerable<Tuple<string, decimal>> AcceptCharset
        {
            get { return this.GetWeightedValues("Accept-Charset"); }
            set { this.SetHeaderValues("Accept-Charset", value, GetWeightedValuesAsStrings); }
        }

        /// <summary>
        /// Acceptable encodings.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains the header values if they are available; otherwise it will be empty.</value>
        public IEnumerable<string> AcceptEncoding
        {
            get { return this.GetSplitValues("Accept-Encoding"); }
            set { this.SetHeaderValues("Accept-Encoding", value, x => x); }
        }

        /// <summary>
        /// Acceptable languages for response.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains the header values if they are available; otherwise it will be empty.</value>
        public IEnumerable<Tuple<string, decimal>> AcceptLanguage
        {
            get { return this.GetWeightedValues("Accept-Language"); }
            set { this.SetHeaderValues("Accept-Language", value, GetWeightedValuesAsStrings); }
        }

        /// <summary>
        /// Authorization header value for request.
        /// </summary>
        /// <value>A <see cref="string"/> containing the header value if it is available; otherwise <see cref="string.Empty"/>.</value>
        public string Authorization
        {
            get { return this.GetValue("Authorization", x => x.First(), string.Empty); }
            set { this.SetHeaderValues("Authorization", value, x => new[] { x }); }
        }

        /// <summary>
        /// Used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains the header values if they are available; otherwise it will be empty.</value>
        public IEnumerable<string> CacheControl
        {
            get { return this.GetValue("Cache-Control"); }
            set { this.SetHeaderValues("Cache-Control", value, x => x); }
        }

        /// <summary>
        /// Contains name/value pairs of information stored for that URL.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains <see cref="INancyCookie"/> instances if they are available; otherwise it will be empty.</value>
        public IEnumerable<INancyCookie> Cookie
        {
            get { return this.GetValue("Cookie", GetNancyCookies, Enumerable.Empty<INancyCookie>()); }
        }

        /// <summary>
        /// What type of connection the user-agent would prefer.
        /// </summary>
        /// <value>A <see cref="string"/> containing the header value if it is available; otherwise <see cref="string.Empty"/>.</value>
        public string Connection
        {
            get { return this.GetValue("Connection", x => x.First(), string.Empty); }
            set { this.SetHeaderValues("Connection", value, x => new[] { x }); }
        }

        /// <summary>
        /// The length of the request body in octets (8-bit bytes).
        /// </summary>
        /// <value>The length of the contents if it is available; otherwise 0.</value>
        public long ContentLength
        {
            get { return this.GetValue("Content-Length", x => Convert.ToInt64(x.First()), 0); }
            set { this.SetHeaderValues("Content-Length", value, x => new[] { x.ToString(CultureInfo.InvariantCulture) }); }
        }

        /// <summary>
        /// The mime type of the body of the request (used with POST and PUT requests).
        /// </summary>
        /// <value>A <see cref="string"/> containing the header value if it is available; otherwise <see langword="string.Empty"/>.</value>
        public string ContentType
        {
            get { return this.GetValue("Content-Type", x => x.First(), string.Empty); }
            set { this.SetHeaderValues("Content-Type", value, x => new[] { x }); }
        }

        /// <summary>
        /// The date and time that the message was sent.
        /// </summary>
        /// <value>A <see cref="DateTime"/> instance that specifies when the message was sent. If not available then <see langword="null"/> will be returned.</value>
        public DateTime? Date
        {
            get { return this.GetValue("Date", x => ParseDateTime(x.First()), null); }
            set { this.SetHeaderValues("Date", value, x => new[] { GetDateAsString(value) }); }
        }

        /// <summary>
        /// The domain name of the server (for virtual hosting), mandatory since HTTP/1.1
        /// </summary>
        /// <value>A <see cref="string"/> containing the header value if it is available; otherwise <see cref="string.Empty"/>.</value>
        public string Host
        {
            get { return this.GetValue("Host", x => x.First(), string.Empty); }
            set { this.SetHeaderValues("Host", value, x => new[] { x }); }
        }

        /// <summary>
        /// Only perform the action if the client supplied entity matches the same entity on the server. This is mainly for methods like PUT to only update a resource if it has not been modified since the user last updated it.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains the header values if they are available; otherwise it will be empty.</value>
        public IEnumerable<string> IfMatch
        {
            get { return this.GetValue("If-Match"); }
            set { this.SetHeaderValues("If-Match", value, x => x); }
        }

        /// <summary>
        /// Allows a 304 Not Modified to be returned if content is unchanged
        /// </summary>
        /// <value>A <see cref="DateTime"/> instance that specifies when the requested resource must have been changed since. If not available then <see langword="null"/> will be returned.</value>
        public DateTime? IfModifiedSince
        {
            get { return this.GetValue("If-Modified-Since", x => ParseDateTime(x.First()), null); }
            set { this.SetHeaderValues("If-Modified-Since", value, x => new[] { GetDateAsString(value) }); }
        }

        /// <summary>
        /// Allows a 304 Not Modified to be returned if content is unchanged
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains the header values if they are available; otherwise it will be empty.</value>
        public IEnumerable<string> IfNoneMatch
        {
            get { return this.GetValue("If-None-Match"); }
            set { this.SetHeaderValues("If-None-Match", value, x => x); }
        }

        /// <summary>
        /// If the entity is unchanged, send me the part(s) that I am missing; otherwise, send me the entire new entity.
        /// </summary>
        /// <value>A <see cref="string"/> containing the header value if it is available; otherwise <see cref="string.Empty"/>.</value>
        public string IfRange
        {
            get { return this.GetValue("If-Range", x => x.First(), string.Empty); }
            set { this.SetHeaderValues("If-Range", value, x => new[] { x }); }
        }

        /// <summary>
        /// Only send the response if the entity has not been modified since a specific time.
        /// </summary>
        /// <value>A <see cref="DateTime"/> instance that specifies when the requested resource may not have been changed since. If not available then <see langword="null"/> will be returned.</value>
        public DateTime? IfUnmodifiedSince
        {
            get { return this.GetValue("If-Unmodified-Since", x => ParseDateTime(x.First()), null); }
            set { this.SetHeaderValues("If-Unmodified-Since", value, x => new[] { GetDateAsString(value) }); }

        }

        /// <summary>
        /// Gets the names of the available request headers.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> containing the names of the headers.</value>
        public IEnumerable<string> Keys
        {
            get { return this.headers.Keys; }
        }

        /// <summary>
        /// Limit the number of times the message can be forwarded through proxies or gateways.
        /// </summary>
        /// <value>The number of the maximum allowed number of forwards if it is available; otherwise 0.</value>
        public int MaxForwards
        {
            get { return this.GetValue("Max-Forwards", x => Convert.ToInt32(x.First()), 0); }
            set { this.SetHeaderValues("Max-Forwards", value, x => new[] { x.ToString(CultureInfo.InvariantCulture) }); }
        }

        /// <summary>
        /// This is the address of the previous web page from which a link to the currently requested page was followed.
        /// </summary>
        /// <value>A <see cref="string"/> containing the header value if it is available; otherwise <see cref="string.Empty"/>.</value>
        public string Referrer
        {
            get { return this.GetValue("Referer", x => x.First(), string.Empty); }
            set { this.SetHeaderValues("Referer", value, x => new[] { x }); }
        }

        /// <summary>
        /// The user agent string of the user agent
        /// </summary>
        /// <value>A <see cref="string"/> containing the header value if it is available; otherwise <see cref="string.Empty"/>.</value>
        public string UserAgent
        {
            get { return this.GetValue("User-Agent", x => x.First(), string.Empty); }
            set { this.SetHeaderValues("User-Agent", value, x => new[] { x }); }
        }

        /// <summary>
        /// Gets all the header values.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains all the header values.</value>
        public IEnumerable<IEnumerable<string>> Values
        {
            get { return this.headers.Values; }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>A <see cref="IEnumerator{T}"/> that can be used to iterate through the collection.</returns>
        public IEnumerator<KeyValuePair<string, IEnumerable<string>>> GetEnumerator()
        {
            return this.headers.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        /// <summary>
        /// Gets the values for the header identified by the <paramref name="name"/> parameter.
        /// </summary>
        /// <param name="name">The name of the header to return the values for.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> that contains the values for the header. If the header is not defined then <see cref="Enumerable.Empty{TResult}"/> is returned.</returns>
        public IEnumerable<string> this[string name]
        {
            get
            {
                return (this.headers.ContainsKey(name)) ?
                    this.headers[name] :
                    Enumerable.Empty<string>();
            }
        }

        private static string GetDateAsString(DateTime? value)
        {
            return !value.HasValue ? null : value.Value.ToString("R", CultureInfo.InvariantCulture);
        }

        private IEnumerable<string> GetSplitValues(string header)
        {
            var values = this.GetValue(header);

            return values
                .SelectMany(x => x.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries))
                .Select(x => x.Trim())
                .ToList();
        }

        private IEnumerable<Tuple<string, decimal>> GetWeightedValues(string headerName)
        {
            return this.cache.GetOrAdd(headerName, r =>
            {
                var values = this.GetValue(r);
                var result = new List<Tuple<string, decimal>>();

                foreach (var header in values)
                {
                    var buffer = string.Empty;
                    var name = string.Empty;
                    var quality = string.Empty;
                    var isReadingQuality = false;
                    var isInQuotedSection = false;

                    for (var index = 0; index < header.Length; index++)
                    {
                        var character = header[index];

                        if (character.Equals(' ') && (index != header.Length - 1) && !isInQuotedSection)
                        {
                            continue;
                        }

                        if (character.Equals('"'))
                        {
                            isInQuotedSection = !isInQuotedSection;
                        }

                        if (isInQuotedSection)
                        {
                            buffer += character;

                            if (index != header.Length - 1)
                            {
                                continue; ;
                            }
                        }

                        if (character.Equals(';') || character.Equals(',') || (index == header.Length - 1))
                        {
                            if (!(character.Equals(';') || character.Equals(',')))
                            {
                                buffer += character;
                            }

                            if (isReadingQuality)
                            {
                                quality = buffer;
                            }
                            else
                            {
                                if (name.Length > 0)
                                {
                                    name += ';';
                                }

                                name += buffer;
                            }

                            buffer = string.Empty;
                            isReadingQuality = false;
                            isInQuotedSection = false;
                        }

                        if (character.Equals(';'))
                        {
                            continue;
                        }

                        if ((character.Equals('q') || character.Equals('Q')) && (index != header.Length - 1))
                        {
                            if (header[index + 1].Equals('='))
                            {
                                isReadingQuality = true;
                                continue;
                            }
                        }

                        if (isReadingQuality && character.Equals('='))
                        {
                            continue;
                        }

                        if (character.Equals(',') || (index == header.Length - 1))
                        {
                            var actualQuality = 1m;
                            decimal temp;

                            if (decimal.TryParse(quality, NumberStyles.Number, CultureInfo.InvariantCulture, out temp))
                            {
                                actualQuality = temp;
                            }

                            result.Add(new Tuple<string, decimal>(name, actualQuality));

                            name = string.Empty;
                            quality = string.Empty;
                            buffer = string.Empty;
                            isReadingQuality = false;

                            continue;
                        }

                        buffer += character;
                    }
                }

                return result.OrderByDescending(x => x.Item2);
            });
        }

        private static IEnumerable<INancyCookie> GetNancyCookies(IEnumerable<string> cookies)
        {
            if (cookies == null)
            {
                yield break;
            }

            foreach (var cookie in cookies)
            {
                var cookieStrings = cookie.Split(';');
                foreach (var cookieString in cookieStrings)
                {
                    var equalPos = cookieString.IndexOf('=');
                    if (equalPos >= 0)
                    {
                        yield return new NancyCookie(cookieString.Substring(0, equalPos).TrimStart(), cookieString.Substring(equalPos + 1).TrimEnd());
                    }
                }
            }
        }

        private IEnumerable<string> GetValue(string name)
        {
            return this.GetValue(name, x => x, new string[] { });
        }

        private T GetValue<T>(string name, Func<IEnumerable<string>, T> converter, T defaultValue)
        {
            IEnumerable<string> values;

            if (!this.headers.TryGetValue(name, out values))
            {
                return defaultValue;
            }

            return converter.Invoke(values);
        }

        private static IEnumerable<string> GetWeightedValuesAsStrings(IEnumerable<Tuple<string, decimal>> values)
        {
            return values.Select(x => string.Concat(x.Item1, ";q=", x.Item2.ToString(CultureInfo.InvariantCulture)));
        }

        private static DateTime? ParseDateTime(string value)
        {
            DateTime result;
            // note CultureInfo.InvariantCulture is ignored
            if (DateTime.TryParseExact(value, "R", CultureInfo.InvariantCulture, DateTimeStyles.None, out result))
            {
                return result;
            }
            return null;
        }

        private void SetHeaderValues<T>(string header, T value, Func<T, IEnumerable<string>> valueTransformer)
        {
            this.InvalidateCacheEntry(header);

            if (EqualityComparer<T>.Default.Equals(value, default(T)))
            {
                if (this.headers.ContainsKey(header))
                {
                    this.headers.Remove(header);
                }
            }
            else
            {
                this.headers[header] = valueTransformer.Invoke(value);
            }
        }

        private void InvalidateCacheEntry(string header)
        {
            IEnumerable<Tuple<string, decimal>> values;
            this.cache.TryRemove(header, out values);
        }
    }
}
namespace Nancy.Responses
{
    using System;
    using System.Collections.Generic;
    using System.IO;

    using Nancy.Cookies;

    /// <summary>
    /// Represents a HTML (text/html) response
    /// </summary>
    public class HtmlResponse : Response
    {
        /// <summary>
        /// Creates a new instance of the HtmlResponse class
        /// </summary>
        /// <param name="statusCode">Status code - defaults to OK</param>
        /// <param name="contents">Response body delegate - defaults to empty if null</param>
        /// <param name="headers">Headers if required</param>
        /// <param name="cookies">Cookies if required</param>
        public HtmlResponse(HttpStatusCode statusCode = HttpStatusCode.OK, Action<Stream> contents = null, IDictionary<string, string> headers = null, IEnumerable<INancyCookie> cookies = null)
        {
            this.ContentType = "text/html";
            this.StatusCode = statusCode;

            if (contents != null)
            {
                this.Contents = contents;
            }

            if (headers != null)
            {
                this.Headers = headers;
            }

            if (cookies != null)
            {
                foreach (var nancyCookie in cookies)
                {
                    this.Cookies.Add(nancyCookie);
                }
            }
        }
    }
}
namespace Nancy.Security
{
    using System;
    using System.Linq;

    using Nancy.Bootstrapper;
    using Nancy.Cookies;
    using Nancy.Cryptography;
    using Nancy.Helpers;

    /// <summary>
    /// Csrf protection methods
    /// </summary>
    public static class Csrf
    {
        private const string CsrfHookName = "CsrfPostHook";

        /// <summary>
        /// Enables Csrf token generation.
        /// This is disabled by default.
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        public static void Enable(IPipelines pipelines, CryptographyConfiguration cryptographyConfiguration = null)
        {
            cryptographyConfiguration = cryptographyConfiguration ?? CsrfApplicationStartup.CryptographyConfiguration;

            var postHook = new PipelineItem<Action<NancyContext>>(
                CsrfHookName,
                context =>
                {
                    if (context.Response == null || context.Response.Cookies == null || context.Request.Method.Equals("OPTIONS", StringComparison.OrdinalIgnoreCase))
                    {
                        return;
                    }

                    if (context.Items.ContainsKey(CsrfToken.DEFAULT_CSRF_KEY))
                    {
                        context.Response.Cookies.Add(new NancyCookie(CsrfToken.DEFAULT_CSRF_KEY,
                                                                     (string)context.Items[CsrfToken.DEFAULT_CSRF_KEY],
                                                                     true));
                        return;
                    }

                    if (context.Request.Cookies.ContainsKey(CsrfToken.DEFAULT_CSRF_KEY))
                    {
                        var cookieValue = context.Request.Cookies[CsrfToken.DEFAULT_CSRF_KEY];
                        var cookieToken = CsrfApplicationStartup.ObjectSerializer.Deserialize(cookieValue) as CsrfToken;

                        if (CsrfApplicationStartup.TokenValidator.CookieTokenStillValid(cookieToken))
                        {
                            context.Items[CsrfToken.DEFAULT_CSRF_KEY] = cookieValue;
                            return;
                        }
                    }

                    var tokenString = GenerateTokenString(cryptographyConfiguration);

                    context.Items[CsrfToken.DEFAULT_CSRF_KEY] = tokenString;
                    context.Response.Cookies.Add(new NancyCookie(CsrfToken.DEFAULT_CSRF_KEY, tokenString, true));
                });

            pipelines.AfterRequest.AddItemToEndOfPipeline(postHook);
        }

        /// <summary>
        /// Disable csrf token generation
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        public static void Disable(IPipelines pipelines)
        {
            pipelines.AfterRequest.RemoveByName(CsrfHookName);
        }

        /// <summary>
        /// Creates a new csrf token for this response with an optional salt.
        /// Only necessary if a particular route requires a new token for each request.
        /// </summary>
        /// <param name="module">Nancy module</param>
        /// <returns></returns>
        public static void CreateNewCsrfToken(this INancyModule module, CryptographyConfiguration cryptographyConfiguration = null)
        {
            var tokenString = GenerateTokenString(cryptographyConfiguration);
            module.Context.Items[CsrfToken.DEFAULT_CSRF_KEY] = tokenString;
        }

        /// <summary>
        /// Creates a new csrf token with an optional salt.
        /// Does not store the token in context.
        /// </summary>
        /// <returns>The generated token</returns>
        internal static string GenerateTokenString(CryptographyConfiguration cryptographyConfiguration = null)
        {
            cryptographyConfiguration = cryptographyConfiguration ?? CsrfApplicationStartup.CryptographyConfiguration;
            var token = new CsrfToken
            {
                CreatedDate = DateTime.Now,
            };
            token.CreateRandomBytes();
            token.CreateHmac(cryptographyConfiguration.HmacProvider);
            var tokenString = CsrfApplicationStartup.ObjectSerializer.Serialize(token);
            return tokenString;
        }

        /// <summary>
        /// Validate that the incoming request has valid CSRF tokens.
        /// Throws <see cref="CsrfValidationException"/> if validation fails.
        /// </summary>
        /// <param name="module">Module object</param>
        /// <param name="validityPeriod">Optional validity period before it times out</param>
        /// <exception cref="CsrfValidationException">If validation fails</exception>
        public static void ValidateCsrfToken(this INancyModule module, TimeSpan? validityPeriod = null)
        {
            var request = module.Request;

            if (request == null)
            {
                return;
            }

            var cookieToken = GetCookieToken(request);
            var providedToken = GetProvidedToken(request);

            var result = CsrfApplicationStartup.TokenValidator.Validate(cookieToken, providedToken, validityPeriod);

            if (result != CsrfTokenValidationResult.Ok)
            {
                throw new CsrfValidationException(result);
            }
        }

        private static CsrfToken GetProvidedToken(Request request)
        {
            CsrfToken providedToken = null;

            var providedTokenString = request.Form[CsrfToken.DEFAULT_CSRF_KEY].Value ?? request.Headers[CsrfToken.DEFAULT_CSRF_KEY].FirstOrDefault();
            if (providedTokenString != null)
            {
                providedToken = CsrfApplicationStartup.ObjectSerializer.Deserialize(providedTokenString) as CsrfToken;
            }

            return providedToken;
        }

        private static CsrfToken GetCookieToken(Request request)
        {
            CsrfToken cookieToken = null;

            string cookieTokenString;
            if (request.Cookies.TryGetValue(CsrfToken.DEFAULT_CSRF_KEY, out cookieTokenString))
            {
                cookieToken = CsrfApplicationStartup.ObjectSerializer.Deserialize(cookieTokenString) as CsrfToken;
            }

            return cookieToken;
        }
    }
}
namespace Nancy.Security
{
    using Nancy.Bootstrapper;
    using Nancy.Cryptography;

    /// <summary>
    /// Wires up the CSRF (anti-forgery token) support at application startup.
    /// </summary>
    public class CsrfApplicationStartup : IApplicationStartup
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CsrfApplicationStartup"/> class, using the
        /// provided <paramref name="cryptographyConfiguration"/>, <paramref name="objectSerializer"/> and <paramref name="tokenValidator"/>.
        /// </summary>
        /// <param name="cryptographyConfiguration">The cryptographic configuration to use.</param>
        /// <param name="objectSerializer">The serializer that should be used.</param>
        /// <param name="tokenValidator">The token validator that should be used.</param>
        public CsrfApplicationStartup(CryptographyConfiguration cryptographyConfiguration, IObjectSerializer objectSerializer, ICsrfTokenValidator tokenValidator)
        {
            CryptographyConfiguration = cryptographyConfiguration;
            ObjectSerializer = objectSerializer;
            TokenValidator = tokenValidator;
        }

        /// <summary>
        /// Gets the configured crypto config
        /// </summary>
        internal static CryptographyConfiguration CryptographyConfiguration { get; private set; }

        /// <summary>
        /// Gets the configured object serialiser
        /// </summary>
        internal static IObjectSerializer ObjectSerializer { get; private set; }

        /// <summary>
        /// Gets the configured token validator
        /// </summary>
        internal static ICsrfTokenValidator TokenValidator { get; private set; }

        /// <summary>
        /// Perform any initialisation tasks
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        public void Initialize(IPipelines pipelines)
        {
        }
    }
}
namespace Nancy.Security
{
    using System;
    using System.Linq;

    /// <summary>
    /// Represents a Csrf protection token
    /// </summary>
    [Serializable]
    public sealed class CsrfToken
    {
        /// <summary>
        /// The default key for the csrf cookie/form value/querystring value
        /// </summary>
        public const string DEFAULT_CSRF_KEY = "NCSRF";

        /// <summary>
        /// Randomly generated bytes
        /// </summary>
        public byte[] RandomBytes { get; set; }

        /// <summary>
        /// Date and time the token was created
        /// </summary>
        public DateTime CreatedDate { get; set; }

        /// <summary>
        /// Tamper prevention hmac
        /// </summary>
        public byte[] Hmac { get; set; }

        public bool Equals(CsrfToken other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return this.RandomBytes.SequenceEqual(other.RandomBytes)
                && other.CreatedDate.Equals(this.CreatedDate)
                && this.Hmac.SequenceEqual(other.Hmac);
        }

        /// <summary>
        /// Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
        /// </returns>
        /// <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><filterpriority>2</filterpriority>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != typeof(CsrfToken)) return false;
            return Equals((CsrfToken)obj);
        }

        /// <summary>
        /// Serves as a hash function for a particular type.
        /// </summary>
        /// <returns>
        /// A hash code for the current <see cref="T:System.Object"/>.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        public override int GetHashCode()
        {
            unchecked
            {
                int result = (this.RandomBytes != null ? this.RandomBytes.GetHashCode() : 0);
                result = (result * 397) ^ this.CreatedDate.GetHashCode();
                result = (result * 397) ^ (this.Hmac != null ? this.Hmac.GetHashCode() : 0);
                return result;
            }
        }

        public static bool operator ==(CsrfToken left, CsrfToken right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(CsrfToken left, CsrfToken right)
        {
            return !Equals(left, right);
        }
    }
}
namespace Nancy.Security
{
    using System;
    using System.Linq;
    using System.Security.Cryptography;

    using Nancy.Cryptography;

    public static class CsrfTokenExtensions
    {
        private static readonly RandomNumberGenerator randomGenerator = new RNGCryptoServiceProvider();

        /// <summary>
        /// Gets a byte array representation of the csrf token for generating
        /// hmacs
        /// </summary>
        /// <param name="token">Token</param>
        /// <returns>Byte array representing the token</returns>
        public static byte[] GetCsrfTokenBytes(this CsrfToken token)
        {
            return token.RandomBytes
                        .Concat(BitConverter.GetBytes(token.CreatedDate.Ticks))
                        .ToArray();
        }

        /// <summary>
        /// Calculates and sets the Hmac property on a given token
        /// </summary>
        /// <param name="token">Token</param>
        /// <param name="hmacProvider">Hmac provider to use</param>
        /// <returns>Hmac bytes</returns>
        public static void CreateHmac(this CsrfToken token, IHmacProvider hmacProvider)
        {
            token.Hmac = hmacProvider.GenerateHmac(token.GetCsrfTokenBytes());
        }

        /// <summary>
        /// Creates random bytes for the csrf token
        /// </summary>
        /// <returns>Random byte array</returns>
        public static void CreateRandomBytes(this CsrfToken token)
        {
            var randomBytes = new byte[10];

            randomGenerator.GetBytes(randomBytes);

            token.RandomBytes = randomBytes;
        }
    }
}
namespace Nancy.Security
{
    using System;

    public class CsrfValidationException : Exception
    {
        public CsrfTokenValidationResult Result { get; private set; }

        public CsrfValidationException(CsrfTokenValidationResult result)
            : base(result.ToString())
        {
            Result = result;
        }
    }
}
namespace Nancy.Security
{
    using System;
    using System.Linq;

    using Nancy.Cryptography;

    /// <summary>
    /// The default implementation of the <see cref="ICsrfTokenValidator"/> interface.
    /// </summary>
    public class DefaultCsrfTokenValidator : ICsrfTokenValidator
    {
        private readonly IHmacProvider hmacProvider;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultCsrfTokenValidator"/> class,
        /// using the provided <paramref name="cryptoConfig"/>.
        /// </summary>
        /// <param name="cryptoConfig">The <see cref="CryptographyConfiguration"/> that should be used.</param>
        public DefaultCsrfTokenValidator(CryptographyConfiguration cryptoConfig)
        {
            this.hmacProvider = cryptoConfig.HmacProvider;
        }

        /// <summary>
        /// Validates a pair of tokens
        /// </summary>
        /// <param name="tokenOne">First token (usually from either a form post or querystring)</param>
        /// <param name="tokenTwo">Second token (usually from a cookie)</param>
        /// <param name="validityPeriod">Optional period that the tokens are valid for</param>
        /// <returns>Token validation result</returns>
        public CsrfTokenValidationResult Validate(CsrfToken tokenOne, CsrfToken tokenTwo, TimeSpan? validityPeriod = new TimeSpan?())
        {
            if (tokenOne == null || tokenTwo == null)
            {
                return CsrfTokenValidationResult.TokenMissing;
            }

            if (!tokenOne.Equals(tokenTwo))
            {
                return CsrfTokenValidationResult.TokenMismatch;
            }

            if (tokenOne.RandomBytes == null || tokenOne.RandomBytes.Length == 0)
            {
                return CsrfTokenValidationResult.TokenTamperedWith;
            }

            var newToken = new CsrfToken
            {
                CreatedDate = tokenOne.CreatedDate,
                RandomBytes = tokenOne.RandomBytes,
            };
            newToken.CreateHmac(this.hmacProvider);
            if (!newToken.Hmac.SequenceEqual(tokenOne.Hmac))
            {
                return CsrfTokenValidationResult.TokenTamperedWith;
            }

            if (validityPeriod.HasValue)
            {
                var expiryDate = tokenOne.CreatedDate.Add(validityPeriod.Value);

                if (DateTime.Now > expiryDate)
                {
                    return CsrfTokenValidationResult.TokenExpired;
                }
            }

            return CsrfTokenValidationResult.Ok;
        }

        /// <summary>
        /// Validates that a cookie token is still valid with the current configuration / keys
        /// </summary>
        /// <param name="cookieToken">Token to validate</param>
        /// <returns>True if valid, false otherwise</returns>
        public bool CookieTokenStillValid(CsrfToken cookieToken)
        {
            if (cookieToken == null || cookieToken.RandomBytes == null || cookieToken.RandomBytes.Length == 0)
            {
                return false;
            }

            var newToken = new CsrfToken
            {
                CreatedDate = cookieToken.CreatedDate,
                RandomBytes = cookieToken.RandomBytes,
            };
            newToken.CreateHmac(this.hmacProvider);

            if (!newToken.Hmac.SequenceEqual(cookieToken.Hmac))
            {
                return false;
            }

            return true;
        }
    }
}
namespace Nancy.Security
{
    using System;

    /// <summary>
    /// Validates Csrf tokens
    /// </summary>
    public interface ICsrfTokenValidator
    {
        /// <summary>
        /// Validates a pair of tokens
        /// </summary>
        /// <param name="tokenOne">First token (usually from either a form post or querystring)</param>
        /// <param name="tokenTwo">Second token (usually from a cookie)</param>
        /// <param name="validityPeriod">Optional period that the tokens are valid for</param>
        /// <returns>Token validation result</returns>
        CsrfTokenValidationResult Validate(CsrfToken tokenOne, CsrfToken tokenTwo, TimeSpan? validityPeriod = null);

        /// <summary>
        /// Validates that a cookie token is still valid with the current configuration / keys
        /// </summary>
        /// <param name="cookieToken">Token to validate</param>
        /// <returns>True if valid, false otherwise</returns>
        bool CookieTokenStillValid(CsrfToken cookieToken);
    }
}
namespace Nancy.Security
{
    /// <summary>
    /// Result of Csrf Token validation
    /// </summary>
    public enum CsrfTokenValidationResult
    {
        /// <summary>
        /// Validated ok
        /// </summary>
        Ok,

        /// <summary>
        /// One or both of the tokens appears to have been tampered with
        /// </summary>
        TokenTamperedWith,

        /// <summary>
        /// One or both of the tokens are missing
        /// </summary>
        TokenMissing,

        /// <summary>
        /// Tokens to not match
        /// </summary>
        TokenMismatch,

        /// <summary>
        /// Token is valid, but has expired
        /// </summary>
        TokenExpired,
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    using Nancy.Cookies;
    using Nancy.Responses;

    /// <summary>
    /// Containing extensions for the <see cref="Response"/> object.
    /// </summary>
    public static class ResponseExtensions
    {
        /// <summary>
        /// Force the response to be downloaded as an attachment
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="fileName">Filename for the download</param>
        /// <param name="contentType">Optional content type</param>
        /// <returns>Modified Response object</returns>
        public static Response AsAttachment(this Response response, string fileName = null, string contentType = null)
        {
            var actualFilename = fileName;

            if (actualFilename == null && response is GenericFileResponse)
            {
                actualFilename = ((GenericFileResponse)response).Filename;
            }

            if (string.IsNullOrEmpty(actualFilename))
            {
                throw new ArgumentException("fileName cannot be null or empty");
            }

            if (contentType != null)
            {
                response.ContentType = contentType;
            }

            return response.WithHeader("Content-Disposition", "attachment; filename=" + actualFilename);
        }

        /// <summary>
        /// Adds a <see cref="INancyCookie"/> to the response.
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="name">The name of the cookie.</param>
        /// <param name="value">The value of the cookie.</param>
        /// <returns>The <see cref="Response"/> instance.</returns>
        public static Response WithCookie(this Response response, string name, string value)
        {
            return WithCookie(response, name, value, null, null, null);
        }

        /// <summary>
        /// Adds a <see cref="INancyCookie"/> to the response.
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="name">The name of the cookie.</param>
        /// <param name="value">The value of the cookie.</param>
        /// <param name="expires">The expiration date of the cookie. Can be <see langword="null" /> if it should expire at the end of the session.</param>
        /// <returns>The <see cref="Response"/> instance.</returns>
        public static Response WithCookie(this Response response, string name, string value, DateTime? expires)
        {
            return WithCookie(response, name, value, expires, null, null);
        }

        /// <summary>
        /// Adds a <see cref="INancyCookie"/> to the response.
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="name">The name of the cookie.</param>
        /// <param name="value">The value of the cookie.</param>
        /// <param name="expires">The expiration date of the cookie. Can be <see langword="null" /> if it should expire at the end of the session.</param>
        /// <param name="domain">The domain of the cookie.</param>
        /// <param name="path">The path of the cookie.</param>
        /// <returns>The <see cref="Response"/> instance.</returns>
        public static Response WithCookie(this Response response, string name, string value, DateTime? expires, string domain, string path)
        {
            return WithCookie(response, new NancyCookie(name, value) { Expires = expires, Domain = domain, Path = path });
        }

        /// <summary>
        /// Adds a <see cref="INancyCookie"/> to the response.
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="nancyCookie">A <see cref="INancyCookie"/> instance.</param>
        /// <returns></returns>
        public static Response WithCookie(this Response response, INancyCookie nancyCookie)
        {
            response.Cookies.Add(nancyCookie);
            return response;
        }

        /// <summary>
        /// Add a header to the response
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="header">Header name</param>
        /// <param name="value">Header value</param>
        /// <returns>Modified response</returns>
        public static Response WithHeader(this Response response, string header, string value)
        {
            return response.WithHeaders(new { Header = header, Value = value });
        }

        /// <summary>
        /// Adds headers to the response using anonymous types
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="headers">
        /// Array of headers - each header should be an anonymous type with two string properties 
        /// 'Header' and 'Value' to represent the header name and its value.
        /// </param>
        /// <returns>Modified response</returns>
        public static Response WithHeaders(this Response response, params object[] headers)
        {
            return response.WithHeaders(headers.Select(GetTuple).ToArray());
        }

        /// <summary>
        /// Adds headers to the response using anonymous types
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="headers">
        /// Array of headers - each header should be a Tuple with two string elements 
        /// for header name and header value
        /// </param>
        /// <returns>Modified response</returns>
        public static Response WithHeaders(this Response response, params Tuple<string, string>[] headers)
        {
            if (response.Headers == null)
            {
                response.Headers = new Dictionary<string, string>();
            }

            foreach (var keyValuePair in headers)
            {
                response.Headers[keyValuePair.Item1] = keyValuePair.Item2;
            }

            return response;
        }

        /// <summary>
        /// Sets the content type of the response
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="contentType">The type of the content</param>
        /// <returns>Modified response</returns>
        public static Response WithContentType(this Response response, string contentType)
        {
            response.ContentType = contentType;
            return response;
        }

        /// <summary>
        /// Sets the status code of the response
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="statusCode">The http status code</param>
        /// <returns>Modified response</returns>
        public static Response WithStatusCode(this Response response, HttpStatusCode statusCode)
        {
            response.StatusCode = statusCode;
            return response;
        }

        /// <summary>
        /// Sets the status code of the response
        /// </summary>
        /// <param name="response">Response object</param>
        /// <param name="statusCode">The http status code</param>
        /// <returns>Modified response</returns>
        public static Response WithStatusCode(this Response response, int statusCode)
        {
            response.StatusCode = (HttpStatusCode)statusCode;
            return response;
        }

        private static Tuple<string, string> GetTuple(object header)
        {
            var properties = header.GetType()
                                   .GetProperties()
                                   .Where(prop => prop.CanRead && prop.PropertyType == typeof(string))
                                   .ToArray();

            var headerProperty = properties
                                    .Where(p => string.Equals(p.Name, "Header", StringComparison.OrdinalIgnoreCase))
                                    .FirstOrDefault();

            var valueProperty = properties
                                    .Where(p => string.Equals(p.Name, "Value", StringComparison.OrdinalIgnoreCase))
                                    .FirstOrDefault();

            if (headerProperty == null || valueProperty == null)
            {
                throw new ArgumentException("Unable to extract 'Header' or 'Value' properties from anonymous type.");
            }

            return Tuple.Create(
                (string)headerProperty.GetValue(header, null),
                (string)valueProperty.GetValue(header, null));
        }
    }
}
namespace Nancy
{
    using System;
    using System.Diagnostics;
    using System.Linq;
    using Nancy.Bootstrapper;
    using Nancy.Diagnostics;

    public static class StaticConfiguration
    {
        static StaticConfiguration()
        {
            CaseSensitive = false;
            RequestQueryFormMultipartLimit = 1000;
            AllowFileStreamUploadAsync = true;
        }

        /// <summary>
        /// Gets or sets a value indicating whether or not to enable case sensitivity in query, parameters (DynamicDictionary) and model binding. Enable this to conform with RFC3986.
        /// </summary>
        [Description("Enable case sensitivity in query, parameters (DynamicDictionary) and model binding. Enable this to conform with RFC3986.")]
        public static bool CaseSensitive { get; set; }

        /// <summary>
        /// Gets or sets the limit on the number of query string variables, form fields,
        /// or multipart sections in a request.
        /// </summary>
        public static int RequestQueryFormMultipartLimit { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether or not to disable request stream switching
        /// </summary>
        public static bool? DisableRequestStreamSwitching { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="Nancy.StaticConfiguration"/> allow file stream
        /// upload async due to mono issues before v4.  Uploads of over 80mb would result in extra padded chars to the filestream corrupting the file.
        /// </summary>
        /// <value><c>true</c> if allow file stream upload async; otherwise, <c>false</c>.</value>
        public static bool AllowFileStreamUploadAsync { get; set; }
    }
}
namespace Nancy
{
    /// <summary>
    /// Configuration for tracing.
    /// </summary>
    public class TraceConfiguration
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TraceConfiguration"/> class.
        /// </summary>
        /// <param name="enabled">Determines if tracing should be enabled.</param>
        /// <param name="displayErrorTraces">Determines if traces should be displayed in error messages.</param>
        public TraceConfiguration(bool enabled, bool displayErrorTraces)
        {
            this.Enabled = enabled;
            this.DisplayErrorTraces = displayErrorTraces;
        }

        /// <summary>
        /// Gets a value indicating whether or not to enable request tracing.
        /// </summary>
        /// <value><see langword="true"/> if tracing should be enabled, otherwise <see langword="false"/>.</value>
        public bool Enabled { get; private set; }

        /// <summary>
        /// Gets a value indicating whether or not to display traces in error messages.
        /// </summary>
        /// <value><see langword="true"/> traces should be displayed in error messages, otherwise <see langword="false"/>.</value>
        public bool DisplayErrorTraces { get; private set; }
    }
}
namespace Nancy
{
    using Nancy.Configuration;

    /// <summary>
    /// Contains <see cref="TraceConfiguration"/> configuration extensions for <see cref="INancyEnvironment"/>.
    /// </summary>
    public static class TraceConfigurationExtensions
    {
        /// <summary>
        /// Configures <see cref="TraceConfiguration"/>.
        /// </summary>
        /// <param name="environment">An <see cref="INancyEnvironment"/> that should be configured.</param>
        /// <param name="enabled"><see langword="true"/> if tracing should be enabled, otherwise <see langword="false"/>.</param>
        /// <param name="displayErrorTraces"><see langword="true"/> traces should be displayed in error messages, otherwise <see langword="false"/>.</param>
        public static void Tracing(this INancyEnvironment environment, bool enabled, bool displayErrorTraces)
        {
            environment.AddValue(new TraceConfiguration(
                enabled: enabled,
                displayErrorTraces: displayErrorTraces));
        }
    }
}
namespace Nancy
{
    using System;
    using System.Net;
    using System.Net.Sockets;
    using System.Text;

    /// <summary>
    /// Represents a full Url of the form scheme://hostname:port/basepath/path?query
    /// </summary>
    /// <remarks>Since this is for  internal use, and fragments are not passed to the server, fragments are not supported.</remarks>
    public sealed class Url : ICloneable
    {
        private string basePath;

        private string query;

        /// <summary>
        /// Creates an instance of the <see cref="Url" /> class
        /// </summary>
        public Url()
        {
            this.Scheme = Uri.UriSchemeHttp;
            this.HostName = string.Empty;
            this.Port = null;
            this.BasePath = string.Empty;
            this.Path = string.Empty;
            this.Query = string.Empty;
        }

        /// <summary>
        /// Creates an instance of the <see cref="Url" /> class
        /// </summary>
        /// <param name="url">A <see cref="string" /> containing a URL.</param>
        public Url(string url)
        {
            var uri = new Uri(url);
            this.HostName = uri.Host;
            this.Path = uri.LocalPath;
            this.Port = uri.Port;
            this.Query = uri.Query;
            this.Scheme = uri.Scheme;
        }

        /// <summary>
        /// Gets or sets the HTTP protocol used by the client.
        /// </summary>
        /// <value>The protocol.</value>
        public string Scheme { get; set; }

        /// <summary>
        /// Gets the hostname of the request
        /// </summary>
        public string HostName { get; set; }

        /// <summary>
        /// Gets the port name of the request
        /// </summary>
        public int? Port { get; set; }

        /// <summary>
        /// Gets the base path of the request i.e. the "Nancy root"
        /// </summary>
        public string BasePath
        {
            get { return this.basePath; }
            set { this.basePath = (value ?? string.Empty).TrimEnd('/'); }
        }

        /// <summary>
        /// Gets the path of the request, relative to the base path
        /// This property drives the route matching
        /// </summary>
        public string Path { get; set; }

        /// <summary>
        /// Gets the querystring data of the requested resource.
        /// </summary>
        public string Query
        {
            get { return this.query; }
            set { this.query = GetQuery(value); }
        }

        /// <summary>
        /// Gets the domain part of the request
        /// </summary>
        public string SiteBase
        {
            get
            {
                return new StringBuilder()
                    .Append(this.Scheme)
                    .Append(Uri.SchemeDelimiter)
                    .Append(GetHostName(this.HostName))
                    .Append(GetPort(this.Port))
                    .ToString();
            }
        }

        /// <summary>
        /// Gets whether the url is secure or not.
        /// </summary>
        public bool IsSecure
        {
            get
            {
                return Uri.UriSchemeHttps.Equals(this.Scheme, StringComparison.OrdinalIgnoreCase);
            }
        }

        public override string ToString()
        {
            return new StringBuilder()
                .Append(this.Scheme)
                .Append(Uri.SchemeDelimiter)
                .Append(GetHostName(this.HostName))
                .Append(GetPort(this.Port))
                .Append(GetCorrectPath(this.BasePath))
                .Append(GetCorrectPath(this.Path))
                .Append(this.Query)
                .ToString();
        }

        /// <summary>
        /// Clones the url.
        /// </summary>
        /// <returns>Returns a new cloned instance of the url.</returns>
        object ICloneable.Clone()
        {
            return this.Clone();
        }

        /// <summary>
        /// Clones the url.
        /// </summary>
        /// <returns>Returns a new cloned instance of the url.</returns>
        public Url Clone()
        {
            return new Url
            {
                BasePath = this.BasePath,
                HostName = this.HostName,
                Port = this.Port,
                Query = this.Query,
                Path = this.Path,
                Scheme = this.Scheme
            };
        }

        /// <summary>
        /// Casts the current <see cref="Url"/> instance to a <see cref="string"/> instance.
        /// </summary>
        /// <param name="url">The instance that should be cast.</param>
        /// <returns>A <see cref="string"/> representation of the <paramref name="url"/>.</returns>
        public static implicit operator string(Url url)
        {
            return url.ToString();
        }

        /// <summary>
        /// Casts the current <see cref="string"/> instance to a <see cref="Url"/> instance.
        /// </summary>
        /// <param name="url">The instance that should be cast.</param>
        /// <returns>An <see cref="Url"/> representation of the <paramref name="url"/>.</returns>
        public static implicit operator Url(string url)
        {
            return new Uri(url);
        }

        /// <summary>
        /// Casts the current <see cref="Url"/> instance to a <see cref="Uri"/> instance.
        /// </summary>
        /// <param name="url">The instance that should be cast.</param>
        /// <returns>An <see cref="Uri"/> representation of the <paramref name="url"/>.</returns>
        public static implicit operator Uri(Url url)
        {
            return new Uri(url.ToString(), UriKind.Absolute);
        }

        /// <summary>
        /// Casts a <see cref="Uri"/> instance to a <see cref="Url"/> instance
        /// </summary>
        /// <param name="uri">The instance that should be cast.</param>
        /// <returns>An <see cref="Url"/> representation of the <paramref name="uri"/>.</returns>
        public static implicit operator Url(Uri uri)
        {
            if (uri.IsAbsoluteUri)
            {
                return new Url
                {
                    HostName = uri.Host,
                    Path = uri.LocalPath,
                    Port = uri.Port,
                    Query = uri.Query,
                    Scheme = uri.Scheme
                };
            }

            return new Url { Path = uri.OriginalString };
        }

        private static string GetQuery(string query)
        {
            return string.IsNullOrEmpty(query) ? string.Empty : (query[0] == '?' ? query : '?' + query);
        }

        private static string GetCorrectPath(string path)
        {
            return (string.IsNullOrEmpty(path) || path.Equals("/")) ? string.Empty : path;
        }

        private static string GetPort(int? port)
        {
            return port.HasValue ? string.Concat(":", port.Value) : string.Empty;
        }

        private static string GetHostName(string hostName)
        {
            IPAddress address;

            if (IPAddress.TryParse(hostName, out address))
            {
                var addressString = address.ToString();

                return address.AddressFamily == AddressFamily.InterNetworkV6
                    ? string.Format("[{0}]", addressString)
                    : addressString;
            }

            return hostName;
        }
    }
}
namespace Nancy.Validation
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// A composite validator to combine other validators.
    /// </summary>
    public class CompositeValidator : IModelValidator
    {
        private readonly IEnumerable<IModelValidator> validators;

        /// <summary>
        /// Initializes a new instance of the <see cref="CompositeValidator"/> class.
        /// </summary>
        /// <param name="validators">The validators.</param>
        /// <param name="modelType">The type of the model that is being validated.</param>
        public CompositeValidator(IEnumerable<IModelValidator> validators, Type modelType)
        {
            var modelValidators =
                validators.ToArray();

            this.ModelType = modelType;
            this.Description = CreateCompositeDescription(modelValidators, modelType);
            this.validators = modelValidators;
        }

        /// <summary>
        /// Gets the description of the validator.
        /// </summary>
        public ModelValidationDescriptor Description { get; private set; }

        /// <summary>
        /// The type of the model that is being validated by the validator.
        /// </summary>
        public Type ModelType { get; private set; }

        /// <summary>
        /// Validates the specified instance.
        /// </summary>
        /// <param name="instance">The instance that should be validated.</param>
        /// <param name="context">The <see cref="NancyContext"/> of the current request.</param>
        /// <returns>A <see cref="ModelValidationResult"/> with the result of the validation.</returns>
        public ModelValidationResult Validate(object instance, NancyContext context)
        {
            var errors = validators
                .Select(v => v.Validate(instance, context))
                .Where(r => r != null)
                .SelectMany(r => r.Errors)
                .ToDictionary(x => x.Key, x => x.Value);

            return (!errors.Any()) ?
                new ModelValidationResult() :
                new ModelValidationResult(errors);
        }

        private static ModelValidationDescriptor CreateCompositeDescription(IEnumerable<IModelValidator> validators, Type modelType)
        {
            var rules = validators
                .SelectMany(v => v.Description.Rules)
                .ToDictionary(x => x.Key, x => x.Value);

            return new ModelValidationDescriptor(rules, modelType);
        }
    }
}
namespace Nancy.Validation
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// The default Nancy implementation of IValidatorLocator.
    /// </summary>
    public class DefaultValidatorLocator : IModelValidatorLocator
    {
        private readonly ConcurrentDictionary<Type, IModelValidator> cachedValidators;
        private readonly IEnumerable<IModelValidatorFactory> factories;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValidatorLocator"/> class.
        /// </summary>
        /// <param name="factories">The factories.</param>
        public DefaultValidatorLocator(IEnumerable<IModelValidatorFactory> factories)
        {
            this.cachedValidators =
                new ConcurrentDictionary<Type, IModelValidator>();

            this.factories = factories ?? Enumerable.Empty<IModelValidatorFactory>();
        }

        /// <summary>
        /// Gets a validator for a given type.
        /// </summary>
        /// <param name="type">The type to validate.</param>
        /// <returns>An <see cref="IModelValidator"/> instance or <see langword="null"/> if none found.</returns>
        public IModelValidator GetValidatorForType(Type type)
        {
            if (!this.factories.Any())
            {
                throw new ModelValidationException("No model validator factory could be located. Please ensure that you have an appropriate validation package installed, such as one of the Nancy.Validation packages.");
            }

            return cachedValidators.GetOrAdd(type, CreateValidator);
        }

        private IModelValidator CreateValidator(Type type)
        {
            var validators = this.factories
                .Select(factory => factory.Create(type))
                .Where(validator => validator != null)
                .ToArray();

            if (!validators.Any())
            {
                return null;
            }

            return (validators.Length == 1) ?
                validators[0] :
                new CompositeValidator(validators, type);
        }
    }
}
namespace Nancy.Validation
{
    using System;

    /// <summary>
    /// Provides a way to validate a type as well as a description to use for client-side validation.
    /// </summary>
    public interface IModelValidator
    {
        /// <summary>
        /// Gets the description of the validator.
        /// </summary>
        ModelValidationDescriptor Description { get; }

        /// <summary>
        /// Gets the <see cref="Type"/> of the model that is being validated by the validator.
        /// </summary>
        Type ModelType { get; }

        /// <summary>
        /// Validates the specified instance.
        /// </summary>
        /// <param name="instance">The instance that should be validated.</param>
        /// <param name="context">The <see cref="NancyContext"/> of the current request.</param>
        /// <returns>A <see cref="ModelValidationResult"/> with the result of the validation.</returns>
        ModelValidationResult Validate(object instance, NancyContext context);
    }
}
namespace Nancy.Validation
{
    using System;

    /// <summary>
    /// Creates instances of IValidator.
    /// </summary>
    public interface IModelValidatorFactory
    {
        /// <summary>
        /// Creates a validator for the given type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>A validator for the given type or null if none exists.</returns>
        IModelValidator Create(Type type);
    }
}
namespace Nancy.Validation
{
    using System;

    /// <summary>
    /// Locates a validator for a given type.
    /// </summary>
    public interface IModelValidatorLocator
    {
        /// <summary>
        /// Gets a validator for a given type.
        /// </summary>
        /// <param name="type">The type to validate.</param>
        /// <returns>An <see cref="IModelValidator"/> instance or <see langword="null"/> if none found.</returns>
        IModelValidator GetValidatorForType(Type type);
    }
}
namespace Nancy.Validation
{
    using System;

    /// <summary>
    /// Exception that is thrown during problems with model validation.
    /// </summary>
    public class ModelValidationException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationException"/> class.
        /// </summary>
        public ModelValidationException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationException"/> class,
        /// with the provided <paramref name="message"/>.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public ModelValidationException(string message) : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationException"/> class,
        /// with the provided <paramref name="message"/> and <paramref name="innerException"/>
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
        public ModelValidationException(string message, Exception innerException) : base(message, innerException)
        {
        }
    }
}
namespace Nancy.Validation
{
    using System.Linq;

    /// <summary>
    /// Extensions to <see cref="INancyModule"/> for validation.
    /// </summary>
    public static class ModuleExtensions
    {
        /// <summary>
        /// Performs validation on the specified <paramref name="instance"/>.
        /// </summary>
        /// <typeparam name="T">The type of the <paramref name="instance"/> that is being validated.</typeparam>
        /// <param name="module">The module that the validation is performed from.</param>
        /// <param name="instance">The instance that is being validated.</param>
        /// <returns>A <see cref="ModelValidationResult"/> instance.</returns>
        public static ModelValidationResult Validate<T>(this INancyModule module, T instance)
        {
            var validator =
                module.ValidatorLocator.GetValidatorForType(typeof(T));

            var result = (validator == null) ?
                new ModelValidationResult() :
                validator.Validate(instance, module.Context);

            if (module.ModelValidationResult.Errors.Any())
            {
                module.ModelValidationResult.Errors =
                    module.ModelValidationResult.Errors.Concat(result.Errors).ToDictionary(key => key.Key, val => val.Value);
            }

            module.ModelValidationResult = module.ModelValidationResult.Errors.Any()
                                               ? module.ModelValidationResult
                                               : result;

            return module.ModelValidationResult;
        }
    }
}
namespace Nancy.Validation.Rules
{
    /// <summary>
    /// Specifies the validation comparison operators used by the <see cref="ComparisonValidationRule"/> type.
    /// </summary>
    public enum ComparisonOperator
    {
        /// <summary>
        /// A comparison for greater than.
        /// </summary>
        GreaterThan,

        /// <summary>
        /// A comparison for greater than or equal to.
        /// </summary>
        GreaterThanOrEqual,

        /// <summary>
        /// A comparison for less than.
        /// </summary>
        LessThan,

        /// <summary>
        /// A comparison for less than or equal to.
        /// </summary>
        LessThanOrEqual,

        /// <summary>
        /// A comparison for equality.
        /// </summary>
        Equal,

        /// <summary>
        /// A comparison for inequality.
        /// </summary>
        NotEqual
    }
}
namespace Nancy.Validation.Rules
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Implementation of <see cref="ModelValidationRule"/> for ensuring a string does not
    /// contain an empty value.
    /// </summary>
    public class NotEmptyValidationRule : ModelValidationRule
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NotEmptyValidationRule"/> class.
        /// </summary>
        /// <param name="errorMessageFormatter">The error message formatter.</param>
        /// <param name="memberNames">The member names.</param>
        public NotEmptyValidationRule(Func<string, string> errorMessageFormatter, IEnumerable<string> memberNames)
            : base("NotEmpty", errorMessageFormatter, memberNames)
        {
        }
    }
}
namespace Nancy.Validation.Rules
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Implementation of <see cref="ModelValidationRule"/> for ensuring a string is not null.
    /// </summary>
    public class NotNullValidationRule : ModelValidationRule
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NotNullValidationRule"/> class.
        /// </summary>
        /// <param name="errorMessageFormatter">The error message formatter.</param>
        /// <param name="memberNames">The member names.</param>
        public NotNullValidationRule(Func<string, string> errorMessageFormatter, IEnumerable<string> memberNames)
            : base("NotNull", errorMessageFormatter, memberNames)
        {
        }
    }
}
namespace Nancy.Validation.Rules
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Implementation of <see cref="ModelValidationRule"/> for comparing two values using a
    /// provided <see cref="ComparisonOperator"/>.
    /// </summary>
    public class ComparisonValidationRule : ModelValidationRule
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ComparisonValidationRule"/> class.
        /// </summary>
        /// <param name="errorMessageFormatter">The error message formatter.</param>
        /// <param name="memberNames">The member names.</param>
        /// <param name="operator">The <see cref="ComparisonOperator"/> that should be used when comparing values.</param>
        /// <param name="value">Gets the value to compare against.</param>
        public ComparisonValidationRule(Func<string, string> errorMessageFormatter, IEnumerable<string> memberNames, ComparisonOperator @operator, object value)
            : base("Comparison", errorMessageFormatter, memberNames)
        {
            this.Operator = @operator;
            this.Value = value;
        }

        /// <summary>
        /// The <see cref="ComparisonOperator"/> that should be used when comparing values.
        /// </summary>
        /// <value>A <see cref="ComparisonOperator"/> value.</value>
        public ComparisonOperator Operator { get; private set; }

        /// <summary>
        /// Gets the value to compare against.
        /// </summary>
        public object Value { get; private set; }
    }
}
namespace Nancy.Validation.Rules
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Implementation of <see cref="ModelValidationRule"/> for ensuring a string matches the
    /// pattern which is defined by a regex.
    /// </summary>
    public class RegexValidationRule : ModelValidationRule
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RegexValidationRule"/> class.
        /// </summary>
        /// <param name="errorMessageFormatter">The error message formatter.</param>
        /// <param name="memberNames">The member names.</param>
        /// <param name="pattern">The regex pattern that should be used to check for a match.</param>
        public RegexValidationRule(Func<string, string> errorMessageFormatter, IEnumerable<string> memberNames, string pattern)
            : base("Regex", errorMessageFormatter, memberNames)
        {
            this.Pattern = pattern;
        }

        /// <summary>
        /// The regex pattern that should be used to check for a match.
        /// </summary>
        public string Pattern { get; private set; }
    }
}
namespace Nancy.Validation.Rules
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Implementation of <see cref="ModelValidationRule"/> for ensuring that the length of a string
    /// is withing the specified range.
    /// </summary>
    public class StringLengthValidationRule : ModelValidationRule
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StringLengthValidationRule"/> class.
        /// </summary>
        /// <param name="errorMessageFormatter">The error message formatter.</param>
        /// <param name="memberNames">The member names.</param>
        /// <param name="minLength">Minimum allowed length of the string</param>
        /// <param name="maxLength">Maximum allowed length of the string</param>
        public StringLengthValidationRule(Func<string, string> errorMessageFormatter, IEnumerable<string> memberNames, int minLength, int maxLength)
            : base("StringLength", errorMessageFormatter, memberNames)
        {
            this.MinLength = minLength;
            this.MaxLength = maxLength;
        }

        /// <summary>
        /// Gets the length of the min.
        /// </summary>
        /// <value>The length of the min.</value>
        public int MinLength { get; private set; }

        /// <summary>
        /// Gets the length of the max.
        /// </summary>
        /// <value>The length of the max.</value>
        public int MaxLength { get; private set; }
    }
}
namespace Nancy.Validation
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// A description of the rules a validator provides.
    /// </summary>
    public class ModelValidationDescriptor
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationDescriptor"/> class.
        /// </summary>
        /// <param name="rules">The rules that describes the model.</param>
        /// <param name="modelType">The type of the model that the rules are defined for.</param>
        public ModelValidationDescriptor(IEnumerable<ModelValidationRule> rules, Type modelType)
            : this(GetModelValidationRuleDictionary(rules), modelType)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationDescriptor"/> class.
        /// </summary>
        /// <param name="rules">The rules that describes the model, grouped by member name.</param>
        /// <param name="modelType">The type of the model that the rules are defined for.</param>
        public ModelValidationDescriptor(IDictionary<string, IList<ModelValidationRule>> rules, Type modelType)
        {
            this.Rules = rules;
            this.ModelType = modelType;
        }

        /// <summary>
        /// The type of the model that is being described.
        /// </summary>
        public Type ModelType { get; private set; }

        /// <summary>
        /// Gets the rules.
        /// </summary>
        /// <value>An <see cref="IDictionary{TKey,TValue}"/> instance that contains <see cref="ModelValidationRule"/> instances grouped by property name.</value>
        public IDictionary<string, IList<ModelValidationRule>> Rules { get; private set; }

        private static IDictionary<string, IList<ModelValidationRule>> GetModelValidationRuleDictionary(IEnumerable<ModelValidationRule> rules)
        {
            var results =
                new Dictionary<string, IList<ModelValidationRule>>(StringComparer.OrdinalIgnoreCase);

            if (rules == null)
            {
                return results;
            }

            foreach (var rule in rules)
            {
                foreach (var name in rule.MemberNames)
                {
                    if (!results.ContainsKey(name))
                    {
                        results.Add(name, new List<ModelValidationRule>());
                    }

                    results[name].Add(rule);
                }
            }

            return results;
        }
    }
}
namespace Nancy.Validation
{
    using System.Collections.Generic;

    /// <summary>
    /// Represents a model validation error.
    /// </summary>
    public class ModelValidationError
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationError"/> class.
        /// </summary>
        /// <param name="memberName">Name of the member that the error describes.</param>
        /// <param name="errorMessage"></param>
        public ModelValidationError(string memberName, string errorMessage)
            : this(new[] { memberName }, errorMessage)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationError"/> class.
        /// </summary>
        /// <param name="memberNames">The member names that the error describes.</param>
        /// <param name="errorMessage"></param>
        public ModelValidationError(IEnumerable<string> memberNames, string errorMessage)
        {
            this.MemberNames = memberNames;
            this.ErrorMessage = errorMessage;
        }

        /// <summary>
        /// Gets the member names that are a part of the error.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains the name of the members.</value>
        public IEnumerable<string> MemberNames { get; private set; }

        /// <summary>
        /// 
        /// </summary>
        public string ErrorMessage { get; private set; }

        /// <summary>
        /// Implicitly cast a validation error to a string.
        /// </summary>
        /// <param name="error">The <see cref="ModelValidationError"/> that should be cast.</param>
        /// <returns>A <see cref="string"/> containing the validation error description.</returns>
        public static implicit operator string(ModelValidationError error)
        {
            return error.ErrorMessage;
        }

        /// <summary>
        /// Returns the <see cref="ErrorMessage"/>.
        /// </summary>
        /// <returns>A string containing the error message.</returns>
        public override string ToString()
        {
            return this.ErrorMessage;
        }
    }
}
namespace Nancy.Validation
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;

    /// <summary>
    /// Represents the result of a model validation.
    /// </summary>
    [DebuggerDisplay("IsValid = {IsValid}")]
    public class ModelValidationResult
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationResult"/> class.
        /// </summary>
        public ModelValidationResult()
            : this(Enumerable.Empty<ModelValidationError>())
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationResult"/> class.
        /// </summary>
        /// <param name="errors">The <see cref="ModelValidationError"/> instances that makes up the result.</param>
        public ModelValidationResult(IEnumerable<ModelValidationError> errors)
            : this(GetModelValidationErrorDictionary((errors ?? Enumerable.Empty<ModelValidationError>()).ToArray()))
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationResult"/> class.
        /// </summary>
        /// <param name="errors">The <see cref="ModelValidationError"/> instances that makes up the result, grouped by member name.</param>
        public ModelValidationResult(IDictionary<string, IList<ModelValidationError>> errors)
        {
            this.Errors = errors;
        }

        /// <summary>
        /// Gets the errors.
        /// </summary>
        /// <value>An <see cref="IDictionary{TKey,TValue}"/> instance that contains <see cref="ModelValidationError"/> instances grouped by property name.</value>
        public IDictionary<string, IList<ModelValidationError>> Errors { get; set; }

        /// <summary>
        /// Gets a clean representation of the errors.
        /// </summary>
        /// <returns></returns>
        public IEnumerable<dynamic> FormattedErrors
        {
            get
            {
                var result = this.Errors.Select(x => new { Key = x.Key, Errors = x.Value.Select(y => y.ErrorMessage).ToArray() });
                return result;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the validated instance is valid or not.
        /// </summary>
        /// <value><see langword="true"/> if the validated instance is valid; otherwise, <see langword="false"/>.</value>
        public bool IsValid
        {
            get { return !Errors.Keys.Any(); }
        }

        private static IDictionary<string, IList<ModelValidationError>> GetModelValidationErrorDictionary(ModelValidationError[] results)
        {
            var output =
                new Dictionary<string, IList<ModelValidationError>>(StringComparer.OrdinalIgnoreCase);

            if (results == null || !results.Any())
            {
                return output;
            }

            foreach (var result in results)
            {
                foreach (var name in result.MemberNames)
                {
                    if (!output.ContainsKey(name))
                    {
                        output.Add(name, new List<ModelValidationError>());
                    }

                    output[name].Add(result);
                }

                if (!result.MemberNames.Any() && !string.IsNullOrEmpty(result.ErrorMessage))
                {
                    if (!output.ContainsKey(string.Empty))
                    {
                        output.Add(string.Empty, new List<ModelValidationError>());
                    }

                    output[string.Empty].Add(result);
                }
            }

            return output;
        }
    }
}
namespace Nancy.Validation
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// A description of a validation rule.
    /// </summary>
    public class ModelValidationRule
    {
        private readonly Func<string, string> errorMessageFormatter;

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationRule"/> class.
        /// </summary>
        /// <param name="ruleType">Type of the rule.</param>
        /// <param name="errorMessageFormatter">The error message formatter.</param>
        public ModelValidationRule(string ruleType, Func<string, string> errorMessageFormatter)
        {
            if (ruleType == null)
            {
                throw new ArgumentNullException("ruleType");
            }

            if (errorMessageFormatter == null)
            {
                throw new ArgumentNullException("errorMessageFormatter");
            }

            this.RuleType = ruleType;
            this.errorMessageFormatter = errorMessageFormatter;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelValidationRule"/> class.
        /// </summary>
        /// <param name="ruleType">Type of the rule.</param>
        /// <param name="errorMessageFormatter">The error message formatter.</param>
        /// <param name="memberNames">Name of the member.</param>
        public ModelValidationRule(string ruleType, Func<string, string> errorMessageFormatter, IEnumerable<string> memberNames)
            : this(ruleType, errorMessageFormatter)
        {
            this.MemberNames = memberNames;
        }

        /// <summary>
        /// Gets the names of the members this rule validates.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> that contains the name of the member.</value>
        public IEnumerable<string> MemberNames { get; private set; }

        /// <summary>
        /// Gets the type of the rule.
        /// </summary>
        /// <value>The type of the rule.</value>
        public string RuleType { get; private set; }

        /// <summary>
        /// Gets the error message that this rule will provide upon error.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <returns>The error message.</returns>
        public string GetErrorMessage(string name)
        {
            return errorMessageFormatter(name);
        }
    }
}
namespace Nancy
{
    /// <summary>
    /// Configuration for view rendering.
    /// </summary>
    public class ViewConfiguration
    {
        /// <summary>
        /// A default instance of the <see cref="ViewConfiguration"/> class.
        /// </summary>
        public static readonly ViewConfiguration Default = new ViewConfiguration(
            runtimeViewDiscovery: false,
            runtimeViewUpdates: false);

        private ViewConfiguration()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ViewConfiguration"/> class.
        /// </summary>
        /// <param name="runtimeViewDiscovery">Determines if views can be discovered during runtime.</param>
        /// <param name="runtimeViewUpdates">Determines if views can be updated during runtime.</param>
        public ViewConfiguration(bool runtimeViewDiscovery = false, bool runtimeViewUpdates = false)
        {
            this.RuntimeViewDiscovery = runtimeViewDiscovery;
            this.RuntimeViewUpdates = runtimeViewUpdates;
        }

        /// <summary>
        /// Gets or sets a value indicating whether or not to enable runtime view discovery
        /// </summary>
        /// <value><see langword="true"/> if views can be discovered during runtime, otherwise <see langword="false"/>.</value>
        public bool RuntimeViewDiscovery { get; private set; }

        /// <summary>
        /// Gets a value indicating whether or not to allow runtime changes of views.
        /// </summary>
        /// <value><see langword="true"/> if views can be updated during runtime, otherwise <see langword="false"/>.</value>
        public bool RuntimeViewUpdates { get; private set; }
    }
}
namespace Nancy
{
    using Configuration;

    /// <summary>
    /// Contains <see cref="ViewConfiguration"/> configuration extensions for <see cref="INancyEnvironment"/>.
    /// </summary>
    public static class ViewConfigurationExtensions
    {
        /// <summary>
        /// Configures <see cref="ViewConfiguration"/>.
        /// </summary>
        /// <param name="environment">An <see cref="INancyEnvironment"/> that should be configured.</param>
        /// <param name="runtimeViewDiscovery"><see langword="true"/> if views can be discovered during runtime, otherwise <see langword="false"/>.</param>
        /// <param name="runtimeViewUpdates"><see langword="true"/> if views can be updated during runtime, otherwise <see langword="false"/>.</param>
        public static void Views(this INancyEnvironment environment, bool? runtimeViewDiscovery = false, bool? runtimeViewUpdates = false)
        {
            environment.AddValue(new ViewConfiguration(
                runtimeViewDiscovery: runtimeViewDiscovery ?? ViewConfiguration.Default.RuntimeViewDiscovery,
                runtimeViewUpdates: runtimeViewUpdates ?? ViewConfiguration.Default.RuntimeViewUpdates));
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;

    /// <summary>
    /// Default implementation for retrieving information about views that are stored on the file system.
    /// </summary>
    public class DefaultFileSystemReader : IFileSystemReader
    {
        /// <summary>
        /// Gets information about view that are stored in folders below the applications root path.
        /// </summary>
        /// <param name="path">The path of the folder where the views should be looked for.</param>
        /// <param name="supportedViewExtensions">A list of view extensions to look for.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> containing view locations and contents readers.</returns>
        public IEnumerable<Tuple<string, Func<StreamReader>>> GetViewsWithSupportedExtensions(string path, IEnumerable<string> supportedViewExtensions)
        {
            return supportedViewExtensions
                .SelectMany(extension => GetFilenames(path, extension))
                .Distinct()
                .Select(file => new Tuple<string, Func<StreamReader>>(file, () => new StreamReader(new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))))
                .ToList();
        }

        /// <summary>
        /// Gets the last modified time for the file specified
        /// </summary>
        /// <param name="filename">Filename</param>
        /// <returns>Time the file was last modified</returns>
        public DateTime GetLastModified(string filename)
        {
            return File.GetLastWriteTimeUtc(filename);
        }

        /// <summary>
        /// Gets information about specific views that are stored in folders below the applications root path.
        /// </summary>
        /// <param name="path">The path of the folder where the views should be looked for.</param>
        /// <param name="viewName">Name of the view to search for</param>
        /// <param name="supportedViewExtensions">A list of view extensions to look for.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> containing view locations and contents readers.</returns>
        public IEnumerable<Tuple<string, Func<StreamReader>>> GetViewsWithSupportedExtensions(string path, string viewName, IEnumerable<string> supportedViewExtensions)
        {
            return GetFilenames(path, viewName, supportedViewExtensions)
                       .Select(file => new Tuple<string, Func<StreamReader>>(file, () => new StreamReader(new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))))
                       .ToList();
        }

        private static IEnumerable<string> GetFilenames(string path, string viewName, IEnumerable<string> supportedViewExtensions)
        {
            return Directory.GetFiles(path, viewName + ".*", SearchOption.TopDirectoryOnly)
                            .Where(f => IsValidExtention(f, supportedViewExtensions));
        }

        private static bool IsValidExtention(string filename, IEnumerable<string> supportedViewExtensions)
        {
            var extension = Path.GetExtension(filename);

            if (string.IsNullOrEmpty(extension))
            {
                return false;
            }

            return supportedViewExtensions.Contains(extension.Substring(1));
        }

        private static IEnumerable<string> GetFilenames(string path, string extension)
        {
            return Directory.GetFiles(path, string.Concat("*.", extension), SearchOption.AllDirectories);
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.Collections.Generic;

    using Nancy.Extensions;
    using Nancy.Helpers;
    using Nancy.Localization;
    using Nancy.Security;

    /// <summary>
    /// Default render context implementation.
    /// </summary>
    public class DefaultRenderContext : IRenderContext
    {
        private readonly IViewResolver viewResolver;
        private readonly IViewCache viewCache;

        private readonly ITextResource textResource;

        private readonly ViewLocationContext viewLocationContext;

        private TextResourceFinder textResourceFinder;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultRenderContext"/> class.
        /// </summary>
        /// <param name="viewResolver"></param>
        /// <param name="viewCache"></param>
        /// <param name="textResource"></param>
        /// <param name="viewLocationContext"></param>
        public DefaultRenderContext(IViewResolver viewResolver, IViewCache viewCache, ITextResource textResource, ViewLocationContext viewLocationContext)
        {
            this.viewResolver = viewResolver;
            this.viewCache = viewCache;
            this.textResource = textResource;
            this.viewLocationContext = viewLocationContext;
            this.textResourceFinder = new TextResourceFinder(textResource, viewLocationContext.Context);
        }

        /// <summary>
        /// Gets the context of the current request.
        /// </summary>
        /// <value>A <see cref="NancyContext"/> instance.</value>
        public NancyContext Context
        {
            get { return this.viewLocationContext.Context; }
        }

        /// <summary>
        /// Gets the view cache that is used by Nancy.
        /// </summary>
        /// <value>An <see cref="IViewCache"/> instance.</value>
        public IViewCache ViewCache
        {
            get { return this.viewCache; }
        }

        /// <summary>
        /// Gets the text resource for localisation
        /// </summary>
        public ITextResource TextResource
        {
            get { return this.textResource; }
        }

        /// <summary>
        /// Gets the text resource finder for localisation
        /// </summary>
        public dynamic TextResourceFinder
        {
            get { return this.textResourceFinder; }
        }

        /// <summary>
        /// Parses a path and returns an absolute url path, taking into account
        /// base directory etc.
        /// </summary>
        /// <param name="input">Input url such as ~/styles/main.css</param>
        /// <returns>Parsed absolute url path</returns>
        public string ParsePath(string input)
        {
            return this.viewLocationContext.Context.ToFullPath(input);
        }

        /// <summary>
        /// HTML encodes a string.
        /// </summary>
        /// <param name="input">The string that should be HTML encoded.</param>
        /// <returns>A HTML encoded <see cref="string"/>.</returns>
        public string HtmlEncode(string input)
        {
            return HttpUtility.HtmlEncode(input);
        }

        /// <summary>
        /// Locates a view that matches the provided <paramref name="viewName"/> and <paramref name="model"/>.
        /// </summary>
        /// <param name="viewName">The name of the view that should be located.</param>
        /// <param name="model">The model that should be used when locating the view.</param>
        /// <returns>A <see cref="ViewLocationResult"/> instance if the view could be located; otherwise, <see langword="null"/>.</returns>
        public ViewLocationResult LocateView(string viewName, dynamic model)
        {
            return this.viewResolver.GetViewLocation(viewName, model, this.viewLocationContext);
        }

        /// <summary>
        /// Generates a Csrf token.
        /// The token should be stored in a cookie and the form as a hidden field.
        /// In both cases the name should be the key of the returned key value pair.
        /// </summary>
        /// <returns>A tuple containing the name (cookie name and form/querystring name) and value</returns>
        public KeyValuePair<string, string> GetCsrfToken()
        {
            object tokenObject;
            if (!this.viewLocationContext.Context.Items.TryGetValue(CsrfToken.DEFAULT_CSRF_KEY, out tokenObject))
            {
                throw new InvalidOperationException("CSRF is not enabled on this request");
            }

            var tokenString = tokenObject as string;
            if (string.IsNullOrEmpty(tokenString))
            {
                throw new InvalidOperationException("CSRF object is invalid");
            }

            return new KeyValuePair<string, string>(CsrfToken.DEFAULT_CSRF_KEY, tokenString);
        }
    }
}
namespace Nancy.ViewEngines
{
    using Nancy.Localization;

    /// <summary>
    /// Default render context factory implementation.
    /// </summary>
    public class DefaultRenderContextFactory : IRenderContextFactory
    {
        private readonly IViewCache viewCache;
        private readonly IViewResolver viewResolver;
        private readonly ITextResource textResource;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultRenderContextFactory"/> class.
        /// </summary>
        /// <param name="viewCache">The view cache that should be used by the created render context.</param>
        /// <param name="viewResolver">The view resolver that should be used by the created render context.</param>
        /// <param name="textResource">The <see cref="ITextResource"/> that should be used by the engine.</param>
        public DefaultRenderContextFactory(IViewCache viewCache, IViewResolver viewResolver, ITextResource textResource)
        {
            this.viewCache = viewCache;
            this.viewResolver = viewResolver;
            this.textResource = textResource;
        }

        /// <summary>
        /// Gets a <see cref="IRenderContext"/> for the specified <see cref="ViewLocationContext"/>.
        /// </summary>
        /// <param name="viewLocationContext">The <see cref="ViewLocationContext"/> for which the context should be created.</param>
        /// <returns>A <see cref="IRenderContext"/> instance.</returns>
        public IRenderContext GetRenderContext(ViewLocationContext viewLocationContext)
        {
            return new DefaultRenderContext(this.viewResolver, this.viewCache, this.textResource, viewLocationContext);
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;

    /// <summary>
    /// Default set of assemblies that should be scanned for items (views, text, content etc)
    /// embedded as resources.
    /// </summary>
    /// <remarks>The default convention will scan all assemblies that references another assemblies that has a name that starts with Nancy*</remarks>
    public class ResourceAssemblyProvider : IResourceAssemblyProvider
    {
        private readonly IAssemblyCatalog assemblyCatalog;
        private IEnumerable<Assembly> filteredAssemblies;

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceAssemblyProvider"/>
        /// </summary>
        /// <param name="assemblyCatalog">An <see cref="IAssemblyCatalog"/> instance.</param>
        public ResourceAssemblyProvider(IAssemblyCatalog assemblyCatalog)
        {
            this.assemblyCatalog = assemblyCatalog;
        }

        /// <summary>
        /// Gets a list of assemblies that should be scanned for views.
        /// </summary>
        /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="Assembly"/> instances.</returns>
        public IEnumerable<Assembly> GetAssembliesToScan()
        {
            return (this.filteredAssemblies ?? (this.filteredAssemblies = this.GetFilteredAssemblies()));
        }

        private IEnumerable<Assembly> GetFilteredAssemblies()
        {
            return this.assemblyCatalog
                .GetAssemblies()
                .Where(x => !x.GetName().Name.StartsWith("Nancy", StringComparison.OrdinalIgnoreCase));
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Reflection;

    /// <summary>
    /// Default implementation for extracting view information form an assembly.
    /// </summary>
    public class DefaultResourceReader : IResourceReader
    {
        /// <summary>
        /// Gets information about the resources that are embedded in the assembly.
        /// </summary>
        /// <param name="assembly">The <see cref="Assembly"/> to retrieve view information from.</param>
        /// <param name="supportedViewEngineExtensions">A list of view extensions to look for.</param>
        /// <returns>A <see cref="IList{T}"/> of resource locations and content readers.</returns>
        public IList<Tuple<string, Func<StreamReader>>> GetResourceStreamMatches(Assembly assembly, IEnumerable<string> supportedViewEngineExtensions)
        {
            var resourceStreams =
                from resourceName in assembly.GetManifestResourceNames()
                from viewEngineExtension in supportedViewEngineExtensions
                where GetResourceExtension(resourceName).Equals(viewEngineExtension, StringComparison.OrdinalIgnoreCase)
                select new Tuple<string, Func<StreamReader>>(
                    resourceName,
                    () => new StreamReader(assembly.GetManifestResourceStream(resourceName)));

            return resourceStreams.ToList();
        }

        private static string GetResourceExtension(string resourceName)
        {
            var extension = Path.GetExtension(resourceName);
            return string.IsNullOrEmpty(extension) ? string.Empty : extension.Substring(1);
        }
    }
}
namespace Nancy.Localization
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Resources;

    /// <summary>
    /// Resource based implementation of <see cref="ITextResource"/>
    /// </summary>
    public class ResourceBasedTextResource : ITextResource
    {
        private readonly IResourceAssemblyProvider resourceAssemblyProvider;
        private readonly IDictionary<string, ResourceManager> resourceManagers;

        /// <summary>
        /// Initializes a new instance of <see cref="ResourceBasedTextResource"/> to read strings from *.resx files
        /// </summary>
        /// <param name="resourceAssemblyProvider">The <see cref="IResourceAssemblyProvider"/> that should be used when scanning.</param>
        public ResourceBasedTextResource(IResourceAssemblyProvider resourceAssemblyProvider)
        {
            this.resourceAssemblyProvider = resourceAssemblyProvider;

            var resources =
                from assembly in this.resourceAssemblyProvider.GetAssembliesToScan()
                from resourceName in assembly.GetManifestResourceNames()
                where resourceName.EndsWith(".resources")
                let name = Path.GetFileNameWithoutExtension(resourceName)
                let baseName = resourceName.Replace(".resources", string.Empty)
                select new
                {
                    Name = name,
                    Manager = new ResourceManager(baseName, assembly)
                };

            this.resourceManagers = new Dictionary<string, ResourceManager>(StringComparer.OrdinalIgnoreCase);

            foreach (var x in resources)
            {
                if (!this.resourceManagers.ContainsKey(x.Name))
                {
                    this.resourceManagers[x.Name] = x.Manager;
                }
                else
                {
                    throw new ArgumentException(string.Format("Key '{0}' already exists;", x.Name));
                }
            }
        }

        /// <summary>
        /// Used to return a string value from *.resx files
        /// </summary>
        /// <param name="key">The key to look for in the resource file</param>
        /// <param name="context">The <see cref="NancyContext"/> used to determine the culture for returning culture specific values.</param>
        /// <returns>Returns a string value from culture specific or default file or null if key does not exist as determined by <see cref="ResourceManager"/>.</returns>
        public string this[string key, NancyContext context]
        {
            get
            {
                var components =
                    GetKeyComponents(key);

                var candidates =
                    this.resourceManagers.Where(
                        x => x.Key.EndsWith("." + components.Item1, StringComparison.OrdinalIgnoreCase)).ToArray();

                if (candidates.Count() > 1)
                {
                    throw new InvalidOperationException("More than one text resources match the " + components.Item1 + " key. Try providing a more specific key.");
                }

                var manager = candidates.Any() ?
                    candidates.First().Value :
                    null;

                return (manager == null) ? null : manager.GetString(components.Item2, context.Culture);
            }
        }

        private static Tuple<string, string> GetKeyComponents(string key)
        {
            var index =
                key.LastIndexOf(".", StringComparison.Ordinal);

            if (index == -1)
            {
                throw new InvalidOperationException("The text key needs to be specified in the format resourcename.resourcekey, where resourcename should at least be the name of the resource file and at most the fully qualified path.");
            }

            return new Tuple<string, string>(
                key.Substring(0, index),
                key.Substring(index + 1));
        }
    }
}
namespace Nancy.ViewEngines
{
    /// <summary>
    /// Default implementation of the <see cref="IViewRenderer"/> interface.
    /// </summary>
    public class DefaultViewRenderer : IViewRenderer
    {
        private readonly IViewFactory factory;

        /// <summary>
        /// Initializes an instance of the <see cref="DefaultViewRenderer"/> type, with
        /// the provided <paramref name="factory"/>.
        /// </summary>
        /// <param name="factory">The <see cref="IViewFactory"/> that should be used to render the views.</param>
        public DefaultViewRenderer(IViewFactory factory)
        {
            this.factory = factory;
        }

        /// <summary>
        /// Renders a view to a response object, bypassing content negotiation.
        /// </summary>
        /// <param name="context">Current Nancy context</param>
        /// <param name="viewName">View name</param>
        /// <param name="model">Model object (or null)</param>
        /// <returns>Response object containing the rendered view (if found)</returns>
        public Response RenderView(NancyContext context, string viewName, object model = null)
        {
            var viewContext = new ViewLocationContext { Context = context };

            return this.factory.RenderView(viewName, model, viewContext);
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.Collections.Concurrent;
    using Configuration;

    /// <summary>
    /// Default implementation of <see cref="IViewCache"/>.
    /// </summary>
    /// <remarks>Supports expiring content if it is stale, through the <see cref="ViewConfiguration.RuntimeViewUpdates"/> setting.</remarks>
    public class DefaultViewCache : IViewCache
    {
        private readonly ConcurrentDictionary<ViewLocationResult, object> cache;
        private readonly ViewConfiguration configuration;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultViewCache"/> class.
        /// </summary>
        public DefaultViewCache(INancyEnvironment environment)
        {
            this.cache = new ConcurrentDictionary<ViewLocationResult, object>();
            this.configuration = environment.GetValue<ViewConfiguration>();
        }

        /// <summary>
        /// Gets or adds a view from the cache.
        /// </summary>
        /// <typeparam name="TCompiledView">The type of the cached view instance.</typeparam>
        /// <param name="viewLocationResult">A <see cref="ViewLocationResult"/> instance that describes the view that is being added or retrieved from the cache.</param>
        /// <param name="valueFactory">A function that produces the value that should be added to the cache in case it does not already exist.</param>
        /// <returns>An instance of the type specified by the <typeparamref name="TCompiledView"/> type.</returns>
        public TCompiledView GetOrAdd<TCompiledView>(ViewLocationResult viewLocationResult, Func<ViewLocationResult, TCompiledView> valueFactory)
        {
            if (this.configuration.RuntimeViewUpdates)
            {
                if (viewLocationResult.IsStale())
                {
                    object old;
                    this.cache.TryRemove(viewLocationResult, out old);
                }
            }

            return (TCompiledView)this.cache.GetOrAdd(viewLocationResult, x => valueFactory(x));
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.Reflection;
    using System.Runtime.CompilerServices;

    /// <summary>
    /// Contains miscellaneous extension methods.
    /// </summary>
    public static class Extensions
    {
        /// <summary>
        /// Checks if the evaluated instance is an anonymous
        /// </summary>
        /// <param name="source">The object instance to check.</param>
        /// <returns><see langword="true"/> if the object is an anonymous type; otherwise <see langword="false"/>.</returns>
        public static bool IsAnonymousType(this object source)
        {
            return source != null && source.GetType().IsAnonymousType();
        }

        public static bool IsAnonymousType(this Type type)
        {
            if (type == null)
            {
                return false;
            }

            return type.IsGenericType
                   && (type.Attributes & TypeAttributes.NotPublic) == TypeAttributes.NotPublic
                   && (type.Name.StartsWith("<>", StringComparison.OrdinalIgnoreCase) || type.Name.StartsWith("VB$", StringComparison.OrdinalIgnoreCase))
                   && (type.Name.Contains("AnonymousType") || type.Name.Contains("AnonType"))
                   && Attribute.IsDefined(type, typeof(CompilerGeneratedAttribute), false);
        }
    }
}
namespace Nancy.ViewEngines
{
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;

    /// <summary>
    /// Contains the functionality for locating a view that is located on the file system.
    /// </summary>
    public class FileSystemViewLocationProvider : IViewLocationProvider
    {
        private readonly IFileSystemReader fileSystemReader;
        private readonly string rootPath;

        /// <summary>
        /// Initializes a new instance of the <see cref="FileSystemViewLocationProvider"/> class.
        /// </summary>
        /// <param name="rootPathProvider">A <see cref="IRootPathProvider"/> instance.</param>
        /// <remarks>Creating an instance using this constructor will result in the <see cref="DefaultFileSystemReader"/> being used internally.</remarks>
        public FileSystemViewLocationProvider(IRootPathProvider rootPathProvider)
            : this(rootPathProvider, new DefaultFileSystemReader())
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FileSystemViewLocationProvider"/> class.
        /// </summary>
        /// <param name="rootPathProvider">A <see cref="IRootPathProvider"/> instance.</param>
        /// <param name="fileSystemReader">An <see cref="IFileSystemReader"/> instance that should be used when retrieving view information from the file system.</param>
        public FileSystemViewLocationProvider(IRootPathProvider rootPathProvider, IFileSystemReader fileSystemReader)
        {
            this.fileSystemReader = fileSystemReader;
            this.rootPath = rootPathProvider.GetRootPath();
        }

        /// <summary>
        /// Returns an <see cref="ViewLocationResult"/> instance for all the views that could be located by the provider.
        /// </summary>
        /// <param name="supportedViewExtensions">An <see cref="IEnumerable{T}"/> instance, containing the view engine file extensions that is supported by the running instance of Nancy.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance, containing <see cref="ViewLocationResult"/> instances for the located views.</returns>
        /// <remarks>If no views could be located, this method should return an empty enumerable, never <see langword="null"/>.</remarks>
        public IEnumerable<ViewLocationResult> GetLocatedViews(IEnumerable<string> supportedViewExtensions)
        {
            if (string.IsNullOrEmpty(this.rootPath))
            {
                return Enumerable.Empty<ViewLocationResult>();
            }

            return this.GetViewsFromPath(this.rootPath, supportedViewExtensions);
        }

        /// <summary>
        /// Returns an <see cref="ViewLocationResult"/> instance for all the views matching the viewName that could be located by the provider.
        /// </summary>
        /// <param name="supportedViewExtensions">An <see cref="IEnumerable{T}"/> instance, containing the view engine file extensions that is supported by the running instance of Nancy.</param>
        /// <param name="viewName">The name of the view to try and find</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance, containing <see cref="ViewLocationResult"/> instances for the located views.</returns>
        /// <remarks>If no views could be located, this method should return an empty enumerable, never <see langword="null"/>.</remarks>
        public IEnumerable<ViewLocationResult> GetLocatedViews(IEnumerable<string> supportedViewExtensions, string location, string viewName)
        {
            if (string.IsNullOrEmpty(this.rootPath))
            {
                return Enumerable.Empty<ViewLocationResult>();
            }

            var path = this.rootPath;

            if (!string.IsNullOrEmpty(location))
            {
                path = Path.Combine(path, location.Replace('/', Path.DirectorySeparatorChar));
            }

            if (!Directory.Exists(path))
            {
                return Enumerable.Empty<ViewLocationResult>();
            }

            var results = this.GetViewsFromPath(path, viewName, supportedViewExtensions);

            return results;
        }

        private IEnumerable<ViewLocationResult> GetViewsFromPath(string path, string viewName, IEnumerable<string> supportedViewExtensions)
        {
            var matches = this.fileSystemReader.GetViewsWithSupportedExtensions(path, viewName, supportedViewExtensions);

            return from match in matches
                   select
                       new FileSystemViewLocationResult(
                       GetViewLocation(match.Item1, this.rootPath),
                       Path.GetFileNameWithoutExtension(match.Item1),
                       Path.GetExtension(match.Item1).Substring(1),
                       match.Item2,
                       match.Item1,
                       this.fileSystemReader);
        }

        private IEnumerable<ViewLocationResult> GetViewsFromPath(string path, IEnumerable<string> supportedViewExtensions)
        {
            var matches = this.fileSystemReader.GetViewsWithSupportedExtensions(path, supportedViewExtensions);

            return from match in matches
                   select
                       new FileSystemViewLocationResult(
                       GetViewLocation(match.Item1, this.rootPath),
                       Path.GetFileNameWithoutExtension(match.Item1),
                       Path.GetExtension(match.Item1).Substring(1),
                       match.Item2,
                       match.Item1,
                       this.fileSystemReader);
        }

        private static string GetViewLocation(string match, string rootPath)
        {
            var location = match
                .Replace(rootPath, string.Empty)
                .TrimStart(new[] { Path.DirectorySeparatorChar })
                .Replace(@"\", "/")
                .Replace(Path.GetFileName(match), string.Empty)
                .TrimEnd(new[] { '/' });

            return location;
        }
    }
}
namespace Nancy
{
    using System;
    using System.IO;
    using System.Text;
    using Extensions;
    using Responses;

    /// <summary>
    /// Various extensions to return different responses form a <see cref="NancyModule"/>.
    /// </summary>
    public static class FormatterExtensions
    {
        private static ISerializer jsonSerializer;

        private static ISerializer xmlSerializer;

        /// <summary>
        /// Sends the file at <paramref name="applicationRelativeFilePath"/> to the
        /// agent, using <paramref name="contentType"/> for the <c>Content-Type</c> header.
        /// </summary>
        /// <param name="formatter">The formatter.</param>
        /// <param name="applicationRelativeFilePath">The application relative file path.</param>
        /// <param name="contentType">Value for the <c>Content-Type</c> header.</param>
        public static Response AsFile(this IResponseFormatter formatter, string applicationRelativeFilePath, string contentType)
        {
            return new GenericFileResponse(applicationRelativeFilePath, contentType, formatter.Context);
        }

        /// <summary>
        /// Sends the file at <paramref name="applicationRelativeFilePath"/> to the
        /// agent, using the file extension and <see cref="MimeTypes.GetMimeType"/>
        /// to determine the <c>Content-Type</c> header.
        /// </summary>
        /// <param name="formatter">The formatter.</param>
        /// <param name="applicationRelativeFilePath">The application relative file path.</param>
        public static Response AsFile(this IResponseFormatter formatter, string applicationRelativeFilePath)
        {
            return new GenericFileResponse(applicationRelativeFilePath, formatter.Context);
        }

        /// <summary>
        /// Returns the <paramref name="contents"/> string to the
        /// agent, using <paramref name="contentType"/> and <paramref name="encoding"/>
        /// for the <c>Content-Type</c> header.
        /// </summary>
        /// <param name="formatter">The formatter.</param>
        /// <param name="contents">The contents of the response.</param>
        /// <param name="contentType">Value for the <c>Content-Type</c> header.</param>
        /// <param name="encoding">The encoding to use.</param>
        public static Response AsText(this IResponseFormatter formatter, string contents, string contentType, Encoding encoding)
        {
            return new TextResponse(contents, contentType, encoding);
        }

        /// <summary>
        /// Returns the <paramref name="contents"/> string to the
        /// agent, using <c>text/plain</c> and <paramref name="encoding"/>
        /// for the <c>Content-Type</c> header.
        /// </summary>
        /// <param name="formatter">The formatter.</param>
        /// <param name="contents">The contents of the response.</param>
        /// <param name="encoding">The encoding to use.</param>
        public static Response AsText(this IResponseFormatter formatter, string contents, Encoding encoding)
        {
            return new TextResponse(contents, encoding: encoding);
        }

        /// <summary>
        /// Returns the <paramref name="contents"/> string to the
        /// agent, using <paramref name="contentType"/> for the <c>Content-Type</c> header.
        /// </summary>
        /// <param name="formatter">The formatter.</param>
        /// <param name="contents">The contents of the response.</param>
        /// <param name="contentType">Value for the <c>Content-Type</c> header.</param>
        public static Response AsText(this IResponseFormatter formatter, string contents, string contentType)
        {
            return new TextResponse(contents, contentType);
        }

        /// <summary>
        /// Returns the <paramref name="contents"/> string as a <c>text/plain</c> response to the agent.
        /// </summary>
        /// <param name="formatter">The formatter.</param>
        /// <param name="contents">The contents of the response.</param>
        public static Response AsText(this IResponseFormatter formatter, string contents)
        {
            return new TextResponse(contents);
        }

        /// <summary>
        /// Serializes the <paramref name="model"/> to JSON and returns it to the
        /// agent, optionally using the <paramref name="statusCode"/>.
        /// </summary>
        /// <typeparam name="TModel">The type of the model.</typeparam>
        /// <param name="formatter">The formatter.</param>
        /// <param name="model">The model to serialize.</param>
        /// <param name="statusCode">The HTTP status code. Defaults to <see cref="HttpStatusCode.OK"/>.</param>
        public static Response AsJson<TModel>(this IResponseFormatter formatter, TModel model, HttpStatusCode statusCode = HttpStatusCode.OK)
        {
            var serializer = jsonSerializer ?? (jsonSerializer = formatter.SerializerFactory.GetSerializer("application/json"));

            return new JsonResponse<TModel>(model, serializer, formatter.Environment)
            {
                StatusCode = statusCode
            };
        }

        /// <summary>
        /// Returns a redirect response to the agent.
        /// </summary>
        /// <param name="formatter">The formatter.</param>
        /// <param name="location">The location to redirect to.</param>
        /// <param name="type">The redirect type. See <see cref="RedirectResponse.RedirectType"/>.</param>
        public static Response AsRedirect(this IResponseFormatter formatter, string location, RedirectResponse.RedirectType type = RedirectResponse.RedirectType.SeeOther)
        {
            return new RedirectResponse(formatter.Context.ToFullPath(location), type);
        }

        /// <summary>
        /// Serializes the <paramref name="model"/> to XML and returns it to the
        /// agent, optionally using the <paramref name="statusCode"/>.
        /// </summary>
        /// <typeparam name="TModel">The type of the model.</typeparam>
        /// <param name="formatter">The formatter.</param>
        /// <param name="model">The model to serialize.</param>
        /// <param name="statusCode">The HTTP status code. Defaults to <see cref="HttpStatusCode.OK"/>.</param>
        public static Response AsXml<TModel>(this IResponseFormatter formatter, TModel model, HttpStatusCode statusCode = HttpStatusCode.OK)
        {
            var serializer = xmlSerializer ?? (xmlSerializer = formatter.SerializerFactory.GetSerializer("application/xml"));

            return new XmlResponse<TModel>(model, serializer, formatter.Environment);
        }

        /// <summary>
        /// Writes the data from the given <paramref name="stream"/> to the
        /// agent, using <paramref name="contentType"/> for the <c>Content-Type</c> header.
        /// </summary>
        /// <param name="formatter">The formatter.</param>
        /// <param name="stream">The stream to copy from.</param>
        /// <param name="contentType">Value for the <c>Content-Type</c> header.</param>
        public static Response FromStream(this IResponseFormatter formatter, Stream stream, string contentType)
        {
            return new StreamResponse(() => stream, contentType);
        }

        /// <summary>
        /// Invokes the given <paramref name="streamDelegate"/> to write the stream data to the
        /// agent, using <paramref name="contentType"/> for the <c>Content-Type</c> header.
        /// </summary>
        /// <param name="formatter">The formatter.</param>
        /// <param name="streamDelegate">A delegate returning a stream to copy from.</param>
        /// <param name="contentType">Value for the <c>Content-Type</c> header.</param>
        public static Response FromStream(this IResponseFormatter formatter, Func<Stream> streamDelegate, string contentType)
        {
            return new StreamResponse(streamDelegate, contentType);
        }
    }
}
namespace Nancy
{
    using System;
    using System.Globalization;
    using System.IO;
    using System.Threading.Tasks;

    /// <summary>
    /// Represents a HEAD only response.
    /// </summary>
    public class HeadResponse : Response
    {
        private const string ContentLength = "Content-Length";
        private readonly Response innerResponse;

        /// <summary>
        /// Initializes a new instance of the <see cref="HeadResponse"/> class.
        /// </summary>
        /// <param name="response">
        /// The full response to create the head response from.
        /// </param>
        public HeadResponse(Response response)
        {
            this.innerResponse = response;
            this.Contents = stream =>
            {
                this.CheckAndSetContentLength(this.innerResponse);
                GetStringContents(string.Empty)(stream);
            };
            this.ContentType = response.ContentType;
            this.Headers = response.Headers;
            this.StatusCode = response.StatusCode;
            this.ReasonPhrase = response.ReasonPhrase;
        }

        public override Task PreExecute(NancyContext context)
        {
            return this.innerResponse.PreExecute(context);
        }

        private void CheckAndSetContentLength(Response response)
        {
            if (this.Headers.ContainsKey(ContentLength))
            {
                return;
            }

            using (var nullStream = new NullStream())
            {
                response.Contents.Invoke(nullStream);

                this.Headers[ContentLength] = nullStream.Length.ToString(CultureInfo.InvariantCulture);
            }

        }

        private sealed class NullStream : Stream
        {
            private int bytesWritten;

            public override void Flush()
            {
            }

            public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
            {
                throw new NotSupportedException();
            }

            public override int EndRead(IAsyncResult asyncResult)
            {
                throw new NotSupportedException();
            }

            public override long Seek(long offset, SeekOrigin origin)
            {
                throw new NotSupportedException();
            }

            public override void SetLength(long value)
            {
                throw new NotSupportedException();
            }

            public override int Read(byte[] buffer, int offset, int count)
            {
                throw new NotSupportedException();
            }

            public override int ReadByte()
            {
                throw new NotSupportedException();
            }

            public override void Write(byte[] buffer, int offset, int count)
            {
                // We assume we can't seek and can't overwrite, but don't throw just in case.
                this.bytesWritten += count;
            }

            public override bool CanRead
            {
                get { return false; }
            }

            public override bool CanSeek
            {
                get { return false; }
            }

            public override bool CanTimeout
            {
                get { return false; }
            }

            public override bool CanWrite
            {
                get { return true; }
            }

            public override long Length
            {
                get { return this.bytesWritten; }
            }

            public override long Position
            {
                get { throw new NotSupportedException(); }
                set { throw new NotSupportedException(); }
            }
        }
    }
}
namespace Nancy.Extensions
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Linq;

    /// <summary>
    /// Containing extensions for the collection objects.
    /// </summary>
    public static class CollectionExtensions
    {
        /// <summary>
        /// Converts a <see cref="NameValueCollection"/> to a <see cref="IDictionary{TKey,TValue}"/> instance.
        /// </summary>
        /// <param name="source">The <see cref="NameValueCollection"/> to convert.</param>
        /// <returns>An <see cref="IDictionary{TKey,TValue}"/> instance.</returns>
        public static IDictionary<string, IEnumerable<string>> ToDictionary(this NameValueCollection source)
        {
            return source.AllKeys.ToDictionary<string, string, IEnumerable<string>>(key => key, source.GetValues);
        }

        /// <summary>
        /// Converts an <see cref="IDictionary{TKey,TValue}"/> instance to a <see cref="NameValueCollection"/> instance.
        /// </summary>
        /// <param name="source">The <see cref="IDictionary{TKey,TValue}"/> instance to convert.</param>
        /// <returns>A <see cref="NameValueCollection"/> instance.</returns>
        public static NameValueCollection ToNameValueCollection(this IDictionary<string, IEnumerable<string>> source)
        {
            var collection = new NameValueCollection();

            foreach (var key in source.Keys)
            {
                foreach (var value in source[key])
                {
                    collection.Add(key, value);
                }
            }

            return collection;
        }

        /// <summary>
        /// Merges a collection of <see cref="IDictionary{TKey,TValue}"/> instances into a single one.
        /// </summary>
        /// <param name="dictionaries">The list of <see cref="IDictionary{TKey,TValue}"/> instances to merge.</param>
        /// <returns>An <see cref="IDictionary{TKey,TValue}"/> instance containing the keys and values from the other instances.</returns>
        public static IDictionary<string, string> Merge(this IEnumerable<IDictionary<string, string>> dictionaries)
        {
            var output =
                new Dictionary<string, string>(StaticConfiguration.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);

            foreach (var dictionary in dictionaries.Where(d => d != null))
            {
                foreach (var kvp in dictionary)
                {
                    if (!output.ContainsKey(kvp.Key))
                    {
                        output.Add(kvp.Key, kvp.Value);
                    }
                }
            }

            return output;
        }

        /// <summary>
        /// Filters a collection based on a provided key selector.
        /// </summary>
        /// <param name="source">The collection filter.</param>
        /// <param name="keySelector">The predicate to filter by.</param>
        /// <typeparam name="TSource">The type of the collection to filter.</typeparam>
        /// <typeparam name="TKey">The type of the key to filter by.</typeparam>
        /// <returns>A <see cref="IEnumerable{T}"/> instance with the filtered values.</returns>
        public static IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
        {
            var knownKeys = new HashSet<TKey>();

            foreach (TSource element in source)
            {
                if (knownKeys.Add(keySelector(element)))
                {
                    yield return element;
                }
            }
        }
    }
}
namespace Nancy.Bootstrapper
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Nancy bootstrapper base with per-request container support.
    /// Stores/retrieves the child container in the context to ensure that
    /// only one child container is stored per request, and that the child
    /// container will be disposed at the end of the request.
    /// </summary>
    /// <typeparam name="TContainer">IoC container type</typeparam>
    public abstract class NancyBootstrapperWithRequestContainerBase<TContainer> : NancyBootstrapperBase<TContainer>
        where TContainer : class
    {
        protected NancyBootstrapperWithRequestContainerBase()
        {
            this.RequestScopedTypes = ArrayCache.Empty<TypeRegistration>();
            this.RequestScopedCollectionTypes = ArrayCache.Empty<CollectionTypeRegistration>();
        }
        /// <summary>
        /// Context key for storing the child container in the context
        /// </summary>
        private readonly string contextKey = typeof(TContainer).FullName + "BootstrapperChildContainer";

        /// <summary>
        /// Stores the module registrations to be registered into the request container
        /// </summary>
        private IEnumerable<ModuleRegistration> moduleRegistrationTypeCache;

        /// <summary>
        /// Stores the per-request type registrations
        /// </summary>
        private TypeRegistration[] RequestScopedTypes { get; set; }

        /// <summary>
        /// Stores the per-request collection registrations
        /// </summary>
        private CollectionTypeRegistration[] RequestScopedCollectionTypes { get; set; }

        /// <summary>
        /// Gets the context key for storing the child container in the context
        /// </summary>
        protected virtual string ContextKey
        {
            get
            {
                return this.contextKey;
            }
        }

        /// <summary>
        /// Get all <see cref="INancyModule"/> implementation instances
        /// </summary>
        /// <param name="context">The current context</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance containing <see cref="INancyModule"/> instances.</returns>
        public override sealed IEnumerable<INancyModule> GetAllModules(NancyContext context)
        {
            var requestContainer = this.GetConfiguredRequestContainer(context);

            this.RegisterRequestContainerModules(requestContainer, this.moduleRegistrationTypeCache);

            return this.GetAllModules(requestContainer);
        }

        /// <summary>
        /// Retrieves a specific <see cref="INancyModule"/> implementation - should be per-request lifetime
        /// </summary>
        /// <param name="moduleType">Module type</param>
        /// <param name="context">The current context</param>
        /// <returns>The <see cref="INancyModule"/> instance</returns>
        public override sealed INancyModule GetModule(Type moduleType, NancyContext context)
        {
            var requestContainer = this.GetConfiguredRequestContainer(context);

            return this.GetModule(requestContainer, moduleType);
        }

        /// <summary>
        /// Creates and initializes the request pipelines.
        /// </summary>
        /// <param name="context">The <see cref="NancyContext"/> used by the request.</param>
        /// <returns>An <see cref="IPipelines"/> instance.</returns>
        protected override sealed IPipelines InitializeRequestPipelines(NancyContext context)
        {
            var requestContainer =
                this.GetConfiguredRequestContainer(context);

            var requestPipelines =
                new Pipelines(this.ApplicationPipelines);

            if (this.RequestStartupTaskTypeCache.Any())
            {
                var startupTasks = this.RegisterAndGetRequestStartupTasks(requestContainer, this.RequestStartupTaskTypeCache);

                foreach (var requestStartup in startupTasks)
                {
                    requestStartup.Initialize(requestPipelines, context);
                }
            }

            this.RequestStartup(requestContainer, requestPipelines, context);

            return requestPipelines;
        }

        /// <summary>
        /// Takes the registration tasks and calls the relevant methods to register them
        /// </summary>
        /// <param name="registrationTasks">Registration tasks</param>
        protected override sealed void RegisterRegistrationTasks(IEnumerable<IRegistrations> registrationTasks)
        {
            foreach (var applicationRegistrationTask in registrationTasks.ToList())
            {
                var applicationTypeRegistrations = applicationRegistrationTask.TypeRegistrations == null ?
                                                        ArrayCache.Empty<TypeRegistration>() :
                                                        applicationRegistrationTask.TypeRegistrations.ToArray();

                this.RegisterTypes(this.ApplicationContainer, applicationTypeRegistrations.Where(tr => tr.Lifetime != Lifetime.PerRequest));
                this.RequestScopedTypes = this.RequestScopedTypes.Concat(applicationTypeRegistrations.Where(tr => tr.Lifetime == Lifetime.PerRequest)
                        .Select(tr => new TypeRegistration(tr.RegistrationType, tr.ImplementationType, Lifetime.Singleton)))
                        .ToArray();

                var applicationCollectionRegistrations = applicationRegistrationTask.CollectionTypeRegistrations == null ?
                                                            ArrayCache.Empty<CollectionTypeRegistration>() :
                                                            applicationRegistrationTask.CollectionTypeRegistrations.ToArray();

                this.RegisterCollectionTypes(this.ApplicationContainer, applicationCollectionRegistrations.Where(tr => tr.Lifetime != Lifetime.PerRequest));
                this.RequestScopedCollectionTypes = this.RequestScopedCollectionTypes.Concat(applicationCollectionRegistrations.Where(tr => tr.Lifetime == Lifetime.PerRequest)
                                                      .Select(tr => new CollectionTypeRegistration(tr.RegistrationType, tr.ImplementationTypes, Lifetime.Singleton)))
                                                      .ToArray();

                var applicationInstanceRegistrations = applicationRegistrationTask.InstanceRegistrations;

                if (applicationInstanceRegistrations != null)
                {
                    this.RegisterInstances(this.ApplicationContainer, applicationInstanceRegistrations);
                }
            }
        }

        /// <summary>
        /// Gets the per-request container
        /// </summary>
        /// <param name="context">Current context</param>
        /// <returns>Request container instance</returns>
        protected TContainer GetConfiguredRequestContainer(NancyContext context)
        {
            object contextObject;
            context.Items.TryGetValue(this.ContextKey, out contextObject);
            var requestContainer = contextObject as TContainer;

            if (requestContainer == null)
            {
                requestContainer = this.CreateRequestContainer(context);

                context.Items[this.ContextKey] = requestContainer;

                this.ConfigureRequestContainer(requestContainer, context);

                this.RegisterTypes(requestContainer, this.RequestScopedTypes);
                this.RegisterCollectionTypes(requestContainer, this.RequestScopedCollectionTypes);
            }

            return requestContainer;
        }

        /// <summary>
        /// Configure the request container
        /// </summary>
        /// <param name="container">Request container instance</param>
        /// <param name="context"></param>
        protected virtual void ConfigureRequestContainer(TContainer container, NancyContext context)
        {
        }

        /// <summary>
        /// Register the given module types into the container
        /// </summary>
        /// <param name="container">Container to register into</param>
        /// <param name="moduleRegistrationTypes">NancyModule types</param>
        protected override sealed void RegisterModules(TContainer container, IEnumerable<ModuleRegistration> moduleRegistrationTypes)
        {
            this.moduleRegistrationTypeCache = moduleRegistrationTypes;
        }

        /// <summary>
        /// Creates a per request child/nested container
        /// </summary>
        /// <param name="context">Current context</param>
        /// <returns>Request container instance</returns>
        protected abstract TContainer CreateRequestContainer(NancyContext context);

        /// <summary>
        /// Register the given module types into the request container
        /// </summary>
        /// <param name="container">Container to register into</param>
        /// <param name="moduleRegistrationTypes">NancyModule types</param>
        protected abstract void RegisterRequestContainerModules(TContainer container, IEnumerable<ModuleRegistration> moduleRegistrationTypes);

        /// <summary>
        /// Retrieve all module instances from the container
        /// </summary>
        /// <param name="container">Container to use</param>
        /// <returns>Collection of NancyModule instances</returns>
        protected abstract IEnumerable<INancyModule> GetAllModules(TContainer container);

        /// <summary>
        /// Retrieve a specific module instance from the container
        /// </summary>
        /// <param name="container">Container to use</param>
        /// <param name="moduleType">Type of the module</param>
        /// <returns>NancyModule instance</returns>
        protected abstract INancyModule GetModule(TContainer container, Type moduleType);
    }
}//
// Authors:
//   Patrik Torstensson (Patrik.Torstensson@labs2.com)
//   Wictor Wilén (decode/encode functions) (wictor@ibizkit.se)
//   Tim Coleman (tim@timcoleman.com)
//   Gonzalo Paniagua Javier (gonzalo@ximian.com)

//   Marek Habersack <mhabersack@novell.com>
//
// (C) 2005-2010 Novell, Inc (http://novell.com/)
//

//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Nancy.Helpers
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Text;

#if NET_4_0
	public
#endif
    class HttpEncoder
    {
        static char[] hexChars = "0123456789abcdef".ToCharArray();
        static object entitiesLock = new object();
        static SortedDictionary<string, char> entities;
#if NET_4_0
		static Lazy <HttpEncoder> defaultEncoder;
		static Lazy <HttpEncoder> currentEncoderLazy;
#else
        static HttpEncoder defaultEncoder;
#endif
        static HttpEncoder currentEncoder;

        static IDictionary<string, char> Entities
        {
            get
            {
                lock (entitiesLock)
                {
                    if (entities == null)
                        InitEntities();

                    return entities;
                }
            }
        }

        public static HttpEncoder Current
        {
            get
            {
#if NET_4_0
				if (currentEncoder == null)
					currentEncoder = currentEncoderLazy.Value;
#endif
                return currentEncoder;
            }
#if NET_4_0
			set {
				if (value == null)
					throw new ArgumentNullException ("value");
				currentEncoder = value;
			}
#endif
        }

        public static HttpEncoder Default
        {
            get
            {
#if NET_4_0
				return defaultEncoder.Value;
#else
                return defaultEncoder;
#endif
            }
        }

        static HttpEncoder()
        {
#if NET_4_0
			defaultEncoder = new Lazy <HttpEncoder> (() => new HttpEncoder ());
			currentEncoderLazy = new Lazy <HttpEncoder> (new Func <HttpEncoder> (GetCustomEncoderFromConfig));
#else
            defaultEncoder = new HttpEncoder();
            currentEncoder = defaultEncoder;
#endif
        }

        public HttpEncoder()
        {
        }
#if NET_4_0
		protected internal virtual
#else
        internal static
#endif
 void HeaderNameValueEncode(string headerName, string headerValue, out string encodedHeaderName, out string encodedHeaderValue)
        {
            if (string.IsNullOrEmpty(headerName))
                encodedHeaderName = headerName;
            else
                encodedHeaderName = EncodeHeaderString(headerName);

            if (string.IsNullOrEmpty(headerValue))
                encodedHeaderValue = headerValue;
            else
                encodedHeaderValue = EncodeHeaderString(headerValue);
        }

        static void StringBuilderAppend(string s, ref StringBuilder sb)
        {
            if (sb == null)
                sb = new StringBuilder(s);
            else
                sb.Append(s);
        }

        static string EncodeHeaderString(string input)
        {
            StringBuilder sb = null;
            char ch;

            for (int i = 0; i < input.Length; i++)
            {
                ch = input[i];

                if ((ch < 32 && ch != 9) || ch == 127)
                    StringBuilderAppend(String.Format("%{0:x2}", (int)ch), ref sb);
            }

            if (sb != null)
                return sb.ToString();

            return input;
        }
#if NET_4_0
		protected internal virtual void HtmlAttributeEncode (string value, TextWriter output)
		{

			if (output == null)
				throw new ArgumentNullException ("output");

			if (string.IsNullOrEmpty (value))
				return;

			output.Write (HtmlAttributeEncode (value));
		}

		protected internal virtual void HtmlDecode (string value, TextWriter output)
		{
			if (output == null)
				throw new ArgumentNullException ("output");

			output.Write (HtmlDecode (value));
		}

		protected internal virtual void HtmlEncode (string value, TextWriter output)
		{
			if (output == null)
				throw new ArgumentNullException ("output");

			output.Write (HtmlEncode (value));
		}

		protected internal virtual byte[] UrlEncode (byte[] bytes, int offset, int count)
		{
			return UrlEncodeToBytes (bytes, offset, count);
		}

		static HttpEncoder GetCustomEncoderFromConfig ()
		{
			var cfg = HttpRuntime.Section;
			string typeName = cfg.EncoderType;

			if (String.Compare (typeName, "System.Web.Util.HttpEncoder", StringComparison.OrdinalIgnoreCase) == 0)
				return Default;

			Type t = Type.GetType (typeName, false);
			if (t == null)
				throw new ConfigurationErrorsException (String.Format ("Could not load type '{0}'.", typeName));

			if (!typeof (HttpEncoder).IsAssignableFrom (t))
				throw new ConfigurationErrorsException (
					String.Format ("'{0}' is not allowed here because it does not extend class 'System.Web.Util.HttpEncoder'.", typeName)
				);

			return Activator.CreateInstance (t, false) as HttpEncoder;
		}
#endif
#if NET_4_0
		protected internal virtual
#else
        internal static
#endif
 string UrlPathEncode(string value)
        {
            if (string.IsNullOrEmpty(value))
                return value;

            MemoryStream result = new MemoryStream();
            int length = value.Length;
            for (int i = 0; i < length; i++)
                UrlPathEncodeChar(value[i], result);

            return Encoding.ASCII.GetString(result.ToArray());
        }

        internal static byte[] UrlEncodeToBytes(byte[] bytes, int offset, int count)
        {
            if (bytes == null)
                throw new ArgumentNullException("bytes");

            int blen = bytes.Length;
            if (blen == 0)
                return ArrayCache.Empty<byte>();

            if (offset < 0 || offset >= blen)
                throw new ArgumentOutOfRangeException("offset");

            if (count < 0 || count > blen - offset)
                throw new ArgumentOutOfRangeException("count");

            MemoryStream result = new MemoryStream(count);
            int end = offset + count;
            for (int i = offset; i < end; i++)
                UrlEncodeChar((char)bytes[i], result, false);

            return result.ToArray();
        }

        internal static string HtmlEncode(string s)
        {
            if (s == null)
                return null;

            if (s.Length == 0)
                return String.Empty;

            bool needEncode = false;
            for (int i = 0; i < s.Length; i++)
            {
                char c = s[i];
                if (c == '&' || c == '"' || c == '<' || c == '>' || c > 159
#if NET_4_0
				    || c == '\''
#endif
)
                {
                    needEncode = true;
                    break;
                }
            }

            if (!needEncode)
                return s;

            StringBuilder output = new StringBuilder();
            char ch;
            int len = s.Length;

            for (int i = 0; i < len; i++)
            {
                switch (s[i])
                {
                    case '&':
                        output.Append("&amp;");
                        break;
                    case '>':
                        output.Append("&gt;");
                        break;
                    case '<':
                        output.Append("&lt;");
                        break;
                    case '"':
                        output.Append("&quot;");
                        break;
#if NET_4_0
					case '\'':
						output.Append ("&#39;");
						break;
#endif
                    case '\uff1c':
                        output.Append("&#65308;");
                        break;

                    case '\uff1e':
                        output.Append("&#65310;");
                        break;

                    default:
                        ch = s[i];
                        if (ch > 159 && ch < 256)
                        {
                            output.Append("&#");
                            output.Append(((int)ch).ToString(CultureInfo.InvariantCulture));
                            output.Append(";");
                        }
                        else
                            output.Append(ch);
                        break;
                }
            }

            return output.ToString();
        }

        internal static string HtmlAttributeEncode(string s)
        {
#if NET_4_0
			if (string.IsNullOrEmpty (s))
				return String.Empty;
#else
            if (s == null)
                return null;

            if (s.Length == 0)
                return String.Empty;
#endif
            bool needEncode = false;
            for (int i = 0; i < s.Length; i++)
            {
                char c = s[i];
                if (c == '&' || c == '"' || c == '<'
#if NET_4_0
				    || c == '\''
#endif
)
                {
                    needEncode = true;
                    break;
                }
            }

            if (!needEncode)
                return s;

            StringBuilder output = new StringBuilder();
            int len = s.Length;
            for (int i = 0; i < len; i++)
                switch (s[i])
                {
                    case '&':
                        output.Append("&amp;");
                        break;
                    case '"':
                        output.Append("&quot;");
                        break;
                    case '<':
                        output.Append("&lt;");
                        break;
#if NET_4_0
				case '\'':
					output.Append ("&#39;");
					break;
#endif
                    default:
                        output.Append(s[i]);
                        break;
                }

            return output.ToString();
        }

        internal static string HtmlDecode(string s)
        {
            if (s == null)
                return null;

            if (s.Length == 0)
                return String.Empty;

            if (s.IndexOf('&') == -1)
                return s;
#if NET_4_0
			StringBuilder rawEntity = new StringBuilder ();
#endif
            StringBuilder entity = new StringBuilder();
            StringBuilder output = new StringBuilder();
            int len = s.Length;
            // 0 -> nothing,
            // 1 -> right after '&'
            // 2 -> between '&' and ';' but no '#'
            // 3 -> '#' found after '&' and getting numbers
            int state = 0;
            int number = 0;
            bool is_hex_value = false;
            bool have_trailing_digits = false;

            for (int i = 0; i < len; i++)
            {
                char c = s[i];
                if (state == 0)
                {
                    if (c == '&')
                    {
                        entity.Append(c);
#if NET_4_0
						rawEntity.Append (c);
#endif
                        state = 1;
                    }
                    else
                    {
                        output.Append(c);
                    }
                    continue;
                }

                if (c == '&')
                {
                    state = 1;
                    if (have_trailing_digits)
                    {
                        entity.Append(number.ToString(CultureInfo.InvariantCulture));
                        have_trailing_digits = false;
                    }

                    output.Append(entity.ToString());
                    entity.Length = 0;
                    entity.Append('&');
                    continue;
                }

                if (state == 1)
                {
                    if (c == ';')
                    {
                        state = 0;
                        output.Append(entity.ToString());
                        output.Append(c);
                        entity.Length = 0;
                    }
                    else
                    {
                        number = 0;
                        is_hex_value = false;
                        if (c != '#')
                        {
                            state = 2;
                        }
                        else
                        {
                            state = 3;
                        }
                        entity.Append(c);
#if NET_4_0
						rawEntity.Append (c);
#endif
                    }
                }
                else if (state == 2)
                {
                    entity.Append(c);
                    if (c == ';')
                    {
                        string key = entity.ToString();
                        if (key.Length > 1 && Entities.ContainsKey(key.Substring(1, key.Length - 2)))
                            key = Entities[key.Substring(1, key.Length - 2)].ToString();

                        output.Append(key);
                        state = 0;
                        entity.Length = 0;
#if NET_4_0
						rawEntity.Length = 0;
#endif
                    }
                }
                else if (state == 3)
                {
                    if (c == ';')
                    {
#if NET_4_0
						if (number == 0)
							output.Append (rawEntity.ToString () + ";");
						else
#endif
                        if (number > 65535)
                        {
                            output.Append("&#");
                            output.Append(number.ToString(CultureInfo.InvariantCulture));
                            output.Append(";");
                        }
                        else
                        {
                            output.Append((char)number);
                        }
                        state = 0;
                        entity.Length = 0;
#if NET_4_0
						rawEntity.Length = 0;
#endif
                        have_trailing_digits = false;
                    }
                    else if (is_hex_value && Uri.IsHexDigit(c))
                    {
                        number = number * 16 + Uri.FromHex(c);
                        have_trailing_digits = true;
#if NET_4_0
						rawEntity.Append (c);
#endif
                    }
                    else if (Char.IsDigit(c))
                    {
                        number = number * 10 + ((int)c - '0');
                        have_trailing_digits = true;
#if NET_4_0
						rawEntity.Append (c);
#endif
                    }
                    else if (number == 0 && (c == 'x' || c == 'X'))
                    {
                        is_hex_value = true;
#if NET_4_0
						rawEntity.Append (c);
#endif
                    }
                    else
                    {
                        state = 2;
                        if (have_trailing_digits)
                        {
                            entity.Append(number.ToString(CultureInfo.InvariantCulture));
                            have_trailing_digits = false;
                        }
                        entity.Append(c);
                    }
                }
            }

            if (entity.Length > 0)
            {
                output.Append(entity.ToString());
            }
            else if (have_trailing_digits)
            {
                output.Append(number.ToString(CultureInfo.InvariantCulture));
            }
            return output.ToString();
        }

        internal static bool NotEncoded(char c)
        {
            return (c == '!' || c == '(' || c == ')' || c == '*' || c == '-' || c == '.' || c == '_'
#if !NET_4_0
 || c == '\''
#endif
);
        }

        internal static void UrlEncodeChar(char c, Stream result, bool isUnicode)
        {
            if (c > 255)
            {
                //FIXME: what happens when there is an internal error?
                //if (!isUnicode)
                //	throw new ArgumentOutOfRangeException ("c", c, "c must be less than 256");
                int idx;
                int i = (int)c;

                result.WriteByte((byte)'%');
                result.WriteByte((byte)'u');
                idx = i >> 12;
                result.WriteByte((byte)hexChars[idx]);
                idx = (i >> 8) & 0x0F;
                result.WriteByte((byte)hexChars[idx]);
                idx = (i >> 4) & 0x0F;
                result.WriteByte((byte)hexChars[idx]);
                idx = i & 0x0F;
                result.WriteByte((byte)hexChars[idx]);
                return;
            }

            if (c > ' ' && NotEncoded(c))
            {
                result.WriteByte((byte)c);
                return;
            }
            if (c == ' ')
            {
                result.WriteByte((byte)'+');
                return;
            }
            if ((c < '0') ||
                (c < 'A' && c > '9') ||
                (c > 'Z' && c < 'a') ||
                (c > 'z'))
            {
                if (isUnicode && c > 127)
                {
                    result.WriteByte((byte)'%');
                    result.WriteByte((byte)'u');
                    result.WriteByte((byte)'0');
                    result.WriteByte((byte)'0');
                }
                else
                    result.WriteByte((byte)'%');

                int idx = ((int)c) >> 4;
                result.WriteByte((byte)hexChars[idx]);
                idx = ((int)c) & 0x0F;
                result.WriteByte((byte)hexChars[idx]);
            }
            else
                result.WriteByte((byte)c);
        }

        internal static void UrlPathEncodeChar(char c, Stream result)
        {
            if (c < 33 || c > 126)
            {
                byte[] bIn = Encoding.UTF8.GetBytes(c.ToString());
                for (int i = 0; i < bIn.Length; i++)
                {
                    result.WriteByte((byte)'%');
                    int idx = ((int)bIn[i]) >> 4;
                    result.WriteByte((byte)hexChars[idx]);
                    idx = ((int)bIn[i]) & 0x0F;
                    result.WriteByte((byte)hexChars[idx]);
                }
            }
            else if (c == ' ')
            {
                result.WriteByte((byte)'%');
                result.WriteByte((byte)'2');
                result.WriteByte((byte)'0');
            }
            else
                result.WriteByte((byte)c);
        }

        static void InitEntities()
        {
            // Build the hash table of HTML entity references.  This list comes
            // from the HTML 4.01 W3C recommendation.
            entities = new SortedDictionary<string, char>(StringComparer.Ordinal);

            entities.Add("nbsp", '\u00A0');
            entities.Add("iexcl", '\u00A1');
            entities.Add("cent", '\u00A2');
            entities.Add("pound", '\u00A3');
            entities.Add("curren", '\u00A4');
            entities.Add("yen", '\u00A5');
            entities.Add("brvbar", '\u00A6');
            entities.Add("sect", '\u00A7');
            entities.Add("uml", '\u00A8');
            entities.Add("copy", '\u00A9');
            entities.Add("ordf", '\u00AA');
            entities.Add("laquo", '\u00AB');
            entities.Add("not", '\u00AC');
            entities.Add("shy", '\u00AD');
            entities.Add("reg", '\u00AE');
            entities.Add("macr", '\u00AF');
            entities.Add("deg", '\u00B0');
            entities.Add("plusmn", '\u00B1');
            entities.Add("sup2", '\u00B2');
            entities.Add("sup3", '\u00B3');
            entities.Add("acute", '\u00B4');
            entities.Add("micro", '\u00B5');
            entities.Add("para", '\u00B6');
            entities.Add("middot", '\u00B7');
            entities.Add("cedil", '\u00B8');
            entities.Add("sup1", '\u00B9');
            entities.Add("ordm", '\u00BA');
            entities.Add("raquo", '\u00BB');
            entities.Add("frac14", '\u00BC');
            entities.Add("frac12", '\u00BD');
            entities.Add("frac34", '\u00BE');
            entities.Add("iquest", '\u00BF');
            entities.Add("Agrave", '\u00C0');
            entities.Add("Aacute", '\u00C1');
            entities.Add("Acirc", '\u00C2');
            entities.Add("Atilde", '\u00C3');
            entities.Add("Auml", '\u00C4');
            entities.Add("Aring", '\u00C5');
            entities.Add("AElig", '\u00C6');
            entities.Add("Ccedil", '\u00C7');
            entities.Add("Egrave", '\u00C8');
            entities.Add("Eacute", '\u00C9');
            entities.Add("Ecirc", '\u00CA');
            entities.Add("Euml", '\u00CB');
            entities.Add("Igrave", '\u00CC');
            entities.Add("Iacute", '\u00CD');
            entities.Add("Icirc", '\u00CE');
            entities.Add("Iuml", '\u00CF');
            entities.Add("ETH", '\u00D0');
            entities.Add("Ntilde", '\u00D1');
            entities.Add("Ograve", '\u00D2');
            entities.Add("Oacute", '\u00D3');
            entities.Add("Ocirc", '\u00D4');
            entities.Add("Otilde", '\u00D5');
            entities.Add("Ouml", '\u00D6');
            entities.Add("times", '\u00D7');
            entities.Add("Oslash", '\u00D8');
            entities.Add("Ugrave", '\u00D9');
            entities.Add("Uacute", '\u00DA');
            entities.Add("Ucirc", '\u00DB');
            entities.Add("Uuml", '\u00DC');
            entities.Add("Yacute", '\u00DD');
            entities.Add("THORN", '\u00DE');
            entities.Add("szlig", '\u00DF');
            entities.Add("agrave", '\u00E0');
            entities.Add("aacute", '\u00E1');
            entities.Add("acirc", '\u00E2');
            entities.Add("atilde", '\u00E3');
            entities.Add("auml", '\u00E4');
            entities.Add("aring", '\u00E5');
            entities.Add("aelig", '\u00E6');
            entities.Add("ccedil", '\u00E7');
            entities.Add("egrave", '\u00E8');
            entities.Add("eacute", '\u00E9');
            entities.Add("ecirc", '\u00EA');
            entities.Add("euml", '\u00EB');
            entities.Add("igrave", '\u00EC');
            entities.Add("iacute", '\u00ED');
            entities.Add("icirc", '\u00EE');
            entities.Add("iuml", '\u00EF');
            entities.Add("eth", '\u00F0');
            entities.Add("ntilde", '\u00F1');
            entities.Add("ograve", '\u00F2');
            entities.Add("oacute", '\u00F3');
            entities.Add("ocirc", '\u00F4');
            entities.Add("otilde", '\u00F5');
            entities.Add("ouml", '\u00F6');
            entities.Add("divide", '\u00F7');
            entities.Add("oslash", '\u00F8');
            entities.Add("ugrave", '\u00F9');
            entities.Add("uacute", '\u00FA');
            entities.Add("ucirc", '\u00FB');
            entities.Add("uuml", '\u00FC');
            entities.Add("yacute", '\u00FD');
            entities.Add("thorn", '\u00FE');
            entities.Add("yuml", '\u00FF');
            entities.Add("fnof", '\u0192');
            entities.Add("Alpha", '\u0391');
            entities.Add("Beta", '\u0392');
            entities.Add("Gamma", '\u0393');
            entities.Add("Delta", '\u0394');
            entities.Add("Epsilon", '\u0395');
            entities.Add("Zeta", '\u0396');
            entities.Add("Eta", '\u0397');
            entities.Add("Theta", '\u0398');
            entities.Add("Iota", '\u0399');
            entities.Add("Kappa", '\u039A');
            entities.Add("Lambda", '\u039B');
            entities.Add("Mu", '\u039C');
            entities.Add("Nu", '\u039D');
            entities.Add("Xi", '\u039E');
            entities.Add("Omicron", '\u039F');
            entities.Add("Pi", '\u03A0');
            entities.Add("Rho", '\u03A1');
            entities.Add("Sigma", '\u03A3');
            entities.Add("Tau", '\u03A4');
            entities.Add("Upsilon", '\u03A5');
            entities.Add("Phi", '\u03A6');
            entities.Add("Chi", '\u03A7');
            entities.Add("Psi", '\u03A8');
            entities.Add("Omega", '\u03A9');
            entities.Add("alpha", '\u03B1');
            entities.Add("beta", '\u03B2');
            entities.Add("gamma", '\u03B3');
            entities.Add("delta", '\u03B4');
            entities.Add("epsilon", '\u03B5');
            entities.Add("zeta", '\u03B6');
            entities.Add("eta", '\u03B7');
            entities.Add("theta", '\u03B8');
            entities.Add("iota", '\u03B9');
            entities.Add("kappa", '\u03BA');
            entities.Add("lambda", '\u03BB');
            entities.Add("mu", '\u03BC');
            entities.Add("nu", '\u03BD');
            entities.Add("xi", '\u03BE');
            entities.Add("omicron", '\u03BF');
            entities.Add("pi", '\u03C0');
            entities.Add("rho", '\u03C1');
            entities.Add("sigmaf", '\u03C2');
            entities.Add("sigma", '\u03C3');
            entities.Add("tau", '\u03C4');
            entities.Add("upsilon", '\u03C5');
            entities.Add("phi", '\u03C6');
            entities.Add("chi", '\u03C7');
            entities.Add("psi", '\u03C8');
            entities.Add("omega", '\u03C9');
            entities.Add("thetasym", '\u03D1');
            entities.Add("upsih", '\u03D2');
            entities.Add("piv", '\u03D6');
            entities.Add("bull", '\u2022');
            entities.Add("hellip", '\u2026');
            entities.Add("prime", '\u2032');
            entities.Add("Prime", '\u2033');
            entities.Add("oline", '\u203E');
            entities.Add("frasl", '\u2044');
            entities.Add("weierp", '\u2118');
            entities.Add("image", '\u2111');
            entities.Add("real", '\u211C');
            entities.Add("trade", '\u2122');
            entities.Add("alefsym", '\u2135');
            entities.Add("larr", '\u2190');
            entities.Add("uarr", '\u2191');
            entities.Add("rarr", '\u2192');
            entities.Add("darr", '\u2193');
            entities.Add("harr", '\u2194');
            entities.Add("crarr", '\u21B5');
            entities.Add("lArr", '\u21D0');
            entities.Add("uArr", '\u21D1');
            entities.Add("rArr", '\u21D2');
            entities.Add("dArr", '\u21D3');
            entities.Add("hArr", '\u21D4');
            entities.Add("forall", '\u2200');
            entities.Add("part", '\u2202');
            entities.Add("exist", '\u2203');
            entities.Add("empty", '\u2205');
            entities.Add("nabla", '\u2207');
            entities.Add("isin", '\u2208');
            entities.Add("notin", '\u2209');
            entities.Add("ni", '\u220B');
            entities.Add("prod", '\u220F');
            entities.Add("sum", '\u2211');
            entities.Add("minus", '\u2212');
            entities.Add("lowast", '\u2217');
            entities.Add("radic", '\u221A');
            entities.Add("prop", '\u221D');
            entities.Add("infin", '\u221E');
            entities.Add("ang", '\u2220');
            entities.Add("and", '\u2227');
            entities.Add("or", '\u2228');
            entities.Add("cap", '\u2229');
            entities.Add("cup", '\u222A');
            entities.Add("int", '\u222B');
            entities.Add("there4", '\u2234');
            entities.Add("sim", '\u223C');
            entities.Add("cong", '\u2245');
            entities.Add("asymp", '\u2248');
            entities.Add("ne", '\u2260');
            entities.Add("equiv", '\u2261');
            entities.Add("le", '\u2264');
            entities.Add("ge", '\u2265');
            entities.Add("sub", '\u2282');
            entities.Add("sup", '\u2283');
            entities.Add("nsub", '\u2284');
            entities.Add("sube", '\u2286');
            entities.Add("supe", '\u2287');
            entities.Add("oplus", '\u2295');
            entities.Add("otimes", '\u2297');
            entities.Add("perp", '\u22A5');
            entities.Add("sdot", '\u22C5');
            entities.Add("lceil", '\u2308');
            entities.Add("rceil", '\u2309');
            entities.Add("lfloor", '\u230A');
            entities.Add("rfloor", '\u230B');
            entities.Add("lang", '\u2329');
            entities.Add("rang", '\u232A');
            entities.Add("loz", '\u25CA');
            entities.Add("spades", '\u2660');
            entities.Add("clubs", '\u2663');
            entities.Add("hearts", '\u2665');
            entities.Add("diams", '\u2666');
            entities.Add("quot", '\u0022');
            entities.Add("amp", '\u0026');
            entities.Add("lt", '\u003C');
            entities.Add("gt", '\u003E');
            entities.Add("OElig", '\u0152');
            entities.Add("oelig", '\u0153');
            entities.Add("Scaron", '\u0160');
            entities.Add("scaron", '\u0161');
            entities.Add("Yuml", '\u0178');
            entities.Add("circ", '\u02C6');
            entities.Add("tilde", '\u02DC');
            entities.Add("ensp", '\u2002');
            entities.Add("emsp", '\u2003');
            entities.Add("thinsp", '\u2009');
            entities.Add("zwnj", '\u200C');
            entities.Add("zwj", '\u200D');
            entities.Add("lrm", '\u200E');
            entities.Add("rlm", '\u200F');
            entities.Add("ndash", '\u2013');
            entities.Add("mdash", '\u2014');
            entities.Add("lsquo", '\u2018');
            entities.Add("rsquo", '\u2019');
            entities.Add("sbquo", '\u201A');
            entities.Add("ldquo", '\u201C');
            entities.Add("rdquo", '\u201D');
            entities.Add("bdquo", '\u201E');
            entities.Add("dagger", '\u2020');
            entities.Add("Dagger", '\u2021');
            entities.Add("permil", '\u2030');
            entities.Add("lsaquo", '\u2039');
            entities.Add("rsaquo", '\u203A');
            entities.Add("euro", '\u20AC');
        }
    }
}//
// System.Web.HttpUtility
//
// Authors:
//   Patrik Torstensson (Patrik.Torstensson@labs2.com)
//   Wictor Wilén (decode/encode functions) (wictor@ibizkit.se)
//   Tim Coleman (tim@timcoleman.com)
//   Gonzalo Paniagua Javier (gonzalo@ximian.com)
//
// Copyright (C) 2005-2010 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Nancy.Helpers
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.IO;
    using System.Text;

    public sealed class HttpUtility
    {
        sealed class HttpQSCollection : NameValueCollection
        {
            public HttpQSCollection()
                : this(StaticConfiguration.CaseSensitive)
            {
            }

            public HttpQSCollection(bool caseSensitive)
                : base(caseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase)
            {
            }

            public override string ToString()
            {
                int count = Count;
                if (count == 0)
                    return "";
                StringBuilder sb = new StringBuilder();
                string[] keys = AllKeys;
                for (int i = 0; i < count; i++)
                {
                    sb.AppendFormat("{0}={1}&", keys[i], this[keys[i]]);
                }
                if (sb.Length > 0)
                    sb.Length--;
                return sb.ToString();
            }
        }

        #region Constructors

        public HttpUtility()
        {
        }

        #endregion // Constructors

        #region Methods

        public static void HtmlAttributeEncode(string s, TextWriter output)
        {
            if (output == null)
            {
#if NET_4_0
				throw new ArgumentNullException ("output");
#else
                throw new NullReferenceException(".NET emulation");
#endif
            }
#if NET_4_0
			HttpEncoder.Current.HtmlAttributeEncode (s, output);
#else
            output.Write(HttpEncoder.HtmlAttributeEncode(s));
#endif
        }

        public static string HtmlAttributeEncode(string s)
        {
#if NET_4_0
			if (s == null)
				return null;

			using (var sw = new StringWriter ()) {
				HttpEncoder.Current.HtmlAttributeEncode (s, sw);
				return sw.ToString ();
			}
#else
            return HttpEncoder.HtmlAttributeEncode(s);
#endif
        }

        public static string UrlDecode(string str)
        {
            return UrlDecode(str, Encoding.UTF8);
        }

        static char[] GetChars(MemoryStream b, Encoding e)
        {
            return e.GetChars(b.GetBuffer(), 0, (int)b.Length);
        }

        static void WriteCharBytes(IList buf, char ch, Encoding e)
        {
            if (ch > 255)
            {
                foreach (byte b in e.GetBytes(new char[] { ch }))
                    buf.Add(b);
            }
            else
                buf.Add((byte)ch);
        }

        public static string UrlDecode(string s, Encoding e)
        {
            if (null == s)
                return null;

            if (s.IndexOf('%') == -1 && s.IndexOf('+') == -1)
                return s;

            if (e == null)
                e = Encoding.UTF8;

            long len = s.Length;
            var bytes = new List<byte>();
            int xchar;
            char ch;

            for (int i = 0; i < len; i++)
            {
                ch = s[i];
                if (ch == '%' && i + 2 < len && s[i + 1] != '%')
                {
                    if (s[i + 1] == 'u' && i + 5 < len)
                    {
                        // unicode hex sequence
                        xchar = GetChar(s, i + 2, 4);
                        if (xchar != -1)
                        {
                            WriteCharBytes(bytes, (char)xchar, e);
                            i += 5;
                        }
                        else
                            WriteCharBytes(bytes, '%', e);
                    }
                    else if ((xchar = GetChar(s, i + 1, 2)) != -1)
                    {
                        WriteCharBytes(bytes, (char)xchar, e);
                        i += 2;
                    }
                    else
                    {
                        WriteCharBytes(bytes, '%', e);
                    }
                    continue;
                }

                if (ch == '+')
                    WriteCharBytes(bytes, ' ', e);
                else
                    WriteCharBytes(bytes, ch, e);
            }

            byte[] buf = bytes.ToArray();
            bytes = null;
            return e.GetString(buf);

        }

        public static string UrlDecode(byte[] bytes, Encoding e)
        {
            if (bytes == null)
                return null;

            return UrlDecode(bytes, 0, bytes.Length, e);
        }

        static int GetInt(byte b)
        {
            char c = (char)b;
            if (c >= '0' && c <= '9')
                return c - '0';

            if (c >= 'a' && c <= 'f')
                return c - 'a' + 10;

            if (c >= 'A' && c <= 'F')
                return c - 'A' + 10;

            return -1;
        }

        static int GetChar(byte[] bytes, int offset, int length)
        {
            int value = 0;
            int end = length + offset;
            for (int i = offset; i < end; i++)
            {
                int current = GetInt(bytes[i]);
                if (current == -1)
                    return -1;
                value = (value << 4) + current;
            }

            return value;
        }

        static int GetChar(string str, int offset, int length)
        {
            int val = 0;
            int end = length + offset;
            for (int i = offset; i < end; i++)
            {
                char c = str[i];
                if (c > 127)
                    return -1;

                int current = GetInt((byte)c);
                if (current == -1)
                    return -1;
                val = (val << 4) + current;
            }

            return val;
        }

        public static string UrlDecode(byte[] bytes, int offset, int count, Encoding e)
        {
            if (bytes == null)
                return null;
            if (count == 0)
                return String.Empty;

            if (bytes == null)
                throw new ArgumentNullException("bytes");

            if (offset < 0 || offset > bytes.Length)
                throw new ArgumentOutOfRangeException("offset");

            if (count < 0 || offset + count > bytes.Length)
                throw new ArgumentOutOfRangeException("count");

            StringBuilder output = new StringBuilder();
            MemoryStream acc = new MemoryStream();

            int end = count + offset;
            int xchar;
            for (int i = offset; i < end; i++)
            {
                if (bytes[i] == '%' && i + 2 < count && bytes[i + 1] != '%')
                {
                    if (bytes[i + 1] == (byte)'u' && i + 5 < end)
                    {
                        if (acc.Length > 0)
                        {
                            output.Append(GetChars(acc, e));
                            acc.SetLength(0);
                        }
                        xchar = GetChar(bytes, i + 2, 4);
                        if (xchar != -1)
                        {
                            output.Append((char)xchar);
                            i += 5;
                            continue;
                        }
                    }
                    else if ((xchar = GetChar(bytes, i + 1, 2)) != -1)
                    {
                        acc.WriteByte((byte)xchar);
                        i += 2;
                        continue;
                    }
                }

                if (acc.Length > 0)
                {
                    output.Append(GetChars(acc, e));
                    acc.SetLength(0);
                }

                if (bytes[i] == '+')
                {
                    output.Append(' ');
                }
                else
                {
                    output.Append((char)bytes[i]);
                }
            }

            if (acc.Length > 0)
            {
                output.Append(GetChars(acc, e));
            }

            acc = null;
            return output.ToString();
        }

        public static byte[] UrlDecodeToBytes(byte[] bytes)
        {
            if (bytes == null)
                return null;

            return UrlDecodeToBytes(bytes, 0, bytes.Length);
        }

        public static byte[] UrlDecodeToBytes(string str)
        {
            return UrlDecodeToBytes(str, Encoding.UTF8);
        }

        public static byte[] UrlDecodeToBytes(string str, Encoding e)
        {
            if (str == null)
                return null;

            if (e == null)
                throw new ArgumentNullException("e");

            return UrlDecodeToBytes(e.GetBytes(str));
        }

        public static byte[] UrlDecodeToBytes(byte[] bytes, int offset, int count)
        {
            if (bytes == null)
                return null;
            if (count == 0)
                return ArrayCache.Empty<byte>();

            int len = bytes.Length;
            if (offset < 0 || offset >= len)
                throw new ArgumentOutOfRangeException("offset");

            if (count < 0 || offset > len - count)
                throw new ArgumentOutOfRangeException("count");

            MemoryStream result = new MemoryStream();
            int end = offset + count;
            for (int i = offset; i < end; i++)
            {
                char c = (char)bytes[i];
                if (c == '+')
                {
                    c = ' ';
                }
                else if (c == '%' && i < end - 2)
                {
                    int xchar = GetChar(bytes, i + 1, 2);
                    if (xchar != -1)
                    {
                        c = (char)xchar;
                        i += 2;
                    }
                }
                result.WriteByte((byte)c);
            }

            return result.ToArray();
        }

        public static string UrlEncode(string str)
        {
            return UrlEncode(str, Encoding.UTF8);
        }

        public static string UrlEncode(string s, Encoding Enc)
        {
            if (s == null)
                return null;

            if (s == String.Empty)
                return String.Empty;

            bool needEncode = false;
            int len = s.Length;
            for (int i = 0; i < len; i++)
            {
                char c = s[i];
                if ((c < '0') || (c < 'A' && c > '9') || (c > 'Z' && c < 'a') || (c > 'z'))
                {
                    if (HttpEncoder.NotEncoded(c))
                        continue;

                    needEncode = true;
                    break;
                }
            }

            if (!needEncode)
                return s;

            // avoided GetByteCount call
            byte[] bytes = new byte[Enc.GetMaxByteCount(s.Length)];
            int realLen = Enc.GetBytes(s, 0, s.Length, bytes, 0);
            return Encoding.ASCII.GetString(UrlEncodeToBytes(bytes, 0, realLen));
        }

        public static string UrlEncode(byte[] bytes)
        {
            if (bytes == null)
                return null;

            if (bytes.Length == 0)
                return String.Empty;

            return Encoding.ASCII.GetString(UrlEncodeToBytes(bytes, 0, bytes.Length));
        }

        public static string UrlEncode(byte[] bytes, int offset, int count)
        {
            if (bytes == null)
                return null;

            if (bytes.Length == 0)
                return String.Empty;

            return Encoding.ASCII.GetString(UrlEncodeToBytes(bytes, offset, count));
        }

        public static byte[] UrlEncodeToBytes(string str)
        {
            return UrlEncodeToBytes(str, Encoding.UTF8);
        }

        public static byte[] UrlEncodeToBytes(string str, Encoding e)
        {
            if (str == null)
                return null;

            if (str.Length == 0)
                return ArrayCache.Empty<byte>();

            byte[] bytes = e.GetBytes(str);
            return UrlEncodeToBytes(bytes, 0, bytes.Length);
        }

        public static byte[] UrlEncodeToBytes(byte[] bytes)
        {
            if (bytes == null)
                return null;

            if (bytes.Length == 0)
                return ArrayCache.Empty<byte>();

            return UrlEncodeToBytes(bytes, 0, bytes.Length);
        }

        public static byte[] UrlEncodeToBytes(byte[] bytes, int offset, int count)
        {
            if (bytes == null)
                return null;
#if NET_4_0
			return HttpEncoder.Current.UrlEncode (bytes, offset, count);
#else
            return HttpEncoder.UrlEncodeToBytes(bytes, offset, count);
#endif
        }

        public static string UrlEncodeUnicode(string str)
        {
            if (str == null)
                return null;

            return Encoding.ASCII.GetString(UrlEncodeUnicodeToBytes(str));
        }

        public static byte[] UrlEncodeUnicodeToBytes(string str)
        {
            if (str == null)
                return null;

            if (str.Length == 0)
                return ArrayCache.Empty<byte>();

            MemoryStream result = new MemoryStream(str.Length);
            foreach (char c in str)
            {
                HttpEncoder.UrlEncodeChar(c, result, true);
            }
            return result.ToArray();
        }

        /// <summary>
        /// Decodes an HTML-encoded string and returns the decoded string.
        /// </summary>
        /// <param name="s">The HTML string to decode. </param>
        /// <returns>The decoded text.</returns>
        public static string HtmlDecode(string s)
        {
#if NET_4_0
			if (s == null)
				return null;

			using (var sw = new StringWriter ()) {
				HttpEncoder.Current.HtmlDecode (s, sw);
				return sw.ToString ();
			}
#else
            return HttpEncoder.HtmlDecode(s);
#endif
        }

        /// <summary>
        /// Decodes an HTML-encoded string and sends the resulting output to a TextWriter output stream.
        /// </summary>
        /// <param name="s">The HTML string to decode</param>
        /// <param name="output">The TextWriter output stream containing the decoded string. </param>
        public static void HtmlDecode(string s, TextWriter output)
        {
            if (output == null)
            {
#if NET_4_0
				throw new ArgumentNullException ("output");
#else
                throw new NullReferenceException(".NET emulation");
#endif
            }

            if (!string.IsNullOrEmpty(s))
            {
#if NET_4_0
				HttpEncoder.Current.HtmlDecode (s, output);
#else
                output.Write(HttpEncoder.HtmlDecode(s));
#endif
            }
        }

        public static string HtmlEncode(string s)
        {
#if NET_4_0
			if (s == null)
				return null;

			using (var sw = new StringWriter ()) {
				HttpEncoder.Current.HtmlEncode (s, sw);
				return sw.ToString ();
			}
#else
            return HttpEncoder.HtmlEncode(s);
#endif
        }

        /// <summary>
        /// HTML-encodes a string and sends the resulting output to a TextWriter output stream.
        /// </summary>
        /// <param name="s">The string to encode. </param>
        /// <param name="output">The TextWriter output stream containing the encoded string. </param>
        public static void HtmlEncode(string s, TextWriter output)
        {
            if (output == null)
            {
#if NET_4_0
				throw new ArgumentNullException ("output");
#else
                throw new NullReferenceException(".NET emulation");
#endif
            }

            if (!string.IsNullOrEmpty(s))
            {
#if NET_4_0
				HttpEncoder.Current.HtmlEncode (s, output);
#else
                output.Write(HttpEncoder.HtmlEncode(s));
#endif
            }
        }
#if NET_4_0
		public static string HtmlEncode (object value)
		{
			if (value == null)
				return null;

			IHtmlString htmlString = value as IHtmlString;
			if (htmlString != null)
				return htmlString.ToHtmlString ();

			return HtmlEncode (value.ToString ());
		}

		public static string JavaScriptStringEncode (string value)
		{
			return JavaScriptStringEncode (value, false);
		}

		public static string JavaScriptStringEncode (string value, bool addDoubleQuotes)
		{
			if (string.IsNullOrEmpty (value))
				return addDoubleQuotes ? "\"\"" : String.Empty;

			int len = value.Length;
			bool needEncode = false;
			char c;
			for (int i = 0; i < len; i++) {
				c = value [i];

				if (c >= 0 && c <= 31 || c == 34 || c == 39 || c == 60 || c == 62 || c == 92) {
					needEncode = true;
					break;
				}
			}

			if (!needEncode)
				return addDoubleQuotes ? "\"" + value + "\"" : value;

			var sb = new StringBuilder ();
			if (addDoubleQuotes)
				sb.Append ('"');

			for (int i = 0; i < len; i++) {
				c = value [i];
				if (c >= 0 && c <= 7 || c == 11 || c >= 14 && c <= 31 || c == 39 || c == 60 || c == 62)
					sb.AppendFormat ("\\u{0:x4}", (int)c);
				else switch ((int)c) {
						case 8:
							sb.Append ("\\b");
							break;

						case 9:
							sb.Append ("\\t");
							break;

						case 10:
							sb.Append ("\\n");
							break;

						case 12:
							sb.Append ("\\f");
							break;

						case 13:
							sb.Append ("\\r");
							break;

						case 34:
							sb.Append ("\\\"");
							break;

						case 92:
							sb.Append ("\\\\");
							break;

						default:
							sb.Append (c);
							break;
					}
			}

			if (addDoubleQuotes)
				sb.Append ('"');

			return sb.ToString ();
		}
#endif
        public static string UrlPathEncode(string s)
        {
#if NET_4_0
			return HttpEncoder.Current.UrlPathEncode (s);
#else
            return HttpEncoder.UrlPathEncode(s);
#endif
        }

        public static NameValueCollection ParseQueryString(string query)
        {
            return ParseQueryString(query, Encoding.UTF8);
        }

        public static NameValueCollection ParseQueryString(string query, bool caseSensitive)
        {
            return ParseQueryString(query, Encoding.UTF8, caseSensitive);
        }

        public static NameValueCollection ParseQueryString(string query, Encoding encoding)
        {
            return ParseQueryString(query, encoding, StaticConfiguration.CaseSensitive);
        }

        public static NameValueCollection ParseQueryString(string query, Encoding encoding, bool caseSensitive)
        {
            if (query == null)
                throw new ArgumentNullException("query");
            if (encoding == null)
                throw new ArgumentNullException("encoding");
            if (query.Length == 0 || (query.Length == 1 && query[0] == '?'))
                return new HttpQSCollection(caseSensitive);
            if (query[0] == '?')
                query = query.Substring(1);

            NameValueCollection result = new HttpQSCollection(caseSensitive);
            ParseQueryString(query, encoding, result);
            return result;
        }

        internal static void ParseQueryString(string query, Encoding encoding, NameValueCollection result)
        {
            if (query.Length == 0)
                return;

            var decoded = HtmlDecode(query);
            var segments = decoded.Split(new[] { '&' }, StringSplitOptions.None);

            foreach (var segment in segments)
            {
                var keyValuePair = ParseQueryStringSegment(segment, encoding);
                if (!Equals(keyValuePair, default(KeyValuePair<string, string>)))
                    result.Add(keyValuePair.Key, keyValuePair.Value);
            }
        }

        private static KeyValuePair<string, string> ParseQueryStringSegment(string segment, Encoding encoding)
        {
            if (String.IsNullOrWhiteSpace(segment))
                return default(KeyValuePair<string, string>);

            var indexOfEquals = segment.IndexOf('=');
            if (indexOfEquals == -1)
            {
                var decoded = UrlDecode(segment, encoding);
                return new KeyValuePair<string, string>(decoded, decoded);
            }

            var key = UrlDecode(segment.Substring(0, indexOfEquals), encoding);
            var length = (segment.Length - indexOfEquals) - 1;
            var value = UrlDecode(segment.Substring(indexOfEquals + 1, length), encoding);
            return new KeyValuePair<string, string>(key, value);
        }

        #endregion // Methods
    }
}
namespace Nancy
{
    using System.IO;

    /// <summary>
    /// Represents a file that was captured in a HTTP multipart/form-data request
    /// </summary>
    public class HttpFile
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="HttpFile"/> class,
        /// using the provided <paramref name="boundary"/>.
        /// </summary>
        /// <param name="boundary">The <see cref="HttpMultipartBoundary"/> that contains the file information.</param>
        public HttpFile(HttpMultipartBoundary boundary)
            : this(boundary.ContentType, boundary.Filename, boundary.Value, boundary.Name)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="HttpFile"/> class,
        /// using the provided values
        /// </summary>
        /// <paramref name="contentType">The content type of the file.</paramref>
        /// <paramref name="name">The name of the file.</paramref>
        /// <paramref name="value">The content of the file.</paramref>
        /// <paramref name="key">The name of the field that uploaded the file.</paramref>
        public HttpFile(string contentType, string name, Stream value, string key)
        {
            this.ContentType = contentType;
            this.Name = name;
            this.Value = value;
            this.Key = key;
        }

        /// <summary>
        /// Gets or sets the type of the content.
        /// </summary>
        /// <value>A <see cref="string"/> containing the content type of the file.</value>
        public string ContentType { get; private set; }

        /// <summary>
        /// Gets or sets the name of the file.
        /// </summary>
        /// <value>A <see cref="string"/> containing the name of the file.</value>
        public string Name { get; private set; }

        /// <summary>
        /// Gets or sets the form element name of this file.
        /// </summary>
        /// <value>A <see cref="string"/> containing the key.</value>
        public string Key { get; private set; }

        /// <summary>
        /// Gets or sets the value stream.
        /// </summary>
        /// <value>A <see cref="Stream"/> containing the contents of the file.</value>
        /// <remarks>This is a <see cref="HttpMultipartSubStream"/> instance that sits ontop of the request stream.</remarks>
        public Stream Value { get; private set; }
    }
}
namespace Nancy
{
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// Retrieves <see cref="HttpMultipartBoundary"/> instances from a request stream.
    /// </summary>
    public class HttpMultipart
    {
        private const byte LF = (byte)'\n';
        private readonly byte[] boundaryAsBytes;
        private readonly HttpMultipartBuffer readBuffer;
        private readonly Stream requestStream;
        private readonly byte[] closingBoundaryAsBytes;

        /// <summary>
        /// Initializes a new instance of the <see cref="HttpMultipart"/> class.
        /// </summary>
        /// <param name="requestStream">The request stream to parse.</param>
        /// <param name="boundary">The boundary marker to look for.</param>
        public HttpMultipart(Stream requestStream, string boundary)
        {
            this.requestStream = requestStream;
            this.boundaryAsBytes = GetBoundaryAsBytes(boundary, false);
            this.closingBoundaryAsBytes = GetBoundaryAsBytes(boundary, true);
            this.readBuffer = new HttpMultipartBuffer(this.boundaryAsBytes, this.closingBoundaryAsBytes);
        }

        /// <summary>
        /// Gets the <see cref="HttpMultipartBoundary"/> instances from the request stream.
        /// </summary>
        /// <returns>An <see cref="IEnumerable{T}"/> instance, containing the found <see cref="HttpMultipartBoundary"/> instances.</returns>
        public IEnumerable<HttpMultipartBoundary> GetBoundaries()
        {
            return
                (from boundaryStream in this.GetBoundarySubStreams()
                 select new HttpMultipartBoundary(boundaryStream)).ToList();
        }

        private IEnumerable<HttpMultipartSubStream> GetBoundarySubStreams()
        {
            var boundarySubStreams = new List<HttpMultipartSubStream>();
            var boundaryStart = this.GetNextBoundaryPosition();

            var found = 0;
            while (MultipartIsNotCompleted(boundaryStart) && found < StaticConfiguration.RequestQueryFormMultipartLimit)
            {
                var boundaryEnd = this.GetNextBoundaryPosition();
                boundarySubStreams.Add(new HttpMultipartSubStream(
                    this.requestStream,
                    boundaryStart,
                    this.GetActualEndOfBoundary(boundaryEnd)));

                boundaryStart = boundaryEnd;

                found++;
            }

            return boundarySubStreams;
        }
        private bool MultipartIsNotCompleted(long boundaryPosition)
        {
            return boundaryPosition > -1 && !this.readBuffer.IsClosingBoundary;
        }

        //we add two because or the \r\n before the boundary
        private long GetActualEndOfBoundary(long boundaryEnd)
        {
            if (this.CheckIfFoundEndOfStream())
            {
                return this.requestStream.Position - (this.readBuffer.Length + 2);
            }
            return boundaryEnd - (this.readBuffer.Length + 2);
        }

        private bool CheckIfFoundEndOfStream()
        {
            return this.requestStream.Position.Equals(this.requestStream.Length);
        }

        private static byte[] GetBoundaryAsBytes(string boundary, bool closing)
        {
            var boundaryBuilder = new StringBuilder();

            boundaryBuilder.Append("--");
            boundaryBuilder.Append(boundary);

            if (closing)
            {
                boundaryBuilder.Append("--");
            }
            else
            {
                boundaryBuilder.Append('\r');
                boundaryBuilder.Append('\n');
            }

            var bytes =
                Encoding.ASCII.GetBytes(boundaryBuilder.ToString());

            return bytes;
        }

        private long GetNextBoundaryPosition()
        {
            this.readBuffer.Reset();
            while (true)
            {
                var byteReadFromStream = this.requestStream.ReadByte();

                if (byteReadFromStream == -1)
                {
                    return -1;
                }

                this.readBuffer.Insert((byte)byteReadFromStream);

                if (this.readBuffer.IsFull && (this.readBuffer.IsBoundary || this.readBuffer.IsClosingBoundary))
                {
                    return this.requestStream.Position;
                }

                if (byteReadFromStream.Equals(LF) || this.readBuffer.IsFull)
                {
                    this.readBuffer.Reset();
                }
            }
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <summary>
    /// Represents the content boundary of a HTTP multipart/form-data boundary in a stream.
    /// </summary>
    public class HttpMultipartBoundary
    {
        private const byte LF = (byte)'\n';
        private const byte CR = (byte)'\r';

        /// <summary>
        /// Initializes a new instance of the <see cref="HttpMultipartBoundary"/> class.
        /// </summary>
        /// <param name="boundaryStream">The stream that contains the boundary information.</param>
        public HttpMultipartBoundary(HttpMultipartSubStream boundaryStream)
        {
            this.Value = boundaryStream;
            this.ExtractHeaders();
        }

        /// <summary>
        /// Gets the contents type of the boundary value.
        /// </summary>
        /// <value>A <see cref="string"/> containing the name of the value if it is available; otherwise <see cref="string.Empty"/>.</value>
        public string ContentType { get; private set; }

        /// <summary>
        /// Gets or the filename for the boundary value.
        /// </summary>
        /// <value>A <see cref="string"/> containing the filename value if it is available; otherwise <see cref="string.Empty"/>.</value>
        /// <remarks>This is the RFC2047 decoded value of the filename attribute of the Content-Disposition header.</remarks>
        public string Filename { get; private set; }

        /// <summary>
        /// Gets name of the boundary value.
        /// </summary>
        /// <remarks>This is the RFC2047 decoded value of the name attribute of the Content-Disposition header.</remarks>
        public string Name { get; private set; }

        /// <summary>
        /// A stream containing the value of the boundary.
        /// </summary>
        /// <remarks>This is the RFC2047 decoded value of the Content-Type header.</remarks>
        public HttpMultipartSubStream Value { get; private set; }

        private void ExtractHeaders()
        {
            while (true)
            {
                var header = ReadLineFromStream(this.Value);

                if (string.IsNullOrEmpty(header))
                {
                    break;
                }

                if (header.StartsWith("Content-Disposition", StringComparison.CurrentCultureIgnoreCase))
                {
                    this.Name = Regex.Match(header, @"name=""?(?<name>[^\""]*)", RegexOptions.IgnoreCase).Groups["name"].Value;
                    this.Filename = Regex.Match(header, @"filename=""?(?<filename>[^\""]*)", RegexOptions.IgnoreCase).Groups["filename"].Value;
                }

                if (header.StartsWith("Content-Type", StringComparison.OrdinalIgnoreCase))
                {
                    this.ContentType = header.Split(new[] { ' ' }).Last().Trim();
                }
            }

            this.Value.PositionStartAtCurrentLocation();
        }

        private static string ReadLineFromStream(Stream stream)
        {
            var readBuffer = new List<byte>();

            while (true)
            {
                var byteReadFromStream = stream.ReadByte();

                if (byteReadFromStream == -1)
                {
                    return null;
                }

                if (byteReadFromStream.Equals(LF))
                {
                    break;
                }

                readBuffer.Add((byte)byteReadFromStream);
            }

            return Encoding.UTF8.GetString(readBuffer.ToArray()).Trim((char)CR);
        }
    }
}
namespace Nancy
{
    using System;
    using System.Linq;

    /// <summary>
    /// A buffer that is used to locate a HTTP multipart/form-data boundary in a stream.
    /// </summary>
    public class HttpMultipartBuffer
    {
        private readonly byte[] boundaryAsBytes;
        private readonly byte[] closingBoundaryAsBytes;
        private readonly byte[] buffer;
        private int position;

        /// <summary>
        /// Initializes a new instance of the <see cref="HttpMultipartBuffer"/> class.
        /// </summary>
        /// <param name="boundaryAsBytes">The boundary as a byte-array.</param>
        /// <param name="closingBoundaryAsBytes">The closing boundary as byte-array</param>
        public HttpMultipartBuffer(byte[] boundaryAsBytes, byte[] closingBoundaryAsBytes)
        {
            this.boundaryAsBytes = boundaryAsBytes;
            this.closingBoundaryAsBytes = closingBoundaryAsBytes;
            this.buffer = new byte[this.boundaryAsBytes.Length];
        }

        /// <summary>
        /// Gets a value indicating whether the buffer contains the same values as the boundary.
        /// </summary>
        /// <value><see langword="true"/> if buffer contains the same values as the boundary; otherwise, <see langword="false"/>.</value>
        public bool IsBoundary
        {
            get { return this.buffer.SequenceEqual(this.boundaryAsBytes); }
        }
        public bool IsClosingBoundary
        {
            get { return this.buffer.SequenceEqual(this.closingBoundaryAsBytes); }
        }
        /// <summary>
        /// Gets a value indicating whether this buffer is full.
        /// </summary>
        /// <value><see langword="true"/> if buffer is full; otherwise, <see langword="false"/>.</value>
        public bool IsFull
        {
            get { return this.position.Equals(this.buffer.Length); }
        }

        /// <summary>
        /// Gets the number of bytes that can be stored in the buffer.
        /// </summary>
        /// <value>The number of bytes that can be stored in the buffer.</value>
        public int Length
        {
            get { return this.buffer.Length; }
        }

        /// <summary>
        /// Resets the buffer so that inserts happens from the start again.
        /// </summary>
        /// <remarks>This does not clear any previously written data, just resets the buffer position to the start. Data that is inserted after Reset has been called will overwrite old data.</remarks>
        public void Reset()
        {
            this.position = 0;
        }

        /// <summary>
        /// Inserts the specified value into the buffer and advances the internal position.
        /// </summary>
        /// <param name="value">The value to insert into the buffer.</param>
        /// <remarks>This will throw an <see cref="ArgumentOutOfRangeException"/> is you attempt to call insert more times then the <see cref="Length"/> of the buffer and <see cref="Reset"/> was not invoked.</remarks>
        public void Insert(byte value)
        {
            this.buffer[this.position++] = value;
        }
    }
}
namespace Nancy
{
    /// <summary>
    /// HTTP Status Codes
    /// </summary>
    /// <remarks>The values are based on the list found at http://en.wikipedia.org/wiki/List_of_HTTP_status_codes </remarks>
    public enum HttpStatusCode
    {
        /// <summary>
        /// 100 Continue
        /// </summary>
        Continue = 100,
        /// <summary>
        /// 101 SwitchingProtocols
        /// </summary>
        SwitchingProtocols = 101,
        /// <summary>
        /// 102 Processing
        /// </summary>
        Processing = 102,
        /// <summary>
        /// 103 Checkpoint
        /// </summary>
        Checkpoint = 103,
        /// <summary>
        /// 200 OK
        /// </summary>
        OK = 200,
        /// <summary>
        /// 201 Created
        /// </summary>
        Created = 201,
        /// <summary>
        /// 202 Accepted
        /// </summary>
        Accepted = 202,
        /// <summary>
        /// 203 NonAuthoritativeInformation
        /// </summary>
        NonAuthoritativeInformation = 203,
        /// <summary>
        /// 204 NoContent
        /// </summary>
        NoContent = 204,
        /// <summary>
        /// 205 ResetContent
        /// </summary>
        ResetContent = 205,
        /// <summary>
        /// 206 PartialContent
        /// </summary>
        PartialContent = 206,
        /// <summary>
        /// 207 MultipleStatus
        /// </summary>
        MultipleStatus = 207,
        /// <summary>
        /// 226 IMUsed
        /// </summary>
        IMUsed = 226,
        /// <summary>
        /// 300 MultipleChoices
        /// </summary>
        MultipleChoices = 300,
        /// <summary>
        /// 301 MovedPermanently
        /// </summary>
        MovedPermanently = 301,
        /// <summary>
        /// 302 Found
        /// </summary>
        Found = 302,
        /// <summary>
        /// 303 SeeOther
        /// </summary>
        SeeOther = 303,
        /// <summary>
        /// 304 NotModified
        /// </summary>
        NotModified = 304,
        /// <summary>
        /// 305 UseProxy
        /// </summary>
        UseProxy = 305,
        /// <summary>
        /// 306 SwitchProxy
        /// </summary>
        SwitchProxy = 306,
        /// <summary>
        /// 307 TemporaryRedirect
        /// </summary>
        TemporaryRedirect = 307,
        /// <summary>
        /// 308 ResumeIncomplete
        /// </summary>
        ResumeIncomplete = 308,
        /// <summary>
        /// 400 BadRequest
        /// </summary>
        BadRequest = 400,
        /// <summary>
        /// 401 Unauthorized
        /// </summary>
        Unauthorized = 401,
        /// <summary>
        /// 402 PaymentRequired
        /// </summary>
        PaymentRequired = 402,
        /// <summary>
        /// 403 Forbidden
        /// </summary>
        Forbidden = 403,
        /// <summary>
        /// 404 NotFound
        /// </summary>
        NotFound = 404,
        /// <summary>
        /// 405 MethodNotAllowed
        /// </summary>
        MethodNotAllowed = 405,
        /// <summary>
        /// 406 NotAcceptable
        /// </summary>
        NotAcceptable = 406,
        /// <summary>
        /// 407 ProxyAuthenticationRequired
        /// </summary>
        ProxyAuthenticationRequired = 407,
        /// <summary>
        /// 408 RequestTimeout
        /// </summary>
        RequestTimeout = 408,
        /// <summary>
        /// 409 Conflict
        /// </summary>
        Conflict = 409,
        /// <summary>
        /// 410 Gone
        /// </summary>
        Gone = 410,
        /// <summary>
        /// 411 LengthRequired
        /// </summary>
        LengthRequired = 411,
        /// <summary>
        /// 412 PreconditionFailed
        /// </summary>
        PreconditionFailed = 412,
        /// <summary>
        /// 413 RequestEntityTooLarge
        /// </summary>
        RequestEntityTooLarge = 413,
        /// <summary>
        /// 414 RequestUriTooLong
        /// </summary>
        RequestUriTooLong = 414,
        /// <summary>
        /// 415 UnsupportedMediaType
        /// </summary>
        UnsupportedMediaType = 415,
        /// <summary>
        /// 416 RequestedRangeNotSatisfiable
        /// </summary>
        RequestedRangeNotSatisfiable = 416,
        /// <summary>
        /// 417 ExpectationFailed
        /// </summary>
        ExpectationFailed = 417,
        /// <summary>
        /// 418 ImATeapot
        /// </summary>
        ImATeapot = 418,
        /// <summary>
        /// 420 Enhance Your Calm
        /// </summary>
        EnhanceYourCalm = 420,
        /// <summary>
        /// 422 UnprocessableEntity
        /// </summary>
        UnprocessableEntity = 422,
        /// <summary>
        /// 423 Locked
        /// </summary>
        Locked = 423,
        /// <summary>
        /// 424 FailedDependency
        /// </summary>
        FailedDependency = 424,
        /// <summary>
        /// 425 UnorderedCollection
        /// </summary>
        UnorderedCollection = 425,
        /// <summary>
        /// 426 UpgradeRequired
        /// </summary>
        UpgradeRequired = 426,
        /// <summary>
        /// 429 Too Many Requests
        /// </summary>
        TooManyRequests = 429,
        /// <summary>
        /// 444 NoResponse
        /// </summary>
        NoResponse = 444,
        /// <summary>
        /// 449 RetryWith
        /// </summary>
        RetryWith = 449,
        /// <summary>
        /// 450 BlockedByWindowsParentalControls
        /// </summary>
        BlockedByWindowsParentalControls = 450,
        /// <summary>
        /// 451 UnavailableForLegalReasons
        /// </summary>
        UnavailableForLegalReasons = 451,
        /// <summary>
        /// 499 ClientClosedRequest
        /// </summary>
        ClientClosedRequest = 499,
        /// <summary>
        /// 500 InternalServerError
        /// </summary>
        InternalServerError = 500,
        /// <summary>
        /// 501 NotImplemented
        /// </summary>
        NotImplemented = 501,
        /// <summary>
        /// 502 BadGateway
        /// </summary>
        BadGateway = 502,
        /// <summary>
        /// 503 ServiceUnavailable
        /// </summary>
        ServiceUnavailable = 503,
        /// <summary>
        /// 504 GatewayTimeout
        /// </summary>
        GatewayTimeout = 504,
        /// <summary>
        /// 505 HttpVersionNotSupported
        /// </summary>
        HttpVersionNotSupported = 505,
        /// <summary>
        /// 506 VariantAlsoNegotiates
        /// </summary>
        VariantAlsoNegotiates = 506,
        /// <summary>
        /// 507 InsufficientStorage
        /// </summary>
        InsufficientStorage = 507,
        /// <summary>
        /// 509 BandwidthLimitExceeded
        /// </summary>
        BandwidthLimitExceeded = 509,
        /// <summary>
        /// 510 NotExtended
        /// </summary>
        NotExtended = 510
    }
}
namespace Nancy
{
    using System;
    using System.ComponentModel;

    /// <summary>
    /// Helper interface used to hide the base <see cref="object"/>  members from the fluent API to make it much cleaner
    /// in Visual Studio intellisense.
    /// </summary>
    /// <remarks>Created by Daniel Cazzulino http://www.clariusconsulting.net/blogs/kzu/archive/2008/03/10/58301.aspx</remarks>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IHideObjectMembers
    {
        /// <summary>
        /// Hides the <see cref="Equals"/> method.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        bool Equals(object obj);

        /// <summary>
        /// Hides the <see cref="GetHashCode"/> method.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        int GetHashCode();

        /// <summary>
        /// Hides the <see cref="GetType"/> method.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        Type GetType();

        /// <summary>
        /// Hides the <see cref="ToString"/> method.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        string ToString();
    }
}
namespace Nancy
{
    /// <summary>
    /// Creates NancyContext instances
    /// </summary>
    public interface INancyContextFactory
    {
        /// <summary>
        /// Create a new NancyContext
        /// </summary>
        /// <returns>NancyContext instance</returns>
        NancyContext Create(Request request);
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Catalog of <see cref="INancyModule"/> instances.
    /// </summary>
    public interface INancyModuleCatalog
    {
        /// <summary>
        /// Get all NancyModule implementation instances - should be per-request lifetime
        /// </summary>
        /// <param name="context">The current context</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance containing <see cref="INancyModule"/> instances.</returns>
        IEnumerable<INancyModule> GetAllModules(NancyContext context);

        /// <summary>
        /// Retrieves a specific <see cref="INancyModule"/> implementation - should be per-request lifetime
        /// </summary>
        /// <param name="moduleType">Module type</param>
        /// <param name="context">The current context</param>
        /// <returns>The <see cref="INancyModule"/> instance</returns>
        INancyModule GetModule(Type moduleType, NancyContext context);
    }
}
namespace Nancy
{
    using Nancy.Configuration;

    /// <summary>
    /// An extension point for adding support for formatting response contents. No members should be added to this interface without good reason.
    /// </summary>
    /// <remarks>Extension methods to this interface should always return <see cref="Response"/> or one of the types that can implicitly be types into a <see cref="Response"/>.</remarks>
    public interface IResponseFormatter : IHideObjectMembers
    {
        /// <summary>
        /// Gets all <see cref="ISerializerFactory"/> factory.
        /// </summary>
        ISerializerFactory SerializerFactory { get; }

        /// <summary>
        /// Gets the context for which the response is being formatted.
        /// </summary>
        /// <value>A <see cref="NancyContext"/> instance.</value>
        NancyContext Context { get; }

        /// <summary>
        /// Gets the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <value>An <see cref="INancyEnvironment"/> instance.</value>
        INancyEnvironment Environment { get; }

        /// <summary>
        /// Gets the root path of the application.
        /// </summary>
        /// <value>A <see cref="string"/> containing the root path.</value>
        string RootPath { get; }
    }
}//
// JavaScriptConverter.cs
//
// Author:
//   Igor Zelmanovich <igorz@mainsoft.com>
//
// (C) 2007 Mainsoft, Inc.  http://www.mainsoft.com
//
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
namespace Nancy.Json
{
    using System;
    using System.Collections.Generic;

    public abstract class JavaScriptConverter
    {
        protected JavaScriptConverter() { }

        public abstract IEnumerable<Type> SupportedTypes { get; }

        public virtual object Deserialize(IDictionary<string, object> dictionary, Type type)
        {
            return Deserialize(dictionary, type, null);
        }

        public abstract object Deserialize(IDictionary<string, object> dictionary, Type type, JavaScriptSerializer serializer);

        public IDictionary<string, object> Serialize(object obj)
        {
            return Serialize(obj, null);
        }

        public abstract IDictionary<string, object> Serialize(object obj, JavaScriptSerializer serializer);
    }
}//
// JavaScriptSerializer.cs
//
// Author:
//   Konstantin Triger <kostat@mainsoft.com>
//
// (C) 2007 Mainsoft, Inc.  http://www.mainsoft.com
//
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Nancy.Json
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using Nancy.Json.Simple;

    /// <summary>
    /// JavaScriptSerializer responsible for serializing objects
    /// </summary>
    public class JavaScriptSerializer
    {
        private readonly NancySerializationStrategy serializerStrategy;

        /// <summary>
        /// Creates an instance of <see cref="JavaScriptSerializer"/>
        /// </summary>
        public JavaScriptSerializer() : this(JsonConfiguration.Default)
        {
        }

        /// <summary>
        /// Creates an instance of <see cref="JavaScriptSerializer"/>
        /// </summary>
        /// <param name="configuration">A <see cref="JsonConfiguration"/> object to configure the serializer</param>
        public JavaScriptSerializer(JsonConfiguration configuration)
        {
            this.serializerStrategy = new NancySerializationStrategy(configuration.RetainCasing);
        }

        /// <summary>
        /// Creates an instance of <see cref="JavaScriptSerializer"/>
        /// </summary>
        /// <param name="configuration">A <see cref="JsonConfiguration"/> object to configure the serializer</param>
        /// <param name="registerConverters">A boolean to determine whether to register custom converters</param>
        public JavaScriptSerializer(JsonConfiguration configuration, bool registerConverters) : this(configuration)
        {
            if (registerConverters)
            {
                this.RegisterConverters(configuration.Converters, configuration.PrimitiveConverters);
            }
        }

        /// <summary>
        /// Deserialize JSON
        /// </summary>
        /// <param name="input">JSON representation</param>
        /// <typeparam name="T">The <see cref="Type"/> to deserialize into</typeparam>
        /// <returns>An instance of type <typeparamref name="T"/> representing <paramref name="input"/> as an object</returns>
        public T Deserialize<T>(string input)
        {
            return SimpleJson.DeserializeObject<T>(input, this.serializerStrategy);
        }

        /// <summary>
        /// Deserialize JSON
        /// </summary>
        /// <param name="input">JSON representation</param>
        /// <returns>An object representing <paramref name="input"/></returns>
        public object DeserializeObject(string input)
        {
            return SimpleJson.DeserializeObject(input, null, this.serializerStrategy);
        }

        /// <summary>
        /// Register custom JSON converters
        /// </summary>
        /// <param name="converters">An array of <see cref="JavaScriptConverter"/> to register</param>
        /// <exception cref="ArgumentNullException"><paramref name="converters"/> is null</exception>
        public void RegisterConverters(IEnumerable<JavaScriptConverter> converters)
        {
            if (converters == null)
            {
                throw new ArgumentNullException("converters");
            }

            this.serializerStrategy.RegisterConverters(converters);
        }

        /// <summary>
        /// Register custom JSON converters
        /// </summary>
        /// <param name="primitiveConverters">An array of <see cref="JavaScriptPrimitiveConverter"/></param>
        /// <exception cref="ArgumentNullException"><paramref name="primitiveConverters"/> is null</exception>
        public void RegisterConverters(IEnumerable<JavaScriptPrimitiveConverter> primitiveConverters)
        {
            if (primitiveConverters == null)
            {
                throw new ArgumentNullException("primitiveConverters");
            }

            this.serializerStrategy.RegisterConverters(primitiveConverters);
        }

        /// <summary>
        /// Register custom JSON converters
        /// </summary>
        /// <param name="converters">An array of <see cref="JavaScriptConverter"/> to register</param>
        /// <param name="primitiveConverters">An array of <see cref="JavaScriptPrimitiveConverter"/></param>
        public void RegisterConverters(IEnumerable<JavaScriptConverter> converters,
            IEnumerable<JavaScriptPrimitiveConverter> primitiveConverters)
        {
            if (converters != null)
            {
                this.RegisterConverters(converters);
            }

            if (primitiveConverters != null)
            {
                this.RegisterConverters(primitiveConverters);
            }
        }

        /// <summary>
        /// Serialize an object to JSON
        /// </summary>
        /// <param name="obj">The object to serialize</param>
        /// <returns>A JSON string representation of <paramref name="obj"/></returns>
        public string Serialize(object obj)
        {
            return SimpleJson.SerializeObject(obj, this.serializerStrategy);
        }

        /// <summary>
        /// Serialize an object to JSON and write result to <paramref name="output"/>
        /// </summary>
        /// <param name="obj">The object to serialize</param>
        /// <param name="output">An instance of <see cref="TextWriter" /> to write the serialized <paramref name="obj"/></param>
        public void Serialize(object obj, TextWriter output)
        {
            output.Write(this.Serialize(obj));
        }
    }
}
//
// Json.cs
//
// Author:
//   Marek Habersack <mhabersack@novell.com>
//
// (C) 2008 Novell, Inc.  http://novell.com/
//
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
namespace Nancy.Json
{
    using System;

    internal static class Json
    {
        /// <summary>
        /// Attempts to detect if the content type is JSON.
        /// Supports:
        ///   application/json
        ///   text/json
        ///   [something]+json
        /// Matches are case insensitive to try and be as "accepting" as possible.
        /// </summary>
        /// <param name="contentType">Request content type</param>
        /// <returns>True if content type is JSON, false otherwise</returns>
        public static bool IsJsonContentType(string contentType)
        {
            if (string.IsNullOrEmpty(contentType))
            {
                return false;
            }

            var contentMimeType = contentType.Split(';')[0];

            return contentMimeType.Equals("application/json", StringComparison.OrdinalIgnoreCase) ||
            contentMimeType.StartsWith("application/json-", StringComparison.OrdinalIgnoreCase) ||
            contentMimeType.Equals("text/json", StringComparison.OrdinalIgnoreCase) ||
            contentMimeType.EndsWith("+json", StringComparison.OrdinalIgnoreCase);
        }
    }
}
#region License
// Copyright (c) 2007 James Newton-King
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
#endregion

namespace Nancy.Helpers
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Reflection;

    internal static class ReflectionUtils
    {
        public static bool IsInstantiatableType(Type t)
        {
            if (t == null)
                throw new ArgumentNullException("t");

            if (t.IsAbstract || t.IsInterface || t.IsArray)
                return false;

            if (!HasDefaultConstructor(t))
                return false;

            return true;
        }

        public static bool HasDefaultConstructor(Type t)
        {
            if (t == null)
                throw new ArgumentNullException("t");

            return (t.GetConstructor(BindingFlags.Instance, null, Type.EmptyTypes, null) != null);
        }

        public static bool IsAssignable(Type to, Type from)
        {
            if (to == null)
                throw new ArgumentNullException("to");

            if (to.IsAssignableFrom(from))
                return true;

            if (to.IsGenericType && from.IsGenericTypeDefinition)
                return to.IsAssignableFrom(from.MakeGenericType(to.GetGenericArguments()));

            return false;
        }

        public static bool IsSubClass(Type type, Type check)
        {
            if (type == null || check == null)
                return false;

            if (type == check)
                return true;

            if (check.IsInterface)
            {
                foreach (Type t in type.GetInterfaces())
                {
                    if (IsSubClass(t, check)) return true;
                }
            }
            if (type.IsGenericType && !type.IsGenericTypeDefinition)
            {
                if (IsSubClass(type.GetGenericTypeDefinition(), check))
                    return true;
            }
            return IsSubClass(type.BaseType, check);
        }

        /// <summary>
        /// Gets the type of the typed list's items.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>The type of the typed list's items.</returns>
        public static Type GetTypedListItemType(Type type)
        {
            if (type == null)
                throw new ArgumentNullException("type");

            if (type.IsArray)
                return type.GetElementType();
            else if (type.IsGenericType && typeof(List<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
                return type.GetGenericArguments()[0];
            else
                throw new Exception("Bad type");
        }

        public static Type GetTypedDictionaryValueType(Type type)
        {
            if (type == null)
                throw new ArgumentNullException("type");

            Type genDictType = GetGenericDictionary(type);

            if (genDictType != null)
                return genDictType.GetGenericArguments()[1];
            else if (typeof(IDictionary).IsAssignableFrom(type))
                return null;
            else
                throw new Exception("Bad type");
        }

        static readonly Type GenericDictionaryType = typeof(IDictionary<,>);
        public static Type GetGenericDictionary(Type type)
        {
            if (type.IsGenericType && GenericDictionaryType.IsAssignableFrom(type.GetGenericTypeDefinition()))
                return type;

            Type[] ifaces = type.GetInterfaces();
            if (ifaces != null)
                for (int i = 0; i < ifaces.Length; i++)
                {
                    Type current = GetGenericDictionary(ifaces[i]);
                    if (current != null)
                        return current;
                }

            return null;
        }

        public static Type GetMemberUnderlyingType(MemberInfo member)
        {
            switch (member.MemberType)
            {
                case MemberTypes.Field:
                    return ((FieldInfo)member).FieldType;
                case MemberTypes.Property:
                    return ((PropertyInfo)member).PropertyType;
                case MemberTypes.Event:
                    return ((EventInfo)member).EventHandlerType;
                default:
                    throw new ArgumentException("MemberInfo must be if type FieldInfo, PropertyInfo or EventInfo", "member");
            }
        }

        /// <summary>
        /// Determines whether the member is an indexed property.
        /// </summary>
        /// <param name="member">The member.</param>
        /// <returns>
        /// 	<c>true</c> if the member is an indexed property; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsIndexedProperty(MemberInfo member)
        {
            if (member == null)
                throw new ArgumentNullException("member");

            PropertyInfo propertyInfo = member as PropertyInfo;

            if (propertyInfo != null)
                return IsIndexedProperty(propertyInfo);
            else
                return false;
        }

        /// <summary>
        /// Determines whether the property is an indexed property.
        /// </summary>
        /// <param name="property">The property.</param>
        /// <returns>
        /// 	<c>true</c> if the property is an indexed property; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsIndexedProperty(PropertyInfo property)
        {
            if (property == null)
                throw new ArgumentNullException("property");

            return (property.GetIndexParameters().Length > 0);
        }

        /// <summary>
        /// Gets the member's value on the object.
        /// </summary>
        /// <param name="member">The member.</param>
        /// <param name="target">The target object.</param>
        /// <returns>The member's value on the object.</returns>
        public static object GetMemberValue(MemberInfo member, object target)
        {
            switch (member.MemberType)
            {
                case MemberTypes.Field:
                    return ((FieldInfo)member).GetValue(target);
                case MemberTypes.Property:
                    try
                    {
                        return ((PropertyInfo)member).GetValue(target, null);
                    }
                    catch (TargetParameterCountException e)
                    {
                        throw new ArgumentException("MemberInfo has index parameters", "member", e);
                    }
                default:
                    throw new ArgumentException("MemberInfo is not of type FieldInfo or PropertyInfo", "member");
            }
        }

        /// <summary>
        /// Sets the member's value on the target object.
        /// </summary>
        /// <param name="member">The member.</param>
        /// <param name="target">The target.</param>
        /// <param name="value">The value.</param>
        public static void SetMemberValue(MemberInfo member, object target, object value)
        {
            switch (member.MemberType)
            {
                case MemberTypes.Field:
                    ((FieldInfo)member).SetValue(target, value);
                    break;
                case MemberTypes.Property:
                    ((PropertyInfo)member).SetValue(target, value, null);
                    break;
                default:
                    throw new ArgumentException("MemberInfo must be if type FieldInfo or PropertyInfo", "member");
            }
        }

        /// <summary>
        /// Determines whether the specified MemberInfo can be read.
        /// </summary>
        /// <param name="member">The MemberInfo to determine whether can be read.</param>
        /// <returns>
        /// 	<c>true</c> if the specified MemberInfo can be read; otherwise, <c>false</c>.
        /// </returns>
        public static bool CanReadMemberValue(MemberInfo member)
        {
            switch (member.MemberType)
            {
                case MemberTypes.Field:
                    return true;
                case MemberTypes.Property:
                    return ((PropertyInfo)member).CanRead;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Determines whether the specified MemberInfo can be set.
        /// </summary>
        /// <param name="member">The MemberInfo to determine whether can be set.</param>
        /// <returns>
        /// 	<c>true</c> if the specified MemberInfo can be set; otherwise, <c>false</c>.
        /// </returns>
        public static bool CanSetMemberValue(MemberInfo member)
        {
            switch (member.MemberType)
            {
                case MemberTypes.Field:
                    return true;
                case MemberTypes.Property:
                    return ((PropertyInfo)member).CanWrite;
                default:
                    return false;
            }
        }

        public static IEnumerable<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr)
        {

            MemberInfo[] members = type.GetFields(bindingAttr);
            for (int i = 0; i < members.Length; i++)
                yield return members[i];
            members = type.GetProperties(bindingAttr);
            for (int i = 0; i < members.Length; i++)
                yield return members[i];
        }
    }
}
//
// ScriptIgnoreAttribute.cs
//
// Author:
//   Igor Zelmanovich <igorz@mainsoft.com>
//
// (C) 2007 Mainsoft, Inc.  http://www.mainsoft.com
//
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
namespace Nancy.Json
{
    using System;

    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
    public sealed class ScriptIgnoreAttribute : Attribute
    {
    }
}//
// StringBuilderExtensions.cs
//
// Author:
//   Marek Habersack <mhabersack@novell.com>
//
// (C) 2008 Novell, Inc.  http://novell.com/
//
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
namespace Nancy.Json
{
    using System;
    using System.Text;

    internal static class StringBuilderExtensions
    {
        static void CheckCount(StringBuilder sb, int maxCount)
        {
            if (sb.Length > maxCount)
                throw new InvalidOperationException("Nancy.Json.JsonConfiguration.MaxJsonLength exceeded");
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, char[] value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, string value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, bool value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, byte value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, decimal value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, double value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, short value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, int value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, long value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, object value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, sbyte value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, float value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, ushort value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, uint value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, ulong value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, char value)
        {
            StringBuilder ret = sb.Append(value);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, char value, int repeatCount)
        {
            StringBuilder ret = sb.Append(value, repeatCount);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, char[] value, int startIndex, int charCount)
        {
            StringBuilder ret = sb.Append(value, startIndex, charCount);
            CheckCount(sb, maxCount);
            return ret;
        }

        public static StringBuilder AppendCount(StringBuilder sb, int maxCount, string value, int startIndex, int count)
        {
            StringBuilder ret = sb.Append(value, startIndex, count);
            CheckCount(sb, maxCount);
            return ret;
        }
    }
}//
// Nancy.MimeTypes
//
// Authors:
//	Gonzalo Paniagua Javier (gonzalo@ximian.com)
//
// (C) 2002 Ximian, Inc (http://www.ximian.com)
// (C) 2003-2009 Novell, Inc (http://novell.com)

//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Nancy
{
    using System;
    using System.Collections.Generic;

    public sealed class MimeTypes
    {
        static Dictionary<string, string> mimeTypes;

        static MimeTypes()
        {
            mimeTypes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            mimeTypes.Add("323", "text/h323");
            mimeTypes.Add("3dmf", "x-world/x-3dmf");
            mimeTypes.Add("3dm", "x-world/x-3dmf");
            mimeTypes.Add("7z", "application/x-7z-compressed");
            mimeTypes.Add("aab", "application/x-authorware-bin");
            mimeTypes.Add("aam", "application/x-authorware-map");
            mimeTypes.Add("aas", "application/x-authorware-seg");
            mimeTypes.Add("abc", "text/vnd.abc");
            mimeTypes.Add("acgi", "text/html");
            mimeTypes.Add("acx", "application/internet-property-stream");
            mimeTypes.Add("afl", "video/animaflex");
            mimeTypes.Add("ai", "application/postscript");
            mimeTypes.Add("aif", "audio/aiff");
            mimeTypes.Add("aifc", "audio/aiff");
            mimeTypes.Add("aiff", "audio/aiff");
            mimeTypes.Add("aim", "application/x-aim");
            mimeTypes.Add("aip", "text/x-audiosoft-intra");
            mimeTypes.Add("ani", "application/x-navi-animation");
            mimeTypes.Add("aos", "application/x-nokia-9000-communicator-add-on-software");
            mimeTypes.Add("application", "application/x-ms-application");
            mimeTypes.Add("aps", "application/mime");
            mimeTypes.Add("art", "image/x-jg");
            mimeTypes.Add("asf", "video/x-ms-asf");
            mimeTypes.Add("asm", "text/x-asm");
            mimeTypes.Add("asp", "text/asp");
            mimeTypes.Add("asr", "video/x-ms-asf");
            mimeTypes.Add("asx", "application/x-mplayer2");
            mimeTypes.Add("atom", "application/atom.xml");
            mimeTypes.Add("atomcat", "application/atomcat+xml");
            mimeTypes.Add("atomsvc", "application/atomsvc+xml");
            mimeTypes.Add("au", "audio/x-au");
            mimeTypes.Add("avi", "video/avi");
            mimeTypes.Add("avs", "video/avs-video");
            mimeTypes.Add("axs", "application/olescript");
            mimeTypes.Add("bas", "text/plain");
            mimeTypes.Add("bcpio", "application/x-bcpio");
            mimeTypes.Add("bin", "application/octet-stream");
            mimeTypes.Add("bm", "image/bmp");
            mimeTypes.Add("bmp", "image/bmp");
            mimeTypes.Add("boo", "application/book");
            mimeTypes.Add("book", "application/book");
            mimeTypes.Add("boz", "application/x-bzip2");
            mimeTypes.Add("bsh", "application/x-bsh");
            mimeTypes.Add("bz2", "application/x-bzip2");
            mimeTypes.Add("bz", "application/x-bzip");
            mimeTypes.Add("cat", "application/vnd.ms-pki.seccat");
            mimeTypes.Add("ccad", "application/clariscad");
            mimeTypes.Add("cco", "application/x-cocoa");
            mimeTypes.Add("cc", "text/plain");
            mimeTypes.Add("cdf", "application/cdf");
            mimeTypes.Add("cer", "application/pkix-cert");
            mimeTypes.Add("cha", "application/x-chat");
            mimeTypes.Add("chat", "application/x-chat");
            mimeTypes.Add("class", "application/java");
            mimeTypes.Add("clp", "application/x-msclip");
            mimeTypes.Add("cmx", "image/x-cmx");
            mimeTypes.Add("cod", "image/cis-cod");
            mimeTypes.Add("conf", "text/plain");
            mimeTypes.Add("cpio", "application/x-cpio");
            mimeTypes.Add("cpp", "text/plain");
            mimeTypes.Add("cpt", "application/x-cpt");
            mimeTypes.Add("crd", "application/x-mscardfile");
            mimeTypes.Add("crl", "application/pkix-crl");
            mimeTypes.Add("crt", "application/pkix-cert");
            mimeTypes.Add("csh", "application/x-csh");
            mimeTypes.Add("css", "text/css");
            mimeTypes.Add("c", "text/plain");
            mimeTypes.Add("c++", "text/plain");
            mimeTypes.Add("cs", "text/plain");
            mimeTypes.Add("cxx", "text/plain");
            mimeTypes.Add("dcr", "application/x-director");
            mimeTypes.Add("deepv", "application/x-deepv");
            mimeTypes.Add("def", "text/plain");
            mimeTypes.Add("deploy", "application/octet-stream");
            mimeTypes.Add("der", "application/x-x509-ca-cert");
            mimeTypes.Add("dib", "image/bmp");
            mimeTypes.Add("dif", "video/x-dv");
            mimeTypes.Add("dir", "application/x-director");
            mimeTypes.Add("disco", "application/xml");
            mimeTypes.Add("dll", "application/x-msdownload");
            mimeTypes.Add("dl", "video/dl");
            mimeTypes.Add("doc", "application/msword");
            mimeTypes.Add("dot", "application/msword");
            mimeTypes.Add("dp", "application/commonground");
            mimeTypes.Add("drw", "application/drafting");
            mimeTypes.Add("dvi", "application/x-dvi");
            mimeTypes.Add("dv", "video/x-dv");
            mimeTypes.Add("dwf", "drawing/x-dwf (old)");
            mimeTypes.Add("dwg", "application/acad");
            mimeTypes.Add("dxf", "application/dxf");
            mimeTypes.Add("dxr", "application/x-director");
            mimeTypes.Add("elc", "application/x-elc");
            mimeTypes.Add("el", "text/x-script.elisp");
            mimeTypes.Add("eml", "message/rfc822");
            mimeTypes.Add("eot", "application/vnd.bw-fontobject");
            mimeTypes.Add("eps", "application/postscript");
            mimeTypes.Add("es", "application/x-esrehber");
            mimeTypes.Add("etx", "text/x-setext");
            mimeTypes.Add("evy", "application/envoy");
            mimeTypes.Add("exe", "application/octet-stream");
            mimeTypes.Add("f77", "text/plain");
            mimeTypes.Add("f90", "text/plain");
            mimeTypes.Add("fdf", "application/vnd.fdf");
            mimeTypes.Add("fif", "image/fif");
            mimeTypes.Add("fli", "video/fli");
            mimeTypes.Add("flo", "image/florian");
            mimeTypes.Add("flr", "x-world/x-vrml");
            mimeTypes.Add("flx", "text/vnd.fmi.flexstor");
            mimeTypes.Add("fmf", "video/x-atomic3d-feature");
            mimeTypes.Add("for", "text/plain");
            mimeTypes.Add("fpx", "image/vnd.fpx");
            mimeTypes.Add("frl", "application/freeloader");
            mimeTypes.Add("f", "text/plain");
            mimeTypes.Add("funk", "audio/make");
            mimeTypes.Add("g3", "image/g3fax");
            mimeTypes.Add("gadget", "application/x-windows-gadget");
            mimeTypes.Add("gif", "image/gif");
            mimeTypes.Add("gl", "video/gl");
            mimeTypes.Add("gsd", "audio/x-gsm");
            mimeTypes.Add("gsm", "audio/x-gsm");
            mimeTypes.Add("gsp", "application/x-gsp");
            mimeTypes.Add("gss", "application/x-gss");
            mimeTypes.Add("gtar", "application/x-gtar");
            mimeTypes.Add("g", "text/plain");
            mimeTypes.Add("gz", "application/x-gzip");
            mimeTypes.Add("gzip", "application/x-gzip");
            mimeTypes.Add("hdf", "application/x-hdf");
            mimeTypes.Add("help", "application/x-helpfile");
            mimeTypes.Add("hgl", "application/vnd.hp-HPGL");
            mimeTypes.Add("hh", "text/plain");
            mimeTypes.Add("hlb", "text/x-script");
            mimeTypes.Add("hlp", "application/x-helpfile");
            mimeTypes.Add("hpg", "application/vnd.hp-HPGL");
            mimeTypes.Add("hpgl", "application/vnd.hp-HPGL");
            mimeTypes.Add("hqx", "application/binhex");
            mimeTypes.Add("hta", "application/hta");
            mimeTypes.Add("htc", "text/x-component");
            mimeTypes.Add("h", "text/plain");
            mimeTypes.Add("htmls", "text/html");
            mimeTypes.Add("html", "text/html");
            mimeTypes.Add("htm", "text/html");
            mimeTypes.Add("htt", "text/webviewhtml");
            mimeTypes.Add("htx", "text/html");
            mimeTypes.Add("ice", "x-conference/x-cooltalk");
            mimeTypes.Add("ico", "image/x-icon");
            mimeTypes.Add("idc", "text/plain");
            mimeTypes.Add("ief", "image/ief");
            mimeTypes.Add("iefs", "image/ief");
            mimeTypes.Add("iges", "application/iges");
            mimeTypes.Add("igs", "application/iges");
            mimeTypes.Add("iii", "application/x-iphone");
            mimeTypes.Add("ima", "application/x-ima");
            mimeTypes.Add("imap", "application/x-httpd-imap");
            mimeTypes.Add("inf", "application/inf");
            mimeTypes.Add("ins", "application/x-internett-signup");
            mimeTypes.Add("ip", "application/x-ip2");
            mimeTypes.Add("isp", "application/x-internet-signup");
            mimeTypes.Add("isu", "video/x-isvideo");
            mimeTypes.Add("it", "audio/it");
            mimeTypes.Add("iv", "application/x-inventor");
            mimeTypes.Add("ivf", "video/x-ivf");
            mimeTypes.Add("ivr", "i-world/i-vrml");
            mimeTypes.Add("ivy", "application/x-livescreen");
            mimeTypes.Add("jam", "audio/x-jam");
            mimeTypes.Add("java", "text/plain");
            mimeTypes.Add("jav", "text/plain");
            mimeTypes.Add("jcm", "application/x-java-commerce");
            mimeTypes.Add("jfif", "image/jpeg");
            mimeTypes.Add("jfif-tbnl", "image/jpeg");
            mimeTypes.Add("jpeg", "image/jpeg");
            mimeTypes.Add("jpe", "image/jpeg");
            mimeTypes.Add("jpg", "image/jpeg");
            mimeTypes.Add("jps", "image/x-jps");
            mimeTypes.Add("js", "application/javascript");
            mimeTypes.Add("json", "application/json");
            mimeTypes.Add("jut", "image/jutvision");
            mimeTypes.Add("kar", "audio/midi");
            mimeTypes.Add("ksh", "text/x-script.ksh");
            mimeTypes.Add("la", "audio/nspaudio");
            mimeTypes.Add("lam", "audio/x-liveaudio");
            mimeTypes.Add("latex", "application/x-latex");
            mimeTypes.Add("less", "text/css");
            mimeTypes.Add("list", "text/plain");
            mimeTypes.Add("lma", "audio/nspaudio");
            mimeTypes.Add("log", "text/plain");
            mimeTypes.Add("lsp", "application/x-lisp");
            mimeTypes.Add("lst", "text/plain");
            mimeTypes.Add("lsx", "text/x-la-asf");
            mimeTypes.Add("ltx", "application/x-latex");
            mimeTypes.Add("m13", "application/x-msmediaview");
            mimeTypes.Add("m14", "application/x-msmediaview");
            mimeTypes.Add("m1v", "video/mpeg");
            mimeTypes.Add("m2a", "audio/mpeg");
            mimeTypes.Add("m2v", "video/mpeg");
            mimeTypes.Add("m3u", "audio/x-mpequrl");
            mimeTypes.Add("m4u", "video/x-mpegurl");
            mimeTypes.Add("m4v", "video/mp4");
            mimeTypes.Add("m4a", "audio/mp4");
            mimeTypes.Add("m4r", "audio/mp4");
            mimeTypes.Add("m4b", "audio/mp4");
            mimeTypes.Add("m4p", "audio/mp4");
            mimeTypes.Add("man", "application/x-troff-man");
            mimeTypes.Add("manifest", "application/x-ms-manifest");
            mimeTypes.Add("map", "application/x-navimap");
            mimeTypes.Add("mar", "text/plain");
            mimeTypes.Add("mbd", "application/mbedlet");
            mimeTypes.Add("mc$", "application/x-magic-cap-package-1.0");
            mimeTypes.Add("mcd", "application/mcad");
            mimeTypes.Add("mcf", "image/vasa");
            mimeTypes.Add("mcp", "application/netmc");
            mimeTypes.Add("mdb", "application/x-msaccess");
            mimeTypes.Add("me", "application/x-troff-me");
            mimeTypes.Add("mht", "message/rfc822");
            mimeTypes.Add("mhtml", "message/rfc822");
            mimeTypes.Add("mid", "audio/midi");
            mimeTypes.Add("midi", "audio/midi");
            mimeTypes.Add("mif", "application/x-mif");
            mimeTypes.Add("mime", "message/rfc822");
            mimeTypes.Add("mjf", "audio/x-vnd.AudioExplosion.MjuiceMediaFile");
            mimeTypes.Add("mjpg", "video/x-motion-jpeg");
            mimeTypes.Add("mm", "application/base64");
            mimeTypes.Add("mme", "application/base64");
            mimeTypes.Add("mny", "application/x-msmoney");
            mimeTypes.Add("mod", "audio/mod");
            mimeTypes.Add("moov", "video/quicktime");
            mimeTypes.Add("movie", "video/x-sgi-movie");
            mimeTypes.Add("mov", "video/quicktime");
            mimeTypes.Add("mp2", "video/mpeg");
            mimeTypes.Add("mp3", "audio/mpeg");
            mimeTypes.Add("mp4", "video/mp4");
            mimeTypes.Add("mp4v", "video/mp4");
            mimeTypes.Add("mpa", "audio/mpeg");
            mimeTypes.Add("mpc", "application/x-project");
            mimeTypes.Add("mpeg", "video/mpeg");
            mimeTypes.Add("mpe", "video/mpeg");
            mimeTypes.Add("mpga", "audio/mpeg");
            mimeTypes.Add("mpg", "video/mpeg");
            mimeTypes.Add("mpg4", "video/mp4");
            mimeTypes.Add("mpp", "application/vnd.ms-project");
            mimeTypes.Add("mpt", "application/x-project");
            mimeTypes.Add("mpv2", "video/mpeg");
            mimeTypes.Add("mpv", "application/x-project");
            mimeTypes.Add("mpx", "application/x-project");
            mimeTypes.Add("mrc", "application/marc");
            mimeTypes.Add("ms", "application/x-troff-ms");
            mimeTypes.Add("m", "text/plain");
            mimeTypes.Add("mvb", "application/x-msmediaview");
            mimeTypes.Add("mv", "video/x-sgi-movie");
            mimeTypes.Add("my", "audio/make");
            mimeTypes.Add("mzz", "application/x-vnd.AudioExplosion.mzz");
            mimeTypes.Add("nap", "image/naplps");
            mimeTypes.Add("naplps", "image/naplps");
            mimeTypes.Add("nc", "application/x-netcdf");
            mimeTypes.Add("ncm", "application/vnd.nokia.configuration-message");
            mimeTypes.Add("niff", "image/x-niff");
            mimeTypes.Add("nif", "image/x-niff");
            mimeTypes.Add("nix", "application/x-mix-transfer");
            mimeTypes.Add("nsc", "application/x-conference");
            mimeTypes.Add("nvd", "application/x-navidoc");
            mimeTypes.Add("nws", "message/rfc822");
            mimeTypes.Add("oda", "application/oda");
            mimeTypes.Add("ods", "application/oleobject");
            mimeTypes.Add("oga", "audio/ogg");
            mimeTypes.Add("ogg", "audio/ogg");
            mimeTypes.Add("ogv", "video/ogg");
            mimeTypes.Add("omc", "application/x-omc");
            mimeTypes.Add("omcd", "application/x-omcdatamaker");
            mimeTypes.Add("omcr", "application/x-omcregerator");
            mimeTypes.Add("otf", "application/x-font-otf");
            mimeTypes.Add("p10", "application/pkcs10");
            mimeTypes.Add("p12", "application/pkcs-12");
            mimeTypes.Add("p7a", "application/x-pkcs7-signature");
            mimeTypes.Add("p7b", "application/x-pkcs7-certificates");
            mimeTypes.Add("p7c", "application/pkcs7-mime");
            mimeTypes.Add("p7m", "application/pkcs7-mime");
            mimeTypes.Add("p7r", "application/x-pkcs7-certreqresp");
            mimeTypes.Add("p7s", "application/pkcs7-signature");
            mimeTypes.Add("part", "application/pro_eng");
            mimeTypes.Add("pas", "text/pascal");
            mimeTypes.Add("pbm", "image/x-portable-bitmap");
            mimeTypes.Add("pcl", "application/x-pcl");
            mimeTypes.Add("pct", "image/x-pict");
            mimeTypes.Add("pcx", "image/x-pcx");
            mimeTypes.Add("pdb", "chemical/x-pdb");
            mimeTypes.Add("pdf", "application/pdf");
            mimeTypes.Add("pfunk", "audio/make");
            mimeTypes.Add("pfx", "application/x-pkcs12");
            mimeTypes.Add("pgm", "image/x-portable-graymap");
            mimeTypes.Add("pic", "image/pict");
            mimeTypes.Add("pict", "image/pict");
            mimeTypes.Add("pkg", "application/x-newton-compatible-pkg");
            mimeTypes.Add("pko", "application/vnd.ms-pki.pko");
            mimeTypes.Add("pl", "text/plain");
            mimeTypes.Add("plx", "application/x-PiXCLscript");
            mimeTypes.Add("pm4", "application/x-pagemaker");
            mimeTypes.Add("pm5", "application/x-pagemaker");
            mimeTypes.Add("pma", "application/x-perfmon");
            mimeTypes.Add("pmc", "application/x-perfmon");
            mimeTypes.Add("pm", "image/x-xpixmap");
            mimeTypes.Add("pml", "application/x-perfmon");
            mimeTypes.Add("pmr", "application/x-perfmon");
            mimeTypes.Add("pmw", "application/x-perfmon");
            mimeTypes.Add("png", "image/png");
            mimeTypes.Add("pnm", "application/x-portable-anymap");
            mimeTypes.Add("pot", "application/mspowerpoint");
            mimeTypes.Add("pov", "model/x-pov");
            mimeTypes.Add("ppa", "application/vnd.ms-powerpoint");
            mimeTypes.Add("ppm", "image/x-portable-pixmap");
            mimeTypes.Add("pps", "application/mspowerpoint");
            mimeTypes.Add("ppt", "application/mspowerpoint");
            mimeTypes.Add("ppz", "application/mspowerpoint");
            mimeTypes.Add("pre", "application/x-freelance");
            mimeTypes.Add("prf", "application/pics-rules");
            mimeTypes.Add("prt", "application/pro_eng");
            mimeTypes.Add("ps", "application/postscript");
            mimeTypes.Add("p", "text/x-pascal");
            mimeTypes.Add("pub", "application/x-mspublisher");
            mimeTypes.Add("pvu", "paleovu/x-pv");
            mimeTypes.Add("pwz", "application/vnd.ms-powerpoint");
            mimeTypes.Add("pyc", "applicaiton/x-bytecode.python");
            mimeTypes.Add("py", "text/x-script.phyton");
            mimeTypes.Add("qcp", "audio/vnd.qcelp");
            mimeTypes.Add("qd3d", "x-world/x-3dmf");
            mimeTypes.Add("qd3", "x-world/x-3dmf");
            mimeTypes.Add("qif", "image/x-quicktime");
            mimeTypes.Add("qtc", "video/x-qtc");
            mimeTypes.Add("qtif", "image/x-quicktime");
            mimeTypes.Add("qti", "image/x-quicktime");
            mimeTypes.Add("qt", "video/quicktime");
            mimeTypes.Add("ra", "audio/x-pn-realaudio");
            mimeTypes.Add("ram", "audio/x-pn-realaudio");
            mimeTypes.Add("ras", "application/x-cmu-raster");
            mimeTypes.Add("rast", "image/cmu-raster");
            mimeTypes.Add("rexx", "text/x-script.rexx");
            mimeTypes.Add("rf", "image/vnd.rn-realflash");
            mimeTypes.Add("rgb", "image/x-rgb");
            mimeTypes.Add("rm", "application/vnd.rn-realmedia");
            mimeTypes.Add("rmi", "audio/mid");
            mimeTypes.Add("rmm", "audio/x-pn-realaudio");
            mimeTypes.Add("rmp", "audio/x-pn-realaudio");
            mimeTypes.Add("rng", "application/ringing-tones");
            mimeTypes.Add("rnx", "application/vnd.rn-realplayer");
            mimeTypes.Add("roff", "application/x-troff");
            mimeTypes.Add("rp", "image/vnd.rn-realpix");
            mimeTypes.Add("rpm", "audio/x-pn-realaudio-plugin");
            mimeTypes.Add("rss", "application/xml");
            mimeTypes.Add("rtf", "text/richtext");
            mimeTypes.Add("rt", "text/richtext");
            mimeTypes.Add("rtx", "text/richtext");
            mimeTypes.Add("rv", "video/vnd.rn-realvideo");
            mimeTypes.Add("s3m", "audio/s3m");
            mimeTypes.Add("sbk", "application/x-tbook");
            mimeTypes.Add("scd", "application/x-msschedule");
            mimeTypes.Add("scm", "application/x-lotusscreencam");
            mimeTypes.Add("sct", "text/scriptlet");
            mimeTypes.Add("sdml", "text/plain");
            mimeTypes.Add("sdp", "application/sdp");
            mimeTypes.Add("sdr", "application/sounder");
            mimeTypes.Add("sea", "application/sea");
            mimeTypes.Add("set", "application/set");
            mimeTypes.Add("setpay", "application/set-payment-initiation");
            mimeTypes.Add("setreg", "application/set-registration-initiation");
            mimeTypes.Add("sgml", "text/sgml");
            mimeTypes.Add("sgm", "text/sgml");
            mimeTypes.Add("shar", "application/x-bsh");
            mimeTypes.Add("sh", "text/x-script.sh");
            mimeTypes.Add("shtml", "text/html");
            mimeTypes.Add("sid", "audio/x-psid");
            mimeTypes.Add("sit", "application/x-sit");
            mimeTypes.Add("skd", "application/x-koan");
            mimeTypes.Add("skm", "application/x-koan");
            mimeTypes.Add("skp", "application/x-koan");
            mimeTypes.Add("skt", "application/x-koan");
            mimeTypes.Add("sl", "application/x-seelogo");
            mimeTypes.Add("smi", "application/smil");
            mimeTypes.Add("smil", "application/smil");
            mimeTypes.Add("snd", "audio/basic");
            mimeTypes.Add("sol", "application/solids");
            mimeTypes.Add("spc", "application/x-pkcs7-certificates");
            mimeTypes.Add("spl", "application/futuresplash");
            mimeTypes.Add("spr", "application/x-sprite");
            mimeTypes.Add("sprite", "application/x-sprite");
            mimeTypes.Add("spx", "audio/ogg");
            mimeTypes.Add("src", "application/x-wais-source");
            mimeTypes.Add("ssi", "text/x-server-parsed-html");
            mimeTypes.Add("ssm", "application/streamingmedia");
            mimeTypes.Add("sst", "application/vnd.ms-pki.certstore");
            mimeTypes.Add("step", "application/step");
            mimeTypes.Add("s", "text/x-asm");
            mimeTypes.Add("stl", "application/sla");
            mimeTypes.Add("stm", "text/html");
            mimeTypes.Add("stp", "application/step");
            mimeTypes.Add("sv4cpio", "application/x-sv4cpio");
            mimeTypes.Add("sv4crc", "application/x-sv4crc");
            mimeTypes.Add("svf", "image/x-dwg");
            mimeTypes.Add("svg", "image/svg+xml");
            mimeTypes.Add("svgz", "image/svg+xml");
            mimeTypes.Add("svr", "application/x-world");
            mimeTypes.Add("swf", "application/x-shockwave-flash");
            mimeTypes.Add("talk", "text/x-speech");
            mimeTypes.Add("t", "application/x-troff");
            mimeTypes.Add("tar", "application/x-tar");
            mimeTypes.Add("tbk", "application/toolbook");
            mimeTypes.Add("tcl", "text/x-script.tcl");
            mimeTypes.Add("tcsh", "text/x-script.tcsh");
            mimeTypes.Add("tex", "application/x-tex");
            mimeTypes.Add("texi", "application/x-texinfo");
            mimeTypes.Add("texinfo", "application/x-texinfo");
            mimeTypes.Add("text", "text/plain");
            mimeTypes.Add("tgz", "application/x-compressed");
            mimeTypes.Add("tiff", "image/tiff");
            mimeTypes.Add("tif", "image/tiff");
            mimeTypes.Add("torrent", "application/x-bittorrent");
            mimeTypes.Add("tr", "application/x-troff");
            mimeTypes.Add("trm", "application/x-msterminal");
            mimeTypes.Add("tsi", "audio/tsp-audio");
            mimeTypes.Add("tsp", "audio/tsplayer");
            mimeTypes.Add("tsv", "text/tab-separated-values");
            mimeTypes.Add("ttf", "application/x-font-ttf");
            mimeTypes.Add("turbot", "image/florian");
            mimeTypes.Add("txt", "text/plain");
            mimeTypes.Add("uil", "text/x-uil");
            mimeTypes.Add("uls", "text/iuls");
            mimeTypes.Add("unis", "text/uri-list");
            mimeTypes.Add("uni", "text/uri-list");
            mimeTypes.Add("unv", "application/i-deas");
            mimeTypes.Add("uris", "text/uri-list");
            mimeTypes.Add("uri", "text/uri-list");
            mimeTypes.Add("ustar", "multipart/x-ustar");
            mimeTypes.Add("uue", "text/x-uuencode");
            mimeTypes.Add("uu", "text/x-uuencode");
            mimeTypes.Add("vcd", "application/x-cdlink");
            mimeTypes.Add("vcf", "text/x-vcard");
            mimeTypes.Add("vcs", "text/x-vCalendar");
            mimeTypes.Add("vda", "application/vda");
            mimeTypes.Add("vdo", "video/vdo");
            mimeTypes.Add("vew", "application/groupwise");
            mimeTypes.Add("vivo", "video/vivo");
            mimeTypes.Add("viv", "video/vivo");
            mimeTypes.Add("vmd", "application/vocaltec-media-desc");
            mimeTypes.Add("vmf", "application/vocaltec-media-file");
            mimeTypes.Add("voc", "audio/voc");
            mimeTypes.Add("vos", "video/vosaic");
            mimeTypes.Add("vox", "audio/voxware");
            mimeTypes.Add("vqe", "audio/x-twinvq-plugin");
            mimeTypes.Add("vqf", "audio/x-twinvq");
            mimeTypes.Add("vql", "audio/x-twinvq-plugin");
            mimeTypes.Add("vrml", "application/x-vrml");
            mimeTypes.Add("vrt", "x-world/x-vrt");
            mimeTypes.Add("vsd", "application/x-visio");
            mimeTypes.Add("vst", "application/x-visio");
            mimeTypes.Add("vsw", "application/x-visio");
            mimeTypes.Add("w60", "application/wordperfect6.0");
            mimeTypes.Add("w61", "application/wordperfect6.1");
            mimeTypes.Add("w6w", "application/msword");
            mimeTypes.Add("wav", "audio/wav");
            mimeTypes.Add("wb1", "application/x-qpro");
            mimeTypes.Add("wbmp", "image/vnd.wap.wbmp");
            mimeTypes.Add("wcm", "application/vnd.ms-works");
            mimeTypes.Add("wdb", "application/vnd.ms-works");
            mimeTypes.Add("web", "application/vnd.xara");
            mimeTypes.Add("webm", "video/webm");
            mimeTypes.Add("wiz", "application/msword");
            mimeTypes.Add("wk1", "application/x-123");
            mimeTypes.Add("wks", "application/vnd.ms-works");
            mimeTypes.Add("wmf", "windows/metafile");
            mimeTypes.Add("wmlc", "application/vnd.wap.wmlc");
            mimeTypes.Add("wmlsc", "application/vnd.wap.wmlscriptc");
            mimeTypes.Add("wmls", "text/vnd.wap.wmlscript");
            mimeTypes.Add("wml", "text/vnd.wap.wml");
            mimeTypes.Add("woff", "application/font-woff");
            mimeTypes.Add("word", "application/msword");
            mimeTypes.Add("wp5", "application/wordperfect");
            mimeTypes.Add("wp6", "application/wordperfect");
            mimeTypes.Add("wp", "application/wordperfect");
            mimeTypes.Add("wpd", "application/wordperfect");
            mimeTypes.Add("wps", "application/vnd.ms-works");
            mimeTypes.Add("wq1", "application/x-lotus");
            mimeTypes.Add("wri", "application/mswrite");
            mimeTypes.Add("wrl", "application/x-world");
            mimeTypes.Add("wrz", "model/vrml");
            mimeTypes.Add("wsc", "text/scriplet");
            mimeTypes.Add("wsdl", "application/xml");
            mimeTypes.Add("wsrc", "application/x-wais-source");
            mimeTypes.Add("wtk", "application/x-wintalk");
            mimeTypes.Add("xaf", "x-world/x-vrml");
            mimeTypes.Add("xaml", "application/xaml+xml");
            mimeTypes.Add("xap", "application/x-silverlight-app");
            mimeTypes.Add("xbap", "application/x-ms-xbap");
            mimeTypes.Add("xbm", "image/x-xbitmap");
            mimeTypes.Add("xdr", "video/x-amt-demorun");
            mimeTypes.Add("xgz", "xgl/drawing");
            mimeTypes.Add("xhtml", "application/xhtml+xml");
            mimeTypes.Add("xht", "application/xhtml+xml");
            mimeTypes.Add("xif", "image/vnd.xiff");
            mimeTypes.Add("xla", "application/excel");
            mimeTypes.Add("xl", "application/excel");
            mimeTypes.Add("xlb", "application/excel");
            mimeTypes.Add("xlc", "application/excel");
            mimeTypes.Add("xld", "application/excel");
            mimeTypes.Add("xlk", "application/excel");
            mimeTypes.Add("xll", "application/excel");
            mimeTypes.Add("xlm", "application/excel");
            mimeTypes.Add("xls", "application/excel");
            mimeTypes.Add("xlt", "application/excel");
            mimeTypes.Add("xlv", "application/excel");
            mimeTypes.Add("xlw", "application/excel");
            mimeTypes.Add("xm", "audio/xm");
            mimeTypes.Add("xml", "application/xml");
            mimeTypes.Add("xmz", "xgl/movie");
            mimeTypes.Add("xof", "x-world/x-vrml");
            mimeTypes.Add("xpi", "application/x-xpinstall");
            mimeTypes.Add("xpix", "application/x-vnd.ls-xpix");
            mimeTypes.Add("xpm", "image/xpm");
            mimeTypes.Add("x-png", "image/png");
            mimeTypes.Add("xsd", "application/xml");
            mimeTypes.Add("xsl", "application/xml");
            mimeTypes.Add("xsr", "video/x-amt-showrun");
            mimeTypes.Add("xwd", "image/x-xwd");
            mimeTypes.Add("xyz", "chemical/x-pdb");
            mimeTypes.Add("z", "application/x-compressed");
            mimeTypes.Add("zip", "application/zip");
            mimeTypes.Add("zsh", "text/x-script.zsh");

            // Office Formats
            mimeTypes.Add("docm", "application/vnd.ms-word.document.macroEnabled.12");
            mimeTypes.Add("docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
            mimeTypes.Add("dotm", "application/vnd.ms-word.template.macroEnabled.12");
            mimeTypes.Add("dotx", "application/vnd.openxmlformats-officedocument.wordprocessingml.template");
            mimeTypes.Add("potm", "application/vnd.ms-powerpoint.template.macroEnabled.12");
            mimeTypes.Add("potx", "application/vnd.openxmlformats-officedocument.presentationml.template");
            mimeTypes.Add("ppam", "application/vnd.ms-powerpoint.addin.macroEnabled.12");
            mimeTypes.Add("ppsm", "application/vnd.ms-powerpoint.slideshow.macroEnabled.12");
            mimeTypes.Add("ppsx", "application/vnd.openxmlformats-officedocument.presentationml.slideshow");
            mimeTypes.Add("pptm", "application/vnd.ms-powerpoint.presentation.macroEnabled.12");
            mimeTypes.Add("pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation");
            mimeTypes.Add("xlam", "application/vnd.ms-excel.addin.macroEnabled.12");
            mimeTypes.Add("xlsb", "application/vnd.ms-excel.sheet.binary.macroEnabled.12");
            mimeTypes.Add("xlsm", "application/vnd.ms-excel.sheet.macroEnabled.12");
            mimeTypes.Add("xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            mimeTypes.Add("xltm", "application/vnd.ms-excel.template.macroEnabled.12");
            mimeTypes.Add("xltx", "application/vnd.openxmlformats-officedocument.spreadsheetml.template");
        }

        public static void AddType(string extension, string type)
        {
            mimeTypes.Add(extension, type);
        }

        public static string GetMimeType(string fileName)
        {
            string result = null;
            int dot = fileName.LastIndexOf('.');

            if (dot != -1 && fileName.Length > dot + 1)
                mimeTypes.TryGetValue(fileName.Substring(dot + 1), out result);

            if (result == null)
                result = "application/octet-stream";

            return result;
        }
    }
}
namespace Nancy.ModelBinding
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Model binding context object
    /// </summary>
    public class BindingContext
    {
        /// <summary>
        /// The binding configuration
        /// </summary>
        public BindingConfig Configuration { get; set; }

        /// <summary>
        /// Current Nancy context
        /// </summary>
        public NancyContext Context { get; set; }

        /// <summary>
        /// Binding destination type
        /// </summary>
        public Type DestinationType { get; set; }

        /// <summary>
        /// The generic type of a collection is only used when DestinationType is a enumerable.
        /// </summary>
        public Type GenericType { get; set; }

        /// <summary>
        /// The current model object (or null for body deserialization)
        /// </summary>
        public object Model { get; set; }

        /// <summary>
        /// DestinationType properties that are not black listed
        /// </summary>
        public IEnumerable<BindingMemberInfo> ValidModelBindingMembers { get; set; }

        /// <summary>
        /// The incoming data fields
        /// </summary>
        public IDictionary<string, string> RequestData { get; set; }

        /// <summary>
        /// Available type converters - user converters followed by any defaults
        /// </summary>
        public IEnumerable<ITypeConverter> TypeConverters { get; set; }
    }
}
namespace Nancy.ModelBinding
{
    using System.Collections.Generic;
    using Nancy.Configuration;
    using Nancy.ModelBinding.DefaultBodyDeserializers;
    using Nancy.ModelBinding.DefaultConverters;

    /// <summary>
    /// Provides default binding converters/deserializers
    /// The defaults have less precedence than any user supplied ones
    /// </summary>
    public class BindingDefaults
    {
        private readonly IEnumerable<ITypeConverter> defaultTypeConverters;
        private readonly IEnumerable<IBodyDeserializer> defaultBodyDeserializers;

        /// <summary>
        /// Initializes a new instance of the <see cref="BindingDefaults"/> class,
        /// with the provided <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public BindingDefaults(INancyEnvironment environment)
        {
            // Ordering is important - for now we will new just these up
            // as the binding defaults class itself is replaceable if necessary,
            // and none of defaults have any dependencies.
            this.defaultTypeConverters = new ITypeConverter[]
            {
                new CollectionConverter(),
                new FallbackConverter(),
            };

            this.defaultBodyDeserializers = new IBodyDeserializer[]
            {
                new JsonBodyDeserializer(environment),
                new XmlBodyDeserializer()
            };
        }

        /// <summary>
        /// Gets the default type converters
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> of <see cref="ITypeConverter"/> instances.</value>
        public virtual IEnumerable<ITypeConverter> DefaultTypeConverters
        {
            get { return this.defaultTypeConverters; }
        }

        /// <summary>
        /// Gets the default type converters
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> of <see cref="IBodyDeserializer"/> instances.</value>
        public virtual IEnumerable<IBodyDeserializer> DefaultBodyDeserializers
        {
            get { return this.defaultBodyDeserializers; }
        }
    }
}
namespace Nancy.ModelBinding
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using System.Text.RegularExpressions;

    using Nancy.Extensions;

    /// <summary>
    /// Default binder - used as a fallback when a specific modelbinder
    /// is not available.
    /// </summary>
    public class DefaultBinder : IBinder
    {
        private readonly IEnumerable<ITypeConverter> typeConverters;

        private readonly IEnumerable<IBodyDeserializer> bodyDeserializers;

        private readonly IFieldNameConverter fieldNameConverter;

        private readonly BindingDefaults defaults;

        private readonly static MethodInfo ToListMethodInfo = typeof(Enumerable).GetMethod("ToList", BindingFlags.Public | BindingFlags.Static);
        private readonly static MethodInfo ToArrayMethodInfo = typeof(Enumerable).GetMethod("ToArray", BindingFlags.Public | BindingFlags.Static);
        private static readonly Regex BracketRegex = new Regex(@"\[(\d+)\]\z", RegexOptions.Compiled);
        private static readonly Regex UnderscoreRegex = new Regex(@"_(\d+)\z", RegexOptions.Compiled);

        public DefaultBinder(IEnumerable<ITypeConverter> typeConverters, IEnumerable<IBodyDeserializer> bodyDeserializers, IFieldNameConverter fieldNameConverter, BindingDefaults defaults)
        {
            if (typeConverters == null)
            {
                throw new ArgumentNullException("typeConverters");
            }

            if (bodyDeserializers == null)
            {
                throw new ArgumentNullException("bodyDeserializers");
            }

            if (fieldNameConverter == null)
            {
                throw new ArgumentNullException("fieldNameConverter");
            }

            if (defaults == null)
            {
                throw new ArgumentNullException("defaults");
            }

            this.typeConverters = typeConverters;
            this.bodyDeserializers = bodyDeserializers;
            this.fieldNameConverter = fieldNameConverter;
            this.defaults = defaults;
        }

        /// <summary>
        /// Bind to the given model type
        /// </summary>
        /// <param name="context">Current context</param>
        /// <param name="modelType">Model type to bind to</param>
        /// <param name="instance">Optional existing instance</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blackList">Blacklisted binding property names</param>
        /// <returns>Bound model</returns>
        public object Bind(NancyContext context, Type modelType, object instance, BindingConfig configuration, params string[] blackList)
        {
            Type genericType = null;
            if (modelType.IsArray() || modelType.IsCollection() || modelType.IsEnumerable())
            {
                //make sure it has a generic type
                if (modelType.IsGenericType())
                {
                    genericType = modelType.GetGenericArguments().FirstOrDefault();
                }
                else
                {
                    var ienumerable =
                        modelType.GetInterfaces().Where(i => i.IsGenericType()).FirstOrDefault(
                            i => i.GetGenericTypeDefinition() == typeof(IEnumerable<>));
                    genericType = ienumerable == null ? null : ienumerable.GetGenericArguments().FirstOrDefault();
                }

                if (genericType == null)
                {
                    throw new ArgumentException("When modelType is an enumerable it must specify the type.", "modelType");
                }
            }

            var bindingContext =
                this.CreateBindingContext(context, modelType, instance, configuration, blackList, genericType);

            try
            {
                var bodyDeserializedModel = this.DeserializeRequestBody(bindingContext);
                if (bodyDeserializedModel != null)
                {
                    UpdateModelWithDeserializedModel(bodyDeserializedModel, bindingContext);
                }
            }
            catch (Exception exception)
            {
                if (!bindingContext.Configuration.IgnoreErrors)
                {
                    throw new ModelBindingException(modelType, innerException: exception);
                }
            }

            var bindingExceptions = new List<PropertyBindingException>();

            if (!bindingContext.Configuration.BodyOnly)
            {
                if (bindingContext.DestinationType.IsCollection() || bindingContext.DestinationType.IsArray() || bindingContext.DestinationType.IsEnumerable())
                {
                    var loopCount = this.GetBindingListInstanceCount(context);
                    var model = (IList)bindingContext.Model;
                    for (var i = 0; i < loopCount; i++)
                    {
                        object genericinstance;
                        if (model.Count > i)
                        {
                            genericinstance = model[i];
                        }
                        else
                        {
                            genericinstance = Activator.CreateInstance(bindingContext.GenericType);
                            model.Add(genericinstance);
                        }

                        foreach (var modelProperty in bindingContext.ValidModelBindingMembers)
                        {
                            var existingCollectionValue = modelProperty.GetValue(genericinstance);

                            var collectionStringValue = GetValue(modelProperty.Name, bindingContext, i);

                            if (this.BindingValueIsValid(collectionStringValue, existingCollectionValue, modelProperty,
                                                    bindingContext))
                            {
                                try
                                {
                                    BindValue(modelProperty, collectionStringValue, bindingContext, genericinstance);
                                }
                                catch (PropertyBindingException ex)
                                {
                                    bindingExceptions.Add(ex);
                                }
                            }
                        }
                    }
                }
                else
                {
                    foreach (var modelProperty in bindingContext.ValidModelBindingMembers)
                    {
                        var existingValue = modelProperty.GetValue(bindingContext.Model);

                        var stringValue = GetValue(modelProperty.Name, bindingContext);

                        if (this.BindingValueIsValid(stringValue, existingValue, modelProperty, bindingContext))
                        {
                            try
                            {
                                BindValue(modelProperty, stringValue, bindingContext);
                            }
                            catch (PropertyBindingException ex)
                            {
                                bindingExceptions.Add(ex);
                            }
                        }
                    }
                }

                if (bindingExceptions.Any() && !bindingContext.Configuration.IgnoreErrors)
                {
                    throw new ModelBindingException(modelType, bindingExceptions);
                }
            }

            if (modelType.IsArray())
            {
                var generictoArrayMethod = ToArrayMethodInfo.MakeGenericMethod(new[] { genericType });
                return generictoArrayMethod.Invoke(null, new[] { bindingContext.Model });
            }
            return bindingContext.Model;
        }

        private bool BindingValueIsValid(string bindingValue, object existingValue, BindingMemberInfo modelProperty, BindingContext bindingContext)
        {
            return (!string.IsNullOrEmpty(bindingValue) &&
                    (IsDefaultValue(existingValue, modelProperty.PropertyType) ||
                     bindingContext.Configuration.Overwrite));
        }

        /// <summary>
        /// Gets the number of distinct indexes from context:
        ///
        /// i.e:
        ///  IntProperty_5
        ///  StringProperty_5
        ///  IntProperty_7
        ///  StringProperty_8
        ///  You'll end up with a list of 3 matches: 5,7,8
        ///
        /// </summary>
        /// <param name="context">Current Context </param>
        /// <returns>An int containing the number of elements</returns>
        private int GetBindingListInstanceCount(NancyContext context)
        {
            var dictionary = context.Request.Form as IDictionary<string, object>;

            if (dictionary == null)
            {
                return 0;
            }

            return dictionary.Keys.Select(IsMatch).Where(x => x != -1).Distinct().ToArray().Length;
        }

        private static int IsMatch(string item)
        {
            var bracketMatch = BracketRegex.Match(item);
            if (bracketMatch.Success)
            {
                return int.Parse(bracketMatch.Groups[1].Value);
            }

            var underscoreMatch = UnderscoreRegex.Match(item);

            if (underscoreMatch.Success)
            {
                return int.Parse(underscoreMatch.Groups[1].Value);
            }

            return -1;
        }

        private static void UpdateModelWithDeserializedModel(object bodyDeserializedModel, BindingContext bindingContext)
        {
            var bodyDeserializedModelType = bodyDeserializedModel.GetType();

            if (bodyDeserializedModelType.IsValueType)
            {
                bindingContext.Model = bodyDeserializedModel;
                return;
            }

            if (bodyDeserializedModelType.IsCollection() || bodyDeserializedModelType.IsEnumerable() ||
                bodyDeserializedModelType.IsArray())
            {
                var count = 0;

                foreach (var o in (IEnumerable)bodyDeserializedModel)
                {
                    var model = (IList)bindingContext.Model;

                    if (o.GetType().IsValueType || o is string)
                    {
                        HandleValueTypeCollectionElement(model, count, o);
                    }
                    else
                    {
                        HandleReferenceTypeCollectionElement(bindingContext, model, count, o);
                    }

                    count++;
                }
            }
            else
            {
                foreach (var modelProperty in bindingContext.ValidModelBindingMembers)
                {
                    var existingValue =
                        modelProperty.GetValue(bindingContext.Model);

                    if (IsDefaultValue(existingValue, modelProperty.PropertyType) || bindingContext.Configuration.Overwrite)
                    {
                        CopyValue(modelProperty, bodyDeserializedModel, bindingContext.Model);
                    }
                }
            }
        }

        private static void HandleValueTypeCollectionElement(IList model, int count, object o)
        {
            // If the instance specified in the binder contains the n-th element use that
            if (model.Count > count)
            {
                return;
            }

            model.Add(o);
        }

        private static void HandleReferenceTypeCollectionElement(BindingContext bindingContext, IList model, int count, object o)
        {
            // If the instance specified in the binder contains the n-th element use that otherwise make a new one.
            object genericTypeInstance;
            if (model.Count > count)
            {
                genericTypeInstance = model[count];
            }
            else
            {
                genericTypeInstance = Activator.CreateInstance(bindingContext.GenericType);
                model.Add(genericTypeInstance);
            }

            foreach (var modelProperty in bindingContext.ValidModelBindingMembers)
            {
                var existingValue = modelProperty.GetValue(genericTypeInstance);

                if (IsDefaultValue(existingValue, modelProperty.PropertyType) || bindingContext.Configuration.Overwrite)
                {
                    CopyValue(modelProperty, o, genericTypeInstance);
                }
            }
        }

        private static void CopyValue(BindingMemberInfo modelProperty, object source, object destination)
        {
            var newValue = modelProperty.GetValue(source);

            modelProperty.SetValue(destination, newValue);
        }

        private static bool IsDefaultValue(object existingValue, Type propertyType)
        {
            return propertyType.IsValueType
                ? Equals(existingValue, Activator.CreateInstance(propertyType))
                : existingValue == null;
        }

        private BindingContext CreateBindingContext(NancyContext context, Type modelType, object instance, BindingConfig configuration, IEnumerable<string> blackList, Type genericType)
        {
            return new BindingContext
            {
                Configuration = configuration,
                Context = context,
                DestinationType = modelType,
                Model = CreateModel(modelType, genericType, instance),
                ValidModelBindingMembers = GetBindingMembers(modelType, genericType, blackList).ToList(),
                RequestData = this.GetDataFields(context),
                GenericType = genericType,
                TypeConverters = this.typeConverters.Concat(this.defaults.DefaultTypeConverters),
            };
        }

        private IDictionary<string, string> GetDataFields(NancyContext context)
        {
            var dictionaries = new IDictionary<string, string>[]
                {
                    ConvertDynamicDictionary(context.Request.Form),
                    ConvertDynamicDictionary(context.Request.Query),
                    ConvertDynamicDictionary(context.Parameters)
                };

            return dictionaries.Merge();
        }

        private IDictionary<string, string> ConvertDynamicDictionary(DynamicDictionary dictionary)
        {
            if (dictionary == null)
            {
                return null;
            }

            return dictionary.GetDynamicMemberNames().ToDictionary(
                    memberName => this.fieldNameConverter.Convert(memberName),
                    memberName => (string)dictionary[memberName]);
        }

        private static void BindValue(BindingMemberInfo modelProperty, string stringValue, BindingContext context)
        {
            BindValue(modelProperty, stringValue, context, context.Model);
        }

        private static void BindValue(BindingMemberInfo modelProperty, string stringValue, BindingContext context, object targetInstance)
        {
            var destinationType = modelProperty.PropertyType;

            var typeConverter =
                context.TypeConverters.FirstOrDefault(c => c.CanConvertTo(destinationType, context));

            if (typeConverter != null)
            {
                try
                {
                    SetBindingMemberValue(modelProperty, targetInstance, typeConverter.Convert(stringValue, destinationType, context));
                }
                catch (Exception e)
                {
                    throw new PropertyBindingException(modelProperty.Name, stringValue, e);
                }
            }
            else if (destinationType == typeof(string))
            {
                SetBindingMemberValue(modelProperty, targetInstance, stringValue);
            }
        }

        private static void SetBindingMemberValue(BindingMemberInfo modelProperty, object model, object value)
        {
            // TODO - catch reflection exceptions?
            modelProperty.SetValue(model, value);
        }

        private static IEnumerable<BindingMemberInfo> GetBindingMembers(Type modelType, Type genericType, IEnumerable<string> blackList)
        {
            var blackListHash = new HashSet<string>(blackList, StringComparer.Ordinal);

            return BindingMemberInfo.Collect(genericType ?? modelType)
                .Where(member => !blackListHash.Contains(member.Name));
        }

        private static object CreateModel(Type modelType, Type genericType, object instance)
        {
            if (modelType.IsArray() || modelType.IsCollection() || modelType.IsEnumerable())
            {
                //make sure instance has a Add method. Otherwise call `.ToList`
                if (instance != null && modelType.IsInstanceOfType(instance))
                {
                    var addMethod = modelType.GetMethod("Add", BindingFlags.Public | BindingFlags.Instance);
                    if (addMethod != null)
                    {
                        return instance;
                    }
                    var genericMethod = ToListMethodInfo.MakeGenericMethod(genericType);
                    return genericMethod.Invoke(null, new[] { instance });
                }

                //else just make a list
                var listType = typeof(List<>).MakeGenericType(genericType);
                return Activator.CreateInstance(listType);
            }

            if (instance == null)
            {
                return Activator.CreateInstance(modelType, true);
            }

            return !modelType.IsInstanceOfType(instance) ?
                Activator.CreateInstance(modelType, true) :
                instance;
        }

        private static string GetValue(string propertyName, BindingContext context, int index = -1)
        {
            if (index != -1)
            {

                var indexindexes = context.RequestData.Keys.Select(IsMatch)
                                           .Where(i => i != -1)
                                           .OrderBy(i => i)
                                           .Distinct()
                                           .Select((k, i) => new KeyValuePair<int, int>(i, k))
                                           .ToDictionary(k => k.Key, v => v.Value);

                if (indexindexes.ContainsKey(index))
                {
                    var propertyValue =
                        context.RequestData.Where(c =>
                        {
                            var indexId = IsMatch(c.Key);
                            return c.Key.StartsWith(propertyName, StringComparison.OrdinalIgnoreCase) && indexId != -1 && indexId == indexindexes[index];
                        })
                        .Select(k => k.Value)
                        .FirstOrDefault();

                    return propertyValue ?? string.Empty;
                }

                return string.Empty;
            }
            return context.RequestData.ContainsKey(propertyName) ? context.RequestData[propertyName] : string.Empty;
        }

        private object DeserializeRequestBody(BindingContext context)
        {
            if (context.Context == null || context.Context.Request == null)
            {
                return null;
            }

            var contentType = GetRequestContentType(context.Context);

            if (string.IsNullOrEmpty(contentType))
            {
                return null;
            }

            var bodyDeserializer = this.bodyDeserializers.FirstOrDefault(b => b.CanDeserialize(contentType, context))
                ?? this.defaults.DefaultBodyDeserializers.FirstOrDefault(b => b.CanDeserialize(contentType, context));

            return bodyDeserializer != null
                ? bodyDeserializer.Deserialize(contentType, context.Context.Request.Body, context)
                : null;
        }

        private static string GetRequestContentType(NancyContext context)
        {
            if (context == null || context.Request == null)
            {
                return String.Empty;
            }

            var contentType =
                context.Request.Headers.ContentType;

            return (string.IsNullOrEmpty(contentType))
                ? string.Empty
                : contentType;
        }
    }
}
namespace Nancy.ModelBinding.DefaultBodyDeserializers
{
    using System.IO;
    using System.Reflection;
    using Nancy.Configuration;
    using Nancy.Json;
    using Nancy.Responses.Negotiation;

    /// <summary>
    /// Deserializes request bodies in JSON format
    /// </summary>
    public class JsonBodyDeserializer : IBodyDeserializer
    {
        private readonly MethodInfo deserializeMethod = typeof(JavaScriptSerializer).GetMethod("Deserialize", BindingFlags.Instance | BindingFlags.Public);
        private readonly JsonConfiguration configuration;

        /// <summary>
        /// Initializes a new instance of the <see cref="JsonBodyDeserializer"/>,
        /// with the provided <paramref name="environment"/>.
        /// </summary>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public JsonBodyDeserializer(INancyEnvironment environment)
        {
            this.configuration = environment.GetValue<JsonConfiguration>();
        }

        /// <summary>
        /// Whether the deserializer can deserialize the content type
        /// </summary>
        /// <param name="mediaRange">Content type to deserialize</param>
        /// <param name="context">Current <see cref="BindingContext"/>.</param>
        /// <returns>True if supported, false otherwise</returns>
        public bool CanDeserialize(MediaRange mediaRange, BindingContext context)
        {
            return Json.IsJsonContentType(mediaRange);
        }

        /// <summary>
        /// Deserialize the request body to a model
        /// </summary>
        /// <param name="mediaRange">Content type to deserialize</param>
        /// <param name="bodyStream">Request body stream</param>
        /// <param name="context">Current context</param>
        /// <returns>Model instance</returns>
        public object Deserialize(MediaRange mediaRange, Stream bodyStream, BindingContext context)
        {
            var serializer = new JavaScriptSerializer(this.configuration);

            serializer.RegisterConverters(this.configuration.Converters, this.configuration.PrimitiveConverters);

            bodyStream.Position = 0;
            string bodyText;
            using (var bodyReader = new StreamReader(bodyStream))
            {
                bodyText = bodyReader.ReadToEnd();
            }

            var genericDeserializeMethod = this.deserializeMethod.MakeGenericMethod(context.DestinationType);

            var deserializedObject = genericDeserializeMethod.Invoke(serializer, new object[] { bodyText });

            return deserializedObject;
        }
    }
}
namespace Nancy.ModelBinding.DefaultBodyDeserializers
{
    using System;
    using System.IO;
    using System.Xml.Serialization;
    using Nancy.Responses.Negotiation;

    /// <summary>
    /// Deserializes request bodies in XML format
    /// </summary>
    public class XmlBodyDeserializer : IBodyDeserializer
    {
        /// <summary>
        /// Whether the deserializer can deserialize the content type
        /// </summary>
        /// <param name="mediaRange">Content type to deserialize</param>
        /// <param name="context">Current <see cref="BindingContext"/>.</param>
        /// <returns>True if supported, false otherwise</returns>
        public bool CanDeserialize(MediaRange mediaRange, BindingContext context)
        {
            if (string.IsNullOrEmpty(mediaRange))
            {
                return false;
            }

            var contentMimeType = mediaRange.ToString().Split(';')[0];

            return contentMimeType.Equals("application/xml", StringComparison.OrdinalIgnoreCase) ||
                   contentMimeType.Equals("text/xml", StringComparison.OrdinalIgnoreCase) ||
                  (contentMimeType.StartsWith("application/vnd", StringComparison.OrdinalIgnoreCase) &&
                   contentMimeType.EndsWith("+xml", StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Deserialize the request body to a model
        /// </summary>
        /// <param name="mediaRange">Content type to deserialize</param>
        /// <param name="bodyStream">Request body stream</param>
        /// <param name="context">Current <see cref="BindingContext"/>.</param>
        /// <returns>Model instance</returns>
        public object Deserialize(MediaRange mediaRange, Stream bodyStream, BindingContext context)
        {
            bodyStream.Position = 0;
            var ser = new XmlSerializer(context.DestinationType);
            return ser.Deserialize(bodyStream);
        }
    }
}
namespace Nancy.ModelBinding.DefaultConverters
{
    using System;
    using System.Linq;
    using System.Reflection;

    using Nancy.Extensions;

    /// <summary>
    /// Converter for handling enumerable types
    /// </summary>
    public class CollectionConverter : ITypeConverter
    {
        private readonly MethodInfo enumerableCastMethod = typeof(Enumerable).GetMethod("Cast", BindingFlags.Public | BindingFlags.Static);
        private readonly MethodInfo enumerableToArrayMethod = typeof(Enumerable).GetMethod("ToArray", BindingFlags.Public | BindingFlags.Static);
        private readonly MethodInfo enumerableToListMethod = typeof(Enumerable).GetMethod("ToList", BindingFlags.Public | BindingFlags.Static);

        /// <summary>
        /// Whether the converter can convert to the destination type
        /// </summary>
        /// <param name="destinationType">Destination type</param>
        /// <param name="context">The current binding context</param>
        /// <returns>True if conversion supported, false otherwise</returns>
        public bool CanConvertTo(Type destinationType, BindingContext context)
        {
            return destinationType.IsCollection() || destinationType.IsEnumerable() || destinationType.IsArray();
        }

        /// <summary>
        /// Convert the string representation to the destination type
        /// </summary>
        /// <param name="input">Input string</param>
        /// <param name="destinationType">Destination type</param>
        /// <param name="context">Current context</param>
        /// <returns>Converted object of the destination type</returns>
        public object Convert(string input, Type destinationType, BindingContext context)
        {
            if (string.IsNullOrEmpty(input))
            {
                return null;
            }

            var items = input.Split(',');

            // Strategy, schmategy ;-)
            if (destinationType.IsCollection())
            {
                return this.ConvertCollection(items, destinationType, context);
            }

            if (destinationType.IsArray())
            {
                return this.ConvertArray(items, destinationType, context);
            }

            if (destinationType.IsEnumerable())
            {
                return this.ConvertEnumerable(items, destinationType, context);
            }

            return null;
        }

        private object ConvertCollection(string[] items, Type destinationType, BindingContext context)
        {
            var genericType = destinationType.GetGenericArguments().First();
            var returnCollection = Activator.CreateInstance(destinationType);

            var converter = context.TypeConverters.FirstOrDefault(c => c.CanConvertTo(genericType, context));
            if (converter == null)
            {
                return null;
            }

            var collectionAddMethod = destinationType.GetMethod("Add", BindingFlags.Public | BindingFlags.Instance);

            foreach (var item in items)
            {
                collectionAddMethod.Invoke(returnCollection, new[] { converter.Convert(item, genericType, context) });
            }

            return returnCollection;
        }

        private object ConvertArray(string[] items, Type destinationType, BindingContext context)
        {
            var elementType = destinationType.GetElementType();

            if (elementType == null)
            {
                return null;
            }

            var converter = context.TypeConverters.FirstOrDefault(c => c.CanConvertTo(elementType, context));

            if (converter == null)
            {
                return null;
            }

            var returnArray = items.Select(s => converter.Convert(s, elementType, context));

            var genericCastMethod = this.enumerableCastMethod.MakeGenericMethod(new[] { elementType });
            var generictoArrayMethod = this.enumerableToArrayMethod.MakeGenericMethod(new[] { elementType });

            var castArray = genericCastMethod.Invoke(null, new object[] { returnArray });

            return generictoArrayMethod.Invoke(null, new[] { castArray });
        }

        private object ConvertEnumerable(string[] items, Type destinationType, BindingContext context)
        {
            var genericType = destinationType.GetGenericArguments().First();

            var converter = context.TypeConverters.FirstOrDefault(c => c.CanConvertTo(genericType, context));

            if (converter == null)
            {
                return null;
            }

            var returnArray = items.Select(s => converter.Convert(s, genericType, context));

            // Use ToList rather than AsEnumerable to make sure the collection
            // is materialised and converters are called as appropriate.
            var genericCastMethod = this.enumerableCastMethod.MakeGenericMethod(new[] { genericType });
            var genericToListMethod = this.enumerableToListMethod.MakeGenericMethod(new[] { genericType });

            var castArray = genericCastMethod.Invoke(null, new object[] { returnArray });

            return genericToListMethod.Invoke(null, new[] { castArray });
        }
    }
}
namespace Nancy.ModelBinding.DefaultConverters
{
    using System;
    using System.ComponentModel;

    /// <summary>
    /// A fallback converter that uses TypeDescriptor.GetConverter to try
    /// and convert the value.
    /// </summary>
    public class FallbackConverter : ITypeConverter
    {
        /// <summary>
        /// Whether the converter can convert to the destination type
        /// </summary>
        /// <param name="destinationType">Destination type</param>
        /// <param name="context">The current binding context</param>
        /// <returns>True if conversion supported, false otherwise</returns>
        public bool CanConvertTo(Type destinationType, BindingContext context)
        {
            return true;
        }

        /// <summary>
        /// Convert the string representation to the destination type
        /// </summary>
        /// <param name="input">Input string</param>
        /// <param name="destinationType">Destination type</param>
        /// <param name="context">Current context</param>
        /// <returns>Converted object of the destination type</returns>
        public object Convert(string input, Type destinationType, BindingContext context)
        {
            var converter = TypeDescriptor.GetConverter(destinationType);

            if (converter == null || !converter.CanConvertFrom(typeof(string)))
            {
                return null;
            }

            try
            {
                return converter.ConvertFrom(input);
            }
            catch (FormatException)
            {
                if (destinationType == typeof(bool) && converter.GetType() == typeof(BooleanConverter) && "on".Equals(input, StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
                return null;
            }
        }
    }
}
namespace Nancy.ModelBinding
{
    using System.Collections.Concurrent;

    /// <summary>
    /// Default field name converter
    /// Converts camel case to pascal case
    /// </summary>
    public class DefaultFieldNameConverter : IFieldNameConverter
    {
        private readonly ConcurrentDictionary<string, string> cache;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultFieldNameConverter"/> class.
        /// </summary>
        public DefaultFieldNameConverter()
        {
            this.cache = new ConcurrentDictionary<string, string>();
        }

        /// <summary>
        /// Converts a field name to a property name
        /// </summary>
        /// <param name="fieldName">Field name</param>
        /// <returns>Property name</returns>
        public string Convert(string fieldName)
        {
            if (string.IsNullOrWhiteSpace(fieldName))
            {
                return fieldName;
            }

            return this.cache.GetOrAdd(fieldName, name =>
            {
                if (name.Length > 1)
                {
                    return char.ToUpperInvariant(name[0]) + name.Substring(1);
                }

                return name.ToUpperInvariant();
            });
        }
    }
}
namespace Nancy.ModelBinding
{
    using System;
    using System.Dynamic;

    /// <summary>
    /// Provides wiring up of a model binder when cast to a destination type
    /// </summary>
    public class DynamicModelBinderAdapter : DynamicObject
    {
        private readonly IModelBinderLocator locator;
        private readonly NancyContext context;
        private readonly object instance;
        private readonly BindingConfig configuration;
        private readonly string[] blacklistedProperties;

        /// <summary>
        /// Initializes a new instance of the <see cref="DynamicModelBinderAdapter"/> class.
        /// </summary>
        /// <param name="locator">Model binder locator</param>
        /// <param name="context">Nancy context</param>
        /// <param name="instance">Optional existing instance, or null</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperties">Blacklisted property names</param>
        public DynamicModelBinderAdapter(IModelBinderLocator locator, NancyContext context, object instance, BindingConfig configuration, params string[] blacklistedProperties)
        {
            if (locator == null)
            {
                throw new ArgumentNullException("locator");
            }

            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            if (configuration == null)
            {
                throw new ArgumentNullException("configuration");
            }

            this.locator = locator;
            this.context = context;
            this.instance = instance;
            this.configuration = configuration;
            this.blacklistedProperties = blacklistedProperties;
        }

        /// <summary>
        /// Provides implementation for type conversion operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations that convert an object from one type to another.
        /// </summary>
        /// <returns>
        /// true if the operation is successful; otherwise, false. If this method returns false, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)
        /// </returns>
        /// <param name="binder">Provides information about the conversion operation. The binder.Type property provides the type to which the object must be converted. For example, for the statement (String)sampleObject in C# (CType(sampleObject, Type) in Visual Basic), where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, binder.Type returns the <see cref="T:System.String"/> type. The binder.Explicit property provides information about the kind of conversion that occurs. It returns true for explicit conversion and false for implicit conversion.</param><param name="result">The result of the type conversion operation.</param>
        public override bool TryConvert(ConvertBinder binder, out object result)
        {
            var instanceType = instance == null ? binder.Type : this.instance.GetType();

            var modelBinder = this.locator.GetBinderForType(instanceType, this.context);

            if (modelBinder == null)
            {
                throw new ModelBindingException(instanceType);
            }

            result = modelBinder.Bind(this.context, instanceType, this.instance, this.configuration, this.blacklistedProperties);

            return result != null || base.TryConvert(binder, out result);
        }
    }
}
namespace Nancy.ModelBinding
{
    using System.IO;
    using Nancy.Responses.Negotiation;

    /// <summary>
    /// Provides a way to deserialize the contents of a request
    /// into a bound model.
    /// </summary>
    public interface IBodyDeserializer
    {
        /// <summary>
        /// Whether the deserializer can deserialize the content type
        /// </summary>
        /// <param name="mediaRange">Content type to deserialize</param>
        /// <param name="context">Current <see cref="BindingContext"/>.</param>
        /// <returns>True if supported, false otherwise</returns>
        bool CanDeserialize(MediaRange mediaRange, BindingContext context);

        /// <summary>
        /// Deserialize the request body to a model
        /// </summary>
        /// <param name="mediaRange">Content type to deserialize</param>
        /// <param name="bodyStream">Request body stream</param>
        /// <param name="context">Current <see cref="BindingContext"/>.</param>
        /// <returns>Model instance</returns>
        object Deserialize(MediaRange mediaRange, Stream bodyStream, BindingContext context);
    }
}
namespace Nancy.ModelBinding
{
    using System;

    /// <summary>
    /// Binds incoming request data to a model type
    /// </summary>
    public interface IBinder
    {
        /// <summary>
        /// Bind to the given model type
        /// </summary>
        /// <param name="context">Current context</param>
        /// <param name="modelType">Model type to bind to</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blackList">Blacklisted property names</param>
        /// <param name="instance">Existing instance of the object</param>
        /// <returns>Bound model</returns>
        object Bind(NancyContext context, Type modelType, object instance, BindingConfig configuration, params string[] blackList);
    }
}
namespace Nancy.ModelBinding
{
    /// <summary>
    /// Provides the capability to supply a convention to
    /// convert form field names to property names if required.
    /// </summary>
    public interface IFieldNameConverter
    {
        /// <summary>
        /// Converts a field name to a property name
        /// </summary>
        /// <param name="fieldName">Field name</param>
        /// <returns>Property name</returns>
        string Convert(string fieldName);
    }
}
namespace Nancy.ModelBinding
{
    using System;

    /// <summary>
    /// Provides a way to bind an incoming request, via the context, to a model type
    /// </summary>
    public interface IModelBinder : IBinder
    {
        /// <summary>
        /// Whether the binder can bind to the given model type
        /// </summary>
        /// <param name="modelType">Required model type</param>
        /// <returns>True if binding is possible, false otherwise</returns>
        bool CanBind(Type modelType);
    }
}
namespace Nancy.ModelBinding
{
    using System;

    /// <summary>
    /// Locates model binders for a particular model
    /// </summary>
    public interface IModelBinderLocator
    {
        /// <summary>
        /// Gets a binder for the given type
        /// </summary>
        /// <param name="modelType">Destination type to bind to</param>
        /// <param name="context">The <see cref="NancyContext"/> instance of the current request.</param>
        /// <returns>IModelBinder instance or null if none found</returns>
        IBinder GetBinderForType(Type modelType, NancyContext context);
    }
}
namespace Nancy.ModelBinding
{
    using System;

    /// <summary>
    /// Provides a way to convert from the incoming string representation
    /// of a type to the type itself.
    /// </summary>
    public interface ITypeConverter
    {
        /// <summary>
        /// Whether the converter can convert to the destination type
        /// </summary>
        /// <param name="destinationType">Destination type</param>
        /// <param name="context">The current binding context</param>
        /// <returns>True if conversion supported, false otherwise</returns>
        bool CanConvertTo(Type destinationType, BindingContext context);

        /// <summary>
        /// Convert the string representation to the destination type
        /// </summary>
        /// <param name="input">Input string</param>
        /// <param name="destinationType">Destination type</param>
        /// <param name="context">Current context</param>
        /// <returns>Converted object of the destination type</returns>
        object Convert(string input, Type destinationType, BindingContext context);
    }
}
namespace Nancy.ModelBinding
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Locates model binders for a particular model
    /// </summary>
    public class DefaultModelBinderLocator : IModelBinderLocator
    {
        /// <summary>
        /// Available model binders
        /// </summary>
        private readonly IReadOnlyCollection<IModelBinder> binders;

        /// <summary>
        /// Default model binder to fall back on
        /// </summary>
        private readonly IBinder fallbackBinder;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultModelBinderLocator"/> class.
        /// </summary>
        /// <param name="binders">Available model binders</param>
        /// <param name="fallbackBinder">Fallback binder</param>
        public DefaultModelBinderLocator(IEnumerable<IModelBinder> binders, IBinder fallbackBinder)
        {
            this.fallbackBinder = fallbackBinder;

            if (binders != null)
            {
                this.binders = binders.ToArray();
            }
        }

        /// <summary>
        /// Gets a binder for the given type
        /// </summary>
        /// <param name="modelType">Destination type to bind to</param>
        /// <param name="context">The <see cref="NancyContext"/> instance of the current request.</param>
        /// <returns>IModelBinder instance or null if none found</returns>
        public IBinder GetBinderForType(Type modelType, NancyContext context)
        {
            if (this.binders == null)
            {
                return this.fallbackBinder;
            }

            foreach (var modelBinder in this.binders)
            {
                if (modelBinder.CanBind(modelType))
                {
                    return modelBinder;
                }
            }

            return this.fallbackBinder;
        }
    }
}
namespace Nancy.ModelBinding
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Represents an exception when attempting to bind to a model
    /// </summary>
    public class ModelBindingException : Exception
    {
        private const string ExceptionMessage = "Unable to bind to type: {0}";

        /// <summary>
        /// Gets all failures
        /// </summary>
        public virtual IEnumerable<PropertyBindingException> PropertyBindingExceptions { get; private set; }

        /// <summary>
        /// Gets the model type, which caused the exception
        /// </summary>
        public virtual Type BoundType { get; private set; }

        /// <summary>
        /// Initializes a new instance of the ModelBindingException class with a specified model type,
        /// property name and the original exception, which caused the problem
        /// </summary>
        /// <param name="boundType">the model type to bind to</param>
        /// <param name="propertyBindingExceptions">the original exceptions, thrown while binding the property</param>
        /// <param name="innerException">The inner exception.</param>
        public ModelBindingException(Type boundType, IEnumerable<PropertyBindingException> propertyBindingExceptions = null, Exception innerException = null)
            : base(string.Format(ExceptionMessage, boundType), innerException)
        {
            if (boundType == null)
            {
                throw new ArgumentNullException("boundType");
            }
            this.PropertyBindingExceptions = propertyBindingExceptions ?? new List<PropertyBindingException>();
            this.BoundType = boundType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelBindingException" /> class with serialized data.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        protected ModelBindingException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}
namespace Nancy.ModelBinding
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Expressions;

    using Nancy.Validation;

    public static class ModuleExtensions
    {
        private static readonly string[] NoBlacklistedProperties = ArrayCache.Empty<string>();

        /// <summary>
        /// Parses an array of expressions like <code>t =&gt; t.Property</code> to a list of strings containing the property names;
        /// </summary>
        /// <typeparam name="T">Type of the model</typeparam>
        /// <param name="expressions">Expressions that tell which property should be ignored</param>
        /// <returns>Array of strings containing the names of the properties.</returns>
        private static string[] ParseBlacklistedPropertiesExpressionTree<T>(this IEnumerable<Expression<Func<T, object>>> expressions)
        {
            return expressions.Select(p => p.GetTargetMemberInfo().Name).ToArray();
        }

        /// <summary>
        /// Bind the incoming request to a model
        /// </summary>
        /// <param name="module">Current module</param>
        /// <param name="blacklistedProperties">Property names to blacklist from binding</param>
        /// <returns>Model adapter - cast to a model type to bind it</returns>
        public static dynamic Bind(this INancyModule module, params string[] blacklistedProperties)
        {
            return module.Bind(BindingConfig.Default, blacklistedProperties);
        }

        /// <summary>
        /// Bind the incoming request to a model
        /// </summary>
        /// <param name="module">Current module</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperties">Property names to blacklist from binding</param>
        /// <returns>Model adapter - cast to a model type to bind it</returns>
        public static dynamic Bind(this INancyModule module, BindingConfig configuration, params string[] blacklistedProperties)
        {
            return new DynamicModelBinderAdapter(module.ModelBinderLocator, module.Context, null, configuration, blacklistedProperties);
        }

        /// <summary>
        /// Bind the incoming request to a model
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <returns>Bound model instance</returns>
        public static TModel Bind<TModel>(this INancyModule module)
        {
            return module.Bind();
        }

        /// <summary>
        /// Bind the incoming request to a model
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="blacklistedProperties">Property names to blacklist from binding</param>
        /// <returns>Bound model instance</returns>
        public static TModel Bind<TModel>(this INancyModule module, params string[] blacklistedProperties)
        {
            return module.Bind(blacklistedProperties);
        }

        /// <summary>
        /// Bind the incoming request to a model
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="blacklistedProperties">Expressions that tell which property should be ignored</param>
        /// <example>this.Bind&lt;Person&gt;(p =&gt; p.Name, p =&gt; p.Age)</example>
        /// <returns>Bound model instance</returns>
        public static TModel Bind<TModel>(this INancyModule module, params Expression<Func<TModel, object>>[] blacklistedProperties)
        {
            return module.Bind<TModel>(blacklistedProperties.ParseBlacklistedPropertiesExpressionTree());
        }

        /// <summary>
        /// Bind the incoming request to a model and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="blacklistedProperties">Property names to blacklist from binding</param>
        /// <returns>Bound model instance</returns>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindAndValidate<TModel>(this INancyModule module, params string[] blacklistedProperties)
        {
            var model = module.Bind<TModel>(blacklistedProperties);
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to a model and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="blacklistedProperties">Expressions that tell which property should be ignored</param>
        /// <example>this.Bind&lt;Person&gt;(p =&gt; p.Name, p =&gt; p.Age)</example>
        /// <returns>Bound model instance</returns>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindAndValidate<TModel>(this INancyModule module, params Expression<Func<TModel, object>>[] blacklistedProperties)
        {
            var model = module.Bind<TModel>(blacklistedProperties.ParseBlacklistedPropertiesExpressionTree());
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to a model and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <returns>Bound model instance</returns>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindAndValidate<TModel>(this INancyModule module)
        {
            var model = module.Bind<TModel>(NoBlacklistedProperties);
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to a model
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <returns>Bound model instance</returns>
        public static TModel Bind<TModel>(this INancyModule module, BindingConfig configuration)
        {
            return module.Bind(configuration);
        }

        /// <summary>
        /// Bind the incoming request to a model
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperties">Property names to blacklist from binding</param>
        /// <returns>Bound model instance</returns>
        public static TModel Bind<TModel>(this INancyModule module, BindingConfig configuration, params string[] blacklistedProperties)
        {
            return module.Bind(configuration, blacklistedProperties);
        }

        /// <summary>
        /// Bind the incoming request to a model
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperty">Expressions that tell which property should be ignored</param>
        /// <example>this.Bind&lt;Person&gt;(p =&gt; p.Name, p =&gt; p.Age)</example>
        /// <returns>Bound model instance</returns>
        public static TModel Bind<TModel>(this INancyModule module, BindingConfig configuration, Expression<Func<TModel, object>> blacklistedProperty)
        {
            return module.Bind(configuration, new[] { blacklistedProperty }.ParseBlacklistedPropertiesExpressionTree());
        }

        /// <summary>
        /// Bind the incoming request to a model
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperties">Expressions that tell which property should be ignored</param>
        /// <example>this.Bind&lt;Person&gt;(p =&gt; p.Name, p =&gt; p.Age)</example>
        /// <returns>Bound model instance</returns>
        public static TModel Bind<TModel>(this INancyModule module, BindingConfig configuration, params Expression<Func<TModel, object>>[] blacklistedProperties)
        {
            return module.Bind(configuration, blacklistedProperties.ParseBlacklistedPropertiesExpressionTree());
        }

        /// <summary>
        /// Bind the incoming request to a model and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperties">Property names to blacklist from binding</param>
        /// <returns>Bound model instance</returns>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindAndValidate<TModel>(this INancyModule module, BindingConfig configuration, params string[] blacklistedProperties)
        {
            var model = module.Bind<TModel>(configuration, blacklistedProperties);
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to a model and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperties">Expressions that tell which property should be ignored</param>
        /// <example>this.Bind&lt;Person&gt;(p =&gt; p.Name, p =&gt; p.Age)</example>
        /// <returns>Bound model instance</returns>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindAndValidate<TModel>(this INancyModule module, BindingConfig configuration, params Expression<Func<TModel, object>>[] blacklistedProperties)
        {
            var model = module.Bind<TModel>(configuration, blacklistedProperties.ParseBlacklistedPropertiesExpressionTree());
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to a model and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <returns>Bound model instance</returns>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindAndValidate<TModel>(this INancyModule module, BindingConfig configuration)
        {
            var model = module.Bind<TModel>(configuration, NoBlacklistedProperties);
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to an existing instance
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <param name="blacklistedProperties">Property names to blacklist from binding</param>
        public static TModel BindTo<TModel>(this INancyModule module, TModel instance, params string[] blacklistedProperties)
        {
            return module.BindTo(instance, BindingConfig.NoOverwrite, blacklistedProperties);
        }

        /// <summary>
        /// Bind the incoming request to an existing instance
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <param name="blacklistedProperties">Expressions that tell which property should be ignored</param>
        /// <example>this.Bind&lt;Person&gt;(p =&gt; p.Name, p =&gt; p.Age)</example>
        public static TModel BindTo<TModel>(this INancyModule module, TModel instance, params Expression<Func<TModel, object>>[] blacklistedProperties)
        {
            return module.BindTo(instance, BindingConfig.NoOverwrite, blacklistedProperties.ParseBlacklistedPropertiesExpressionTree());
        }

        /// <summary>
        /// Bind the incoming request to an existing instance
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        public static TModel BindTo<TModel>(this INancyModule module, TModel instance)
        {
            return module.BindTo(instance, BindingConfig.NoOverwrite, NoBlacklistedProperties);
        }

        /// <summary>
        /// Bind the incoming request to an existing instance and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <param name="blacklistedProperties">Property names to blacklist from binding</param>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindToAndValidate<TModel>(this INancyModule module, TModel instance, params string[] blacklistedProperties)
        {
            var model = module.BindTo(instance, blacklistedProperties);
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to an existing instance and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <param name="blacklistedProperties">Expressions that tell which property should be ignored</param>
        /// <example>this.Bind&lt;Person&gt;(p =&gt; p.Name, p =&gt; p.Age)</example>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindToAndValidate<TModel>(this INancyModule module, TModel instance, params Expression<Func<TModel, object>>[] blacklistedProperties)
        {
            var model = module.BindTo(instance, blacklistedProperties.ParseBlacklistedPropertiesExpressionTree());
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to an existing instance and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindToAndValidate<TModel>(this INancyModule module, TModel instance)
        {
            var model = module.BindTo(instance, NoBlacklistedProperties);
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to an existing instance
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperties">Property names to blacklist from binding</param>
        public static TModel BindTo<TModel>(this INancyModule module, TModel instance, BindingConfig configuration, params string[] blacklistedProperties)
        {
            dynamic adapter =
                new DynamicModelBinderAdapter(module.ModelBinderLocator, module.Context, instance, configuration, blacklistedProperties);

            return adapter;
        }

        /// <summary>
        /// Bind the incoming request to an existing instance
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperties">Expressions that tell which property should be ignored</param>
        /// <example>this.Bind&lt;Person&gt;(p =&gt; p.Name, p =&gt; p.Age)</example>
        public static TModel BindTo<TModel>(this INancyModule module, TModel instance, BindingConfig configuration, params Expression<Func<TModel, object>>[] blacklistedProperties)
        {
            return module.BindTo(instance, configuration, blacklistedProperties.ParseBlacklistedPropertiesExpressionTree());
        }

        /// <summary>
        /// Bind the incoming request to an existing instance
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        public static TModel BindTo<TModel>(this INancyModule module, TModel instance, BindingConfig configuration)
        {
            return module.BindTo(instance, configuration, NoBlacklistedProperties);
        }

        /// <summary>
        /// Bind the incoming request to an existing instance and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperties">Property names to blacklist from binding</param>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindToAndValidate<TModel>(this INancyModule module, TModel instance, BindingConfig configuration, params string[] blacklistedProperties)
        {
            var model = module.BindTo(instance, configuration, blacklistedProperties);
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to an existing instance and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <param name="blacklistedProperties">Expressions that tell which property should be ignored</param>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        /// <example>this.BindToAndValidate(person, config, p =&gt; p.Name, p =&gt; p.Age)</example>
        public static TModel BindToAndValidate<TModel>(this INancyModule module, TModel instance, BindingConfig configuration, params Expression<Func<TModel, object>>[] blacklistedProperties)
        {
            var model = module.BindTo(instance, configuration, blacklistedProperties.ParseBlacklistedPropertiesExpressionTree());
            module.Validate(model);
            return model;
        }

        /// <summary>
        /// Bind the incoming request to an existing instance and validate
        /// </summary>
        /// <typeparam name="TModel">Model type</typeparam>
        /// <param name="module">Current module</param>
        /// <param name="instance">The class instance to bind properties to</param>
        /// <param name="configuration">The <see cref="BindingConfig"/> that should be applied during binding.</param>
        /// <remarks><see cref="ModelValidationResult"/> is stored in NancyModule.ModelValidationResult and NancyContext.ModelValidationResult.</remarks>
        public static TModel BindToAndValidate<TModel>(this INancyModule module, TModel instance, BindingConfig configuration)
        {
            var model = module.BindTo(instance, configuration, NoBlacklistedProperties);
            module.Validate(model);
            return model;
        }
    }
}

namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;
    using System.Security.Claims;
    using Nancy.Configuration;
    using Nancy.Diagnostics;
    using Nancy.Responses.Negotiation;
    using Nancy.Routing;
    using Nancy.Validation;

    /// <summary>
    /// Nancy context.
    /// </summary>
    public sealed class NancyContext : IDisposable
    {
        private Request request;

        private ModelValidationResult modelValidationResult;

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyContext"/> class.
        /// </summary>
        public NancyContext()
        {
            this.Items = new Dictionary<string, object>();
            this.Trace = new DefaultRequestTrace();
            this.ViewBag = new DynamicDictionary();
            this.NegotiationContext = new NegotiationContext();

            // TODO - potentially additional logic to lock to ip etc?
            this.ControlPanelEnabled = true;
        }

        /// <summary>
        /// Gets the dictionary for storage of per-request items. Disposable items will be disposed when the context is.
        /// </summary>
        public IDictionary<string, object> Items { get; private set; }

        /// <summary>
        /// Gets or sets the resolved route
        /// </summary>
        public Route ResolvedRoute { get; set; }

        /// <summary>
        /// Gets or sets the parameters for the resolved route
        /// </summary>
        public dynamic Parameters { get; set; }

        /// <summary>
        /// Gets or sets the incoming request
        /// </summary>
        public Request Request
        {
            get
            {
                return this.request;
            }

            set
            {
                this.request = value;
                this.Trace.RequestData = value;
            }
        }

        /// <summary>
        /// Gets or sets the outgoing response
        /// </summary>
        public Response Response { get; set; }

        /// <summary>
        /// Gets or sets the current user
        /// </summary>
        public ClaimsPrincipal CurrentUser { get; set; }

        /// <summary>
        /// Diagnostic request tracing
        /// </summary>
        public IRequestTrace Trace { get; set; }

        /// <summary>
        /// Gets a value indicating whether control panel access is enabled for this request
        /// </summary>
        public bool ControlPanelEnabled { get; private set; }

        /// <summary>
        /// Non-model specific data for rendering in the response
        /// </summary>
        public dynamic ViewBag { get; private set; }

        /// <summary>
        /// Gets or sets the model validation result.
        /// </summary>
        public ModelValidationResult ModelValidationResult
        {
            get { return this.modelValidationResult ?? (this.modelValidationResult = new ModelValidationResult()); }
            set { this.modelValidationResult = value; }
        }

        /// <summary>
        /// Gets or sets the context's culture
        /// </summary>
        public CultureInfo Culture { get; set; }

        /// <summary>
        /// Context of content negotiation (if relevant)
        /// </summary>
        public NegotiationContext NegotiationContext { get; set; }

        /// <summary>
        /// Gets or sets the dynamic object used to locate text resources.
        /// </summary>
        public dynamic Text { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <value>An <see cref="INancyEnvironment"/> instance.</value>
        public INancyEnvironment Environment { get; set; }

        /// <summary>
        /// Disposes any disposable items in the <see cref="Items"/> dictionary.
        /// </summary>
        public void Dispose()
        {
            foreach (var disposableItem in this.Items.Values.OfType<IDisposable>())
            {
                disposableItem.Dispose();
            }

            this.Items.Clear();

            if (this.request != null)
            {
                ((IDisposable)this.request).Dispose();
            }

            if (this.Response != null)
            {
                this.Response.Dispose();
            }
        }
    }
}
namespace Nancy
{
    using System;
    using System.Threading;
    using System.Threading.Tasks;
    using Nancy.Helpers;

    public class AfterPipeline : AsyncNamedPipelineBase<Func<NancyContext, CancellationToken, Task>, Action<NancyContext>>
    {
        private static readonly Task completeTask = TaskHelpers.CompletedTask;

        public AfterPipeline()
        {
        }

        public AfterPipeline(int capacity)
            : base(capacity)
        {
        }

        public static implicit operator Func<NancyContext, CancellationToken, Task>(AfterPipeline pipeline)
        {
            return pipeline.Invoke;
        }

        public static implicit operator AfterPipeline(Func<NancyContext, CancellationToken, Task> func)
        {
            var pipeline = new AfterPipeline();
            pipeline.AddItemToEndOfPipeline(func);
            return pipeline;
        }

        public static AfterPipeline operator +(AfterPipeline pipeline, Func<NancyContext, CancellationToken, Task> func)
        {
            pipeline.AddItemToEndOfPipeline(func);
            return pipeline;
        }

        public static AfterPipeline operator +(AfterPipeline pipeline, Action<NancyContext> action)
        {
            pipeline.AddItemToEndOfPipeline(action);
            return pipeline;
        }

        public static AfterPipeline operator +(AfterPipeline pipelineToAddTo, AfterPipeline pipelineToAdd)
        {
            foreach (var pipelineItem in pipelineToAdd.PipelineItems)
            {
                pipelineToAddTo.AddItemToEndOfPipeline(pipelineItem);
            }

            return pipelineToAddTo;
        }

        public async Task Invoke(NancyContext context, CancellationToken cancellationToken)
        {
            foreach (var pipelineDelegate in this.PipelineDelegates)
            {
                await pipelineDelegate.Invoke(context, cancellationToken).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Wraps a sync delegate into it's async form
        /// </summary>
        /// <param name="pipelineItem">Sync pipeline item instance</param>
        /// <returns>Async pipeline item instance</returns>
        protected override PipelineItem<Func<NancyContext, CancellationToken, Task>> Wrap(PipelineItem<Action<NancyContext>> pipelineItem)
        {
            var syncDelegate = pipelineItem.Delegate;
            Func<NancyContext, CancellationToken, Task> asyncDelegate = (ctx, ct) =>
            {
                try
                {
                    syncDelegate.Invoke(ctx);
                    return completeTask;
                }
                catch (Exception e)
                {
                    var tcs = new TaskCompletionSource<object>();
                    tcs.SetException(e);
                    return tcs.Task;
                }
            };
            return new PipelineItem<Func<NancyContext, CancellationToken, Task>>(pipelineItem.Name, asyncDelegate);
        }
    }
}
namespace Nancy
{
    using System;
    using System.Threading;
    using System.Threading.Tasks;

    public class BeforePipeline : AsyncNamedPipelineBase<Func<NancyContext, CancellationToken, Task<Response>>, Func<NancyContext, Response>>
    {
        public BeforePipeline()
        {
        }

        public BeforePipeline(int capacity)
            : base(capacity)
        {
        }

        public static implicit operator Func<NancyContext, CancellationToken, Task<Response>>(BeforePipeline pipeline)
        {
            return pipeline.Invoke;
        }

        public static implicit operator BeforePipeline(Func<NancyContext, CancellationToken, Task<Response>> func)
        {
            var pipeline = new BeforePipeline();
            pipeline.AddItemToEndOfPipeline(func);
            return pipeline;
        }

        public static BeforePipeline operator +(BeforePipeline pipeline, Func<NancyContext, CancellationToken, Task<Response>> func)
        {
            pipeline.AddItemToEndOfPipeline(func);
            return pipeline;
        }

        public static BeforePipeline operator +(BeforePipeline pipeline, Func<NancyContext, Response> action)
        {
            pipeline.AddItemToEndOfPipeline(action);
            return pipeline;
        }

        public static BeforePipeline operator +(BeforePipeline pipelineToAddTo, BeforePipeline pipelineToAdd)
        {
            foreach (var pipelineItem in pipelineToAdd.PipelineItems)
            {
                pipelineToAddTo.AddItemToEndOfPipeline(pipelineItem);
            }

            return pipelineToAddTo;
        }

        public async Task<Response> Invoke(NancyContext context, CancellationToken cancellationToken)
        {
            foreach (var pipelineDelegate in this.PipelineDelegates)
            {
                var response = await pipelineDelegate.Invoke(context, cancellationToken).ConfigureAwait(false);
                if (response != null)
                {
                    return response;
                }
            }

            return null;
        }

        /// <summary>
        /// Wraps a sync delegate into it's async form
        /// </summary>
        /// <param name="pipelineItem">Sync pipeline item instance</param>
        /// <returns>Async pipeline item instance</returns>
        protected override PipelineItem<Func<NancyContext, CancellationToken, Task<Response>>> Wrap(PipelineItem<Func<NancyContext, Response>> pipelineItem)
        {
            var syncDelegate = pipelineItem.Delegate;
            Func<NancyContext, CancellationToken, Task<Response>> asyncDelegate = (ctx, ct) =>
            {
                var tcs = new TaskCompletionSource<Response>();
                try
                {
                    var result = syncDelegate.Invoke(ctx);
                    tcs.SetResult(result);
                }
                catch (Exception e)
                {
                    tcs.SetException(e);
                }
                return tcs.Task;
            };
            return new PipelineItem<Func<NancyContext, CancellationToken, Task<Response>>>(pipelineItem.Name, asyncDelegate);
        }
    }
}
namespace Nancy
{
    using Nancy.Configuration;

    /// <summary>
    /// The default implementation of the <see cref="IResponseFormatter"/> interface.
    /// </summary>
    public class DefaultResponseFormatter : IResponseFormatter
    {
        private readonly IRootPathProvider rootPathProvider;
        private readonly NancyContext context;
        private readonly ISerializerFactory serializerFactory;
        private readonly INancyEnvironment environment;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultResponseFormatter"/> class.
        /// </summary>
        /// <param name="rootPathProvider">The <see cref="IRootPathProvider"/> that should be used by the instance.</param>
        /// <param name="context">The <see cref="NancyContext"/> that should be used by the instance.</param>
        /// <param name="serializerFactory">An <see cref="ISerializerFactory" /> instance"/>.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public DefaultResponseFormatter(IRootPathProvider rootPathProvider, NancyContext context, ISerializerFactory serializerFactory, INancyEnvironment environment)
        {
            this.rootPathProvider = rootPathProvider;
            this.context = context;
            this.serializerFactory = serializerFactory;
            this.environment = environment;
        }

        /// <summary>
        /// Gets all <see cref="ISerializerFactory"/> factory.
        /// </summary>
        public ISerializerFactory SerializerFactory
        {
            get { return this.serializerFactory; }
        }

        /// <summary>
        /// Gets the context for which the response is being formatted.
        /// </summary>
        /// <value>A <see cref="NancyContext"/> instance.</value>
        public NancyContext Context
        {
            get { return this.context; }
        }

        /// <summary>
        /// Gets the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <value>An <see cref="INancyEnvironment"/> instance.</value>
        public INancyEnvironment Environment
        {
            get { return this.environment; }
        }

        /// <summary>
        /// Gets the root path of the application.
        /// </summary>
        /// <value>A <see cref="string"/> containing the root path.</value>
        public string RootPath
        {
            get { return this.rootPathProvider.GetRootPath(); }
        }
    }
}
namespace Nancy.IO
{
    using System;
    using System.IO;
    using System.Threading.Tasks;

    using Nancy.Extensions;

    /// <summary>
    /// A <see cref="Stream"/> decorator that can handle moving the stream out from memory and on to disk when the contents reaches a certain length.
    /// </summary>
    public class RequestStream : Stream
    {
        public static long DEFAULT_SWITCHOVER_THRESHOLD = 81920;

        private bool disableStreamSwitching;
        private readonly long thresholdLength;
        private bool isSafeToDisposeStream;
        private Stream stream;

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestStream"/> class.
        /// </summary>
        /// <param name="expectedLength">The expected length of the contents in the stream.</param>
        /// <param name="thresholdLength">The content length that will trigger the stream to be moved out of memory.</param>
        /// <param name="disableStreamSwitching">if set to <see langword="true"/> the stream will never explicitly be moved to disk.</param>
        public RequestStream(long expectedLength, long thresholdLength, bool disableStreamSwitching)
            : this(null, expectedLength, thresholdLength, disableStreamSwitching)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestStream"/> class.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> that should be handled by the request stream</param>
        /// <param name="expectedLength">The expected length of the contents in the stream.</param>
        /// <param name="disableStreamSwitching">if set to <see langword="true"/> the stream will never explicitly be moved to disk.</param>
        public RequestStream(Stream stream, long expectedLength, bool disableStreamSwitching)
            : this(stream, expectedLength, DEFAULT_SWITCHOVER_THRESHOLD, disableStreamSwitching)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestStream"/> class.
        /// </summary>
        /// <param name="expectedLength">The expected length of the contents in the stream.</param>
        /// <param name="disableStreamSwitching">if set to <see langword="true"/> the stream will never explicitly be moved to disk.</param>
        public RequestStream(long expectedLength, bool disableStreamSwitching)
            : this(null, expectedLength, DEFAULT_SWITCHOVER_THRESHOLD, disableStreamSwitching)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestStream"/> class.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> that should be handled by the request stream</param>
        /// <param name="expectedLength">The expected length of the contents in the stream.</param>
        /// <param name="thresholdLength">The content length that will trigger the stream to be moved out of memory.</param>
        /// <param name="disableStreamSwitching">if set to <see langword="true"/> the stream will never explicitly be moved to disk.</param>
        public RequestStream(Stream stream, long expectedLength, long thresholdLength, bool disableStreamSwitching)
        {
            this.thresholdLength = thresholdLength;
            this.disableStreamSwitching = disableStreamSwitching;
            this.stream = stream ?? this.CreateDefaultMemoryStream(expectedLength);

            ThrowExceptionIfCtorParametersWereInvalid(this.stream, expectedLength, this.thresholdLength);

            if (!this.MoveStreamOutOfMemoryIfExpectedLengthExceedSwitchLength(expectedLength))
            {
                this.MoveStreamOutOfMemoryIfContentsLengthExceedThresholdAndSwitchingIsEnabled();
            }

            if (!this.stream.CanSeek)
            {
                var task =
                    MoveToWritableStream();

                task.Wait();

                if (task.IsFaulted)
                {
                    throw new InvalidOperationException("Unable to copy stream", task.Exception);
                }
            }

            this.stream.Position = 0;
        }

        private Task MoveToWritableStream()
        {
            var sourceStream = this.stream;
            this.stream = new MemoryStream(StreamExtensions.BufferSize);

            return sourceStream.CopyToAsync(this);
        }

        /// <summary>
        /// Gets a value indicating whether the current stream supports reading.
        /// </summary>
        /// <returns>Always returns <see langword="true"/>.</returns>
        public override bool CanRead
        {
            get { return true; }
        }

        /// <summary>
        /// Gets a value indicating whether the current stream supports seeking.
        /// </summary>
        /// <returns>Always returns <see langword="true"/>.</returns>
        public override bool CanSeek
        {
            get { return this.stream.CanSeek; }
        }

        /// <summary>
        /// Gets a value that determines whether the current stream can time out.
        /// </summary>
        /// <returns>Always returns <see langword="false"/>.</returns>
        public override bool CanTimeout
        {
            get { return false; }
        }

        /// <summary>
        /// Gets a value indicating whether the current stream supports writing.
        /// </summary>
        /// <returns>Always returns <see langword="true"/>.</returns>
        public override bool CanWrite
        {
            get { return true; }
        }

        /// <summary>
        /// Gets the length in bytes of the stream.
        /// </summary>
        /// <returns>A long value representing the length of the stream in bytes.</returns>
        public override long Length
        {
            get { return this.stream.Length; }
        }

        /// <summary>
        /// Gets a value indicating whether the current stream is stored in memory.
        /// </summary>
        /// <value><see langword="true"/> if the stream is stored in memory; otherwise, <see langword="false"/>.</value>
        /// <remarks>The stream is moved to disk when either the length of the contents or expected content length exceeds the threshold specified in the constructor.</remarks>
        public bool IsInMemory
        {
            get { return !(this.stream.GetType() == typeof(FileStream)); }
        }

        /// <summary>
        /// Gets or sets the position within the current stream.
        /// </summary>
        /// <returns>The current position within the stream.</returns>
        public override long Position
        {
            get { return this.stream.Position; }
            set
            {
                if (value < 0)
                    throw new InvalidOperationException("The position of the stream cannot be set to less than zero.");

                if (value > this.Length)
                    throw new InvalidOperationException("The position of the stream cannot exceed the length of the stream.");

                this.stream.Position = value;
            }
        }

        /// <summary>
        /// Begins an asynchronous read operation.
        /// </summary>
        /// <returns>An <see cref="T:System.IAsyncResult"/> that represents the asynchronous read, which could still be pending.</returns>
        /// <param name="buffer">The buffer to read the data into. </param>
        /// <param name="offset">The byte offset in <paramref name="buffer"/> at which to begin writing data read from the stream. </param>
        /// <param name="count">The maximum number of bytes to read. </param>
        /// <param name="callback">An optional asynchronous callback, to be called when the read is complete. </param>
        /// <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests. </param>
        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return this.stream.BeginRead(buffer, offset, count, callback, state);
        }

        /// <summary>
        /// Begins an asynchronous write operation.
        /// </summary>
        /// <returns>An <see cref="IAsyncResult"/> that represents the asynchronous write, which could still be pending.</returns>
        /// <param name="buffer">The buffer to write data from. </param>
        /// <param name="offset">The byte offset in <paramref name="buffer"/> from which to begin writing. </param>
        /// <param name="count">The maximum number of bytes to write. </param>
        /// <param name="callback">An optional asynchronous callback, to be called when the write is complete. </param>
        /// <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return this.stream.BeginWrite(buffer, offset, count, callback, state);
        }

        protected override void Dispose(bool disposing)
        {
            if (this.isSafeToDisposeStream)
            {
                ((IDisposable)this.stream).Dispose();

                var fileStream = this.stream as FileStream;
                if (fileStream != null)
                {
                    DeleteTemporaryFile(fileStream.Name);
                }
            }

            base.Dispose(disposing);
        }

        /// <summary>
        /// Waits for the pending asynchronous read to complete.
        /// </summary>
        /// <returns>
        /// The number of bytes read from the stream, between zero (0) and the number of bytes you requested. Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.
        /// </returns>
        /// <param name="asyncResult">The reference to the pending asynchronous request to finish. </param>
        public override int EndRead(IAsyncResult asyncResult)
        {
            return this.stream.EndRead(asyncResult);
        }

        /// <summary>
        /// Ends an asynchronous write operation.
        /// </summary>
        /// <param name="asyncResult">A reference to the outstanding asynchronous I/O request. </param>
        public override void EndWrite(IAsyncResult asyncResult)
        {
            this.stream.EndWrite(asyncResult);

            this.ShiftStreamToFileStreamIfNecessary();
        }

        /// <summary>
        /// Clears all buffers for this stream and causes any buffered data to be written to the underlying device.
        /// </summary>
        public override void Flush()
        {
            this.stream.Flush();
        }

        public static RequestStream FromStream(Stream stream)
        {
            return FromStream(stream, 0, DEFAULT_SWITCHOVER_THRESHOLD, false);
        }

        public static RequestStream FromStream(Stream stream, long expectedLength)
        {
            return FromStream(stream, expectedLength, DEFAULT_SWITCHOVER_THRESHOLD, false);
        }

        public static RequestStream FromStream(Stream stream, long expectedLength, long thresholdLength)
        {
            return FromStream(stream, expectedLength, thresholdLength, false);
        }

        public static RequestStream FromStream(Stream stream, long expectedLength, bool disableStreamSwitching)
        {
            return FromStream(stream, expectedLength, DEFAULT_SWITCHOVER_THRESHOLD, disableStreamSwitching);
        }

        public static RequestStream FromStream(Stream stream, long expectedLength, long thresholdLength, bool disableStreamSwitching)
        {
            return new RequestStream(stream, expectedLength, thresholdLength, disableStreamSwitching);
        }

        /// <summary>
        /// Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
        /// </summary>
        /// <returns>The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source. </param>
        /// <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream. </param>
        /// <param name="count">The maximum number of bytes to be read from the current stream. </param>
        public override int Read(byte[] buffer, int offset, int count)
        {
            return this.stream.Read(buffer, offset, count);
        }

        /// <summary>
        /// Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
        /// </summary>
        /// <returns>The unsigned byte cast to an Int32, or -1 if at the end of the stream.</returns>
        public override int ReadByte()
        {
            return this.stream.ReadByte();
        }

        /// <summary>
        /// Sets the position within the current stream.
        /// </summary>
        /// <returns>The new position within the current stream.</returns>
        /// <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter. </param>
        /// <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position. </param>
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this.stream.Seek(offset, origin);
        }

        /// <summary>
        /// Sets the length of the current stream.
        /// </summary>
        /// <param name="value">The desired length of the current stream in bytes. </param>
        /// <exception cref="NotSupportedException">The stream does not support having it's length set.</exception>
        /// <remarks>This functionality is not supported by the <see cref="RequestStream"/> type and will always throw <see cref="NotSupportedException"/>.</remarks>
        public override void SetLength(long value)
        {
            throw new NotSupportedException();
        }

        /// <summary>
        /// Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream. </param>
        /// <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream. </param>
        /// <param name="count">The number of bytes to be written to the current stream. </param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            this.stream.Write(buffer, offset, count);

            this.ShiftStreamToFileStreamIfNecessary();
        }

        private void ShiftStreamToFileStreamIfNecessary()
        {
            if (this.disableStreamSwitching)
            {
                return;
            }

            if (this.stream.Length >= this.thresholdLength)
            {
                // Close the stream here as closing it every time we call
                // MoveStreamContentsToFileStream causes an (ObjectDisposedException)
                // in NancyWcfGenericService - webRequest.UriTemplateMatch
                var old = this.stream;
                this.MoveStreamContentsToFileStream();
                old.Close();
            }
        }

        private static FileStream CreateTemporaryFileStream()
        {
            // we could use Path.GetTempFilePath() but this is problematic on Windows and more so on Mono
            // symptoms will show when this method has been called > 65k times
            // see docs: https://msdn.microsoft.com/en-us/library/system.io.path.gettempfilename(v=vs.110).aspx
            // comments on Win32 implementation: https://msdn.microsoft.com/en-us/library/windows/desktop/aa364991(v=vs.85).aspx
            // mono implementation: https://github.com/mono/mono/blob/master/mcs/class/corlib/System.IO/Path.cs#L490

            var filePath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N") + ".tmp");

            return new FileStream(
                filePath,
                FileMode.Create,
                FileAccess.ReadWrite,
                FileShare.None,
                8192,
                StaticConfiguration.AllowFileStreamUploadAsync);
        }

        private Stream CreateDefaultMemoryStream(long expectedLength)
        {
            this.isSafeToDisposeStream = true;

            if (this.disableStreamSwitching || expectedLength < this.thresholdLength)
            {
                return new MemoryStream((int)expectedLength);
            }

            this.disableStreamSwitching = true;

            return CreateTemporaryFileStream();
        }

        private static void DeleteTemporaryFile(string fileName)
        {
            if (string.IsNullOrEmpty(fileName) || !File.Exists(fileName))
            {
                return;
            }

            try
            {
                File.Delete(fileName);
            }
            catch
            {
            }
        }

        private void MoveStreamOutOfMemoryIfContentsLengthExceedThresholdAndSwitchingIsEnabled()
        {
            if (!this.stream.CanSeek)
            {
                return;
            }

            try
            {
                if ((this.stream.Length > this.thresholdLength) && !this.disableStreamSwitching)
                {
                    this.MoveStreamContentsToFileStream();
                }
            }
            catch (NotSupportedException)
            {
            }
        }

        private bool MoveStreamOutOfMemoryIfExpectedLengthExceedSwitchLength(long expectedLength)
        {
            if ((expectedLength >= this.thresholdLength) && !this.disableStreamSwitching)
            {
                this.MoveStreamContentsToFileStream();
                return true;
            }
            return false;
        }

        private void MoveStreamContentsToFileStream()
        {
            var targetStream = CreateTemporaryFileStream();
            this.isSafeToDisposeStream = true;

            if (this.stream.CanSeek && this.stream.Length == 0)
            {
                this.stream.Close();
                this.stream = targetStream;
                return;
            }

            // Seek to 0 if we can, although if we can't seek, and we've already written (if the size is unknown) then
            // we are screwed anyway, and some streams that don't support seek also don't let you read the position so
            // there's no real way to check :-/
            if (this.stream.CanSeek)
            {
                this.stream.Position = 0;
            }
            this.stream.CopyTo(targetStream, 8196);
            if (this.stream.CanSeek)
            {
                this.stream.Flush();
            }

            this.stream = targetStream;

            this.disableStreamSwitching = true;
        }

        private static void ThrowExceptionIfCtorParametersWereInvalid(Stream stream, long expectedLength, long thresholdLength)
        {
            if (!stream.CanRead)
            {
                throw new InvalidOperationException("The stream must support reading.");
            }

            if (expectedLength < 0)
            {
                throw new ArgumentOutOfRangeException("expectedLength", expectedLength, "The value of the expectedLength parameter cannot be less than zero.");
            }

            if (thresholdLength < 0)
            {
                throw new ArgumentOutOfRangeException("thresholdLength", thresholdLength, "The value of the threshHoldLength parameter cannot be less than zero.");
            }
        }

    }
}
namespace Nancy.Responses
{
    using System;
    using System.IO;
    using System.Linq;
    using Nancy.Configuration;
    using Nancy.Helpers;

    /// <summary>
    /// A response representing a file.
    /// </summary>
    /// <remarks>If the response contains an invalid file (not found, empty name, missing extension and so on) the status code of the response will be set to <see cref="HttpStatusCode.NotFound"/>.</remarks>
    public class GenericFileResponse : Response
    {
        private readonly StaticContentConfiguration configuration;

        /// <summary>
        ///  Size of buffer for transmitting file. Default size 4 Mb
        /// </summary>
        public static int BufferSize = 4 * 1024 * 1024;

        /// <summary>
        /// Initializes a new instance of the <see cref="GenericFileResponse"/> for the file specified
        /// by the <paramref name="filePath"/> parameter.
        /// </summary>
        /// <param name="filePath">The name of the file, including path relative to the root of the application, that should be returned.</param>
        /// <remarks>The <see cref="MimeTypes.GetMimeType"/> method will be used to determine the mimetype of the file and will be used as the content-type of the response. If no match if found the content-type will be set to application/octet-stream.</remarks>
        /// <param name="context">Current context</param>
        public GenericFileResponse(string filePath, NancyContext context)
            : this(filePath, MimeTypes.GetMimeType(filePath), context)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GenericFileResponse"/> for the file specified
        /// by the <paramref name="filePath"/> parameter and the content-type specified by the <paramref name="contentType"/> parameter.
        /// </summary>
        /// <param name="filePath">The name of the file, including path relative to the root of the application, that should be returned.</param>
        /// <param name="contentType">The content-type of the response.</param>
        /// <param name="context">Current context</param>
        public GenericFileResponse(string filePath, string contentType, NancyContext context)
        {
            var environment = context.Environment;
            this.configuration = environment.GetValue<StaticContentConfiguration>();
            this.InitializeGenericFileResponse(filePath, contentType, context);
        }

        /// <summary>
        /// Gets the filename of the file response
        /// </summary>
        /// <value>A string containing the name of the file.</value>
        public string Filename { get; protected set; }

        private static Action<Stream> GetFileContent(string filePath, long length)
        {
            return stream =>
            {
                using (var file = File.OpenRead(filePath))
                {
                    file.CopyTo(stream, (int)(length < BufferSize ? length : BufferSize));
                }
            };
        }

        static bool IsSafeFilePath(string rootPath, string filePath)
        {
            if (!File.Exists(filePath))
            {
                return false;
            }

            var fullPath = Path.GetFullPath(filePath);

            return fullPath.StartsWith(Path.GetFullPath(rootPath), StringComparison.OrdinalIgnoreCase);
        }

        private void InitializeGenericFileResponse(string filePath, string contentType, NancyContext context)
        {
            if (string.IsNullOrEmpty(filePath))
            {
                StatusCode = HttpStatusCode.NotFound;
                return;
            }

            if (this.configuration.SafePaths == null || !this.configuration.SafePaths.Any())
            {
                throw new InvalidOperationException("No SafePaths defined.");
            }
            foreach (var rootPath in this.configuration.SafePaths)
            {
                string fullPath;
                if (Path.IsPathRooted(filePath))
                {
                    fullPath = filePath;
                }
                else
                {
                    fullPath = Path.Combine(rootPath, filePath);
                }

                if (IsSafeFilePath(rootPath, fullPath))
                {
                    this.Filename = Path.GetFileName(fullPath);

                    this.SetResponseValues(contentType, fullPath, context);

                    return;
                }
            }

            StatusCode = HttpStatusCode.NotFound;
        }

        private void SetResponseValues(string contentType, string fullPath, NancyContext context)
        {
            // TODO - set a standard caching time and/or public?
            var fi = new FileInfo(fullPath);

            var lastWriteTimeUtc = fi.LastWriteTimeUtc;
            var etag = string.Concat("\"", lastWriteTimeUtc.Ticks.ToString("x"), "\"");
            var lastModified = lastWriteTimeUtc.ToString("R");
            var length = fi.Length;

            if (CacheHelpers.ReturnNotModified(etag, lastWriteTimeUtc, context))
            {
                this.StatusCode = HttpStatusCode.NotModified;
                this.ContentType = null;
                this.Contents = NoBody;

                return;
            }

            this.Headers["ETag"] = etag;
            this.Headers["Last-Modified"] = lastModified;
            this.Headers["Content-Length"] = length.ToString();

            if (length > 0)
            {
                this.Contents = GetFileContent(fullPath, length);
            }

            this.ContentType = contentType;
            this.StatusCode = HttpStatusCode.OK;
        }
    }
}
namespace Nancy.Responses
{
    using System;
    using System.IO;
    using Nancy.Configuration;
    using Nancy.Json;

    /// <summary>
    /// Represents a JSON response of the type <typeparamref name="TModel"/>.
    /// </summary>
    /// <typeparam name="TModel">The type of the model.</typeparam>
    public class JsonResponse<TModel> : Response
    {
        private readonly JsonConfiguration configuration;

        /// <summary>
        /// Initializes a new instance of the <see cref="JsonResponse{TModel}"/> class,
        /// with the provided <paramref name="model"/>, <paramref name="serializer"/>
        /// and <paramref name="environment"/>.
        /// </summary>
        /// <param name="model">The model that should be returned as JSON.</param>
        /// <param name="serializer">The <see cref="ISerializer"/> to use for the serialization.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public JsonResponse(TModel model, ISerializer serializer, INancyEnvironment environment)
        {
            if (serializer == null)
            {
                throw new InvalidOperationException("JSON Serializer not set");
            }

            this.configuration = environment.GetValue<JsonConfiguration>();
            this.Contents = model == null ? NoBody : this.GetJsonContents(model, serializer);
            this.ContentType = this.DefaultContentType;
            this.StatusCode = HttpStatusCode.OK;
        }

        private string DefaultContentType
        {
            get { return string.Concat("application/json", this.Encoding); }
        }

        private string Encoding
        {
            get { return string.Concat("; charset=", this.configuration.DefaultEncoding.WebName); }
        }

        private Action<Stream> GetJsonContents(TModel model, ISerializer serializer)
        {
            return stream => serializer.Serialize(this.DefaultContentType, model, stream);
        }
    }

    /// <summary>
    /// Represents a JSON response
    /// </summary>
    public class JsonResponse : JsonResponse<object>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="JsonResponse{TModel}"/> class,
        /// with the provided <paramref name="model"/>, <paramref name="serializer"/>
        /// and <paramref name="environment"/>.
        /// </summary>
        /// <param name="model">The model that should be returned as JSON.</param>
        /// <param name="serializer">The <see cref="ISerializer"/> to use for the serialization.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public JsonResponse(object model, ISerializer serializer, INancyEnvironment environment) : base(model, serializer, environment)
        {
        }
    }
}
namespace Nancy.Responses
{
    /// <summary>
    /// A response representing an HTTP redirect
    /// <seealso cref="Nancy.Extensions.ContextExtensions.ToFullPath"/>
    /// <seealso cref="Nancy.Extensions.ContextExtensions.GetRedirect"/>
    /// </summary>
    public class RedirectResponse : Response
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RedirectResponse"/> class.
        /// </summary>
        /// <param name="location">Location to redirect to</param>
        /// <param name="type">Type of redirection to perform</param>
        public RedirectResponse(string location, RedirectType type = RedirectType.SeeOther)
        {
            this.Headers.Add("Location", location);
            this.Contents = GetStringContents(string.Empty);
            this.ContentType = "text/html";
            switch (type)
            {
                case RedirectType.Permanent:
                    this.StatusCode = HttpStatusCode.MovedPermanently;
                    break;
                case RedirectType.Temporary:
                    this.StatusCode = HttpStatusCode.TemporaryRedirect;
                    break;
                default:
                    this.StatusCode = HttpStatusCode.SeeOther;
                    break;
            }
        }

        /// <summary>
        /// Which type of redirect
        /// </summary>
        public enum RedirectType
        {
            /// <summary>
            /// HTTP 301 - All future requests should be to this URL
            /// </summary>
            Permanent,
            /// <summary>
            /// HTTP 307 - Redirect this request but allow future requests to the original URL
            /// </summary>
            Temporary,
            /// <summary>
            /// HTTP 303 - Redirect this request using an HTTP GET
            /// </summary>
            SeeOther
        }
    }
}
namespace Nancy.Responses
{
    using System;
    using System.IO;
    using Nancy.Configuration;
    using Nancy.Xml;

    public class XmlResponse<TModel> : Response
    {
        private readonly XmlConfiguration configuration;

        public XmlResponse(TModel model, ISerializer serializer, INancyEnvironment environment)
        {
            if (serializer == null)
            {
                throw new InvalidOperationException("XML Serializer not set");
            }

            this.configuration = environment.GetValue<XmlConfiguration>();

            this.Contents = GetXmlContents(model, serializer);
            this.ContentType = DefaultContentType;
            this.StatusCode = HttpStatusCode.OK;
        }

        private string DefaultContentType
        {
            get { return string.Concat("application/xml", this.Encoding); }
        }

        private string Encoding
        {
            get
            {
                return this.configuration.EncodingEnabled
                    ? string.Concat("; charset=", this.configuration.DefaultEncoding.WebName)
                    : string.Empty;
            }
        }

        private Action<Stream> GetXmlContents(TModel model, ISerializer serializer)
        {
            return stream => serializer.Serialize(this.DefaultContentType, model, stream);
        }
    }
}
namespace Nancy.Routing
{
    using Nancy.Extensions;
    using Nancy.ModelBinding;
    using Nancy.Responses.Negotiation;
    using Nancy.Validation;
    using Nancy.ViewEngines;

    /// <summary>
    /// Default implementation for building a full configured <see cref="INancyModule"/> instance.
    /// </summary>
    public class DefaultNancyModuleBuilder : INancyModuleBuilder
    {
        private readonly IViewFactory viewFactory;
        private readonly IResponseFormatterFactory responseFormatterFactory;
        private readonly IModelBinderLocator modelBinderLocator;
        private readonly IModelValidatorLocator validatorLocator;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultNancyModuleBuilder"/> class.
        /// </summary>
        /// <param name="viewFactory">The <see cref="IViewFactory"/> instance that should be assigned to the module.</param>
        /// <param name="responseFormatterFactory">An <see cref="IResponseFormatterFactory"/> instance that should be used to create a response formatter for the module.</param>
        /// <param name="modelBinderLocator">A <see cref="IModelBinderLocator"/> instance that should be assigned to the module.</param>
        /// <param name="validatorLocator">A <see cref="IModelValidatorLocator"/> instance that should be assigned to the module.</param>
        public DefaultNancyModuleBuilder(IViewFactory viewFactory, IResponseFormatterFactory responseFormatterFactory, IModelBinderLocator modelBinderLocator, IModelValidatorLocator validatorLocator)
        {
            this.viewFactory = viewFactory;
            this.responseFormatterFactory = responseFormatterFactory;
            this.modelBinderLocator = modelBinderLocator;
            this.validatorLocator = validatorLocator;
        }

        /// <summary>
        /// Builds a fully configured <see cref="INancyModule"/> instance, based upon the provided <paramref name="module"/>.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> that should be configured.</param>
        /// <param name="context">The current request context.</param>
        /// <returns>A fully configured <see cref="INancyModule"/> instance.</returns>
        public INancyModule BuildModule(INancyModule module, NancyContext context)
        {
            module.Context = context;
            module.Response = this.responseFormatterFactory.Create(context);
            module.ViewFactory = this.viewFactory;
            module.ModelBinderLocator = this.modelBinderLocator;
            module.ValidatorLocator = this.validatorLocator;

            return module;
        }
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    using Nancy.Diagnostics;

    /// <summary>
    /// It's not safe for a module to take a dependency on the cache (cyclic dependency)
    ///
    /// We provide an IRouteCacheProvider instead - the default implementation uses
    /// TinyIoC'd Func based lazy factory.
    /// </summary>
    public class DefaultRouteCacheProvider : IRouteCacheProvider, IDiagnosticsProvider
    {
        protected readonly Func<IRouteCache> RouteCacheFactory;

        /// <summary>
        /// Gets the name of the provider.
        /// </summary>
        /// <value>A <see cref="string"/> containing the name of the provider.</value>
        public string Name
        {
            get { return "Route Cache"; }
        }

        /// <summary>
        /// Gets the description of the provider.
        /// </summary>
        /// <value>A <see cref="string"/> containing the description of the provider.</value>
        public string Description
        {
            get { return "Provides methods for viewing and querying the route cache."; }
        }

        /// <summary>
        /// Gets the object that contains the interactive diagnostics methods.
        /// </summary>
        /// <value>An instance of the interactive diagnostics object.</value>
        public object DiagnosticObject { get; private set; }

        /// <summary>
        /// Initializes a new instance of the DefaultRouteCacheProvider class.
        /// </summary>
        /// <param name="routeCacheFactory"></param>
        public DefaultRouteCacheProvider(Func<IRouteCache> routeCacheFactory)
        {
            this.RouteCacheFactory = routeCacheFactory;

            this.DiagnosticObject = new RouteCacheDiagnostics(this);
        }

        /// <summary>
        /// Gets an instance of the route cache.
        /// </summary>
        /// <returns>An <see cref="IRouteCache"/> instance.</returns>
        public IRouteCache GetCache()
        {
            return this.RouteCacheFactory();
        }

        private class RouteCacheDiagnostics
        {
            private readonly DefaultRouteCacheProvider cacheProvider;

            public RouteCacheDiagnostics(DefaultRouteCacheProvider cacheProvider)
            {
                this.cacheProvider = cacheProvider;
            }

            // ReSharper disable once UnusedMember.Local
            public IDictionary<string, IList<object>> GetAllRoutes()
            {
                var result = new Dictionary<string, IList<object>>();

                foreach (var entry in this.cacheProvider.GetCache().Values.SelectMany(t => t.Select(t1 => t1.Item2)))
                {
                    if (!result.ContainsKey(entry.Method))
                    {
                        result[entry.Method] = new List<object>();
                    }

                    result[entry.Method].Add(new { Name = entry.Name, Path = entry.Path });
                }

                return result;
            }
        }
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;
    using System.Text.RegularExpressions;

    using Nancy.Extensions;

    /// <summary>
    /// Default implementation of a route pattern matcher.
    /// </summary>
    public class DefaultRoutePatternMatcher : IRoutePatternMatcher
    {
        private readonly ConcurrentDictionary<string, Tuple<Regex, IEnumerable<ParameterSegmentInformation>>>
            matcherCache = new ConcurrentDictionary<string, Tuple<Regex, IEnumerable<ParameterSegmentInformation>>>();

        /// <summary>
        /// Attempts to match a requested path with a route pattern.
        /// </summary>
        /// <param name="requestedPath">The path that was requested.</param>
        /// <param name="routePath">The route pattern that the requested path should be attempted to be matched with.</param>
        /// <param name="segments"></param>
        /// <param name="context">The <see cref="NancyContext"/> instance for the current request.</param>
        /// <returns>An <see cref="IRoutePatternMatchResult"/> instance, containing the outcome of the match.</returns>
        public IRoutePatternMatchResult Match(string requestedPath, string routePath, IEnumerable<string> segments, NancyContext context)
        {
            var routePathPattern =
                this.matcherCache.GetOrAdd(routePath, s => BuildRegexMatcher(segments.ToList()));

            requestedPath =
                TrimTrailingSlashFromRequestedPath(requestedPath);

            var match =
                routePathPattern.Item1.Match(requestedPath);

            var matches = match
                .Groups.Cast<Group>()
                .ToList();

            return new RoutePatternMatchResult(
                match.Success,
                GetParameters(routePathPattern, matches),
                context);
        }

        private static string TrimTrailingSlashFromRequestedPath(string requestedPath)
        {
            if (!requestedPath.Equals("/"))
            {
                requestedPath = requestedPath.TrimEnd('/');
            }

            return requestedPath;
        }

        private static Tuple<Regex, IEnumerable<ParameterSegmentInformation>> BuildRegexMatcher(IList<string> segments)
        {
            var parameterizedSegments =
                GetParameterizedSegments2(segments);

            var parsedSegments = (segments.Any()) ?
                string.Join(string.Empty, parameterizedSegments.Item1) :
                "/";

            var pattern =
                string.Concat(@"^", parsedSegments, @"$");

            return new Tuple<Regex, IEnumerable<ParameterSegmentInformation>>(
                new Regex(pattern, RegexOptions.Compiled | RegexOptions.IgnoreCase),
                parameterizedSegments.Item2);
        }

        private static DynamicDictionary GetParameters(Tuple<Regex, IEnumerable<ParameterSegmentInformation>> result, IList<Group> matches)
        {
            dynamic data = new DynamicDictionary();

            for (var i = 1; i <= matches.Count() - 1; i++)
            {
                var name =
                    result.Item1.GroupNameFromNumber(i);

                var value = (matches[i].Success) ?
                    matches[i].Value :
                    result.Item2.Where(x => x.Name.Equals(name) && !string.IsNullOrEmpty(x.DefaultValue)).Select(x => x.DefaultValue).SingleOrDefault();

                data[name] = value;
            }

            return data;
        }

        private static Tuple<IEnumerable<string>, IEnumerable<ParameterSegmentInformation>> GetParameterizedSegments2(
            IEnumerable<string> segments)
        {
            var parsedSegments = new List<string>();
            var segmentInformation = new List<ParameterSegmentInformation>();

            foreach (var segment in segments)
            {
                var current = segment;

                if (current.IsParameterized() && !IsRegexSegment(current))
                {
                    var result =
                        ParameterizeSegment(segment);

                    current = result.Item1;
                    segmentInformation.AddRange(result.Item2);
                }
                else
                {
                    current = string.Concat("/", (!IsRegexSegment(current)) ? Regex.Escape(current) : current);
                }

                parsedSegments.Add(current);
            }

            return new Tuple<IEnumerable<string>, IEnumerable<ParameterSegmentInformation>>(parsedSegments, segmentInformation);
        }

        private static bool IsRegexSegment(string segment)
        {
            return segment.StartsWith("(");
        }

        private static Tuple<string, IEnumerable<ParameterSegmentInformation>> ParameterizeSegment(string segment)
        {
            segment = segment.Replace(".", @"\.");

            var details =
                segment.GetParameterDetails().ToList();

            for (var index = 0; index < details.Count; index++)
            {
                var information =
                    details.Skip(index).First();

                var replacement =
                    string.Format(CultureInfo.InvariantCulture, @"(?<{0}>.+?)", information.Name);

                if (information.IsOptional)
                {
                    replacement = string.Concat(replacement, "?");
                }

                segment = segment.Replace(
                    string.Concat("{", information.FullSegmentName, "}"),
                    replacement);
            }

            segment = string.Concat(@"\/", segment);

            if (details.All(x => x.IsOptional) && segment.StartsWith(@"\/(") && (segment.EndsWith(")") || segment.EndsWith(")?")))
            {
                segment = string.Concat(@"(?:", segment, ")?");
            }

            return new Tuple<string, IEnumerable<ParameterSegmentInformation>>(segment, details);
        }
    }
}
namespace Nancy
{
    /// <summary>
    /// Defines the functionality to retrieve the root folder path of the current Nancy application.
    /// </summary>
    public interface IRootPathProvider : IHideObjectMembers
    {
        /// <summary>
        /// Returns the root folder path of the current Nancy application.
        /// </summary>
        /// <returns>A <see cref="string"/> containing the path of the root folder.</returns>
        string GetRootPath();
    }
}
namespace Nancy.Routing
{
    /// <summary>
    /// Defines the functionality to build a fully configured NancyModule instance.
    /// </summary>
    public interface INancyModuleBuilder
    {
        /// <summary>
        /// Builds a fully configured <see cref="INancyModule"/> instance, based upon the provided <paramref name="module"/>.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> that should be configured.</param>
        /// <param name="context">The current request context.</param>
        /// <returns>A fully configured <see cref="INancyModule"/> instance.</returns>
        INancyModule BuildModule(INancyModule module, NancyContext context);
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Contains a cache of all routes registered in the system
    /// </summary>
    public interface IRouteCache : IDictionary<Type, List<Tuple<int, RouteDescription>>>
    {
        /// <summary>
        /// Gets a boolean value that indicates of the cache is empty or not.
        /// </summary>
        /// <returns><see langword="true"/> if the cache is empty, otherwise <see langword="false"/>.</returns>
        bool IsEmpty();
    }
}
namespace Nancy.Routing
{
    /// <summary>
    /// It's not safe for a module to take a dependency on the cache (cyclic dependency)
    ///
    /// We provide an <see cref="IRouteCacheProvider"/> instead.
    ///
    /// It is *not* safe to call GetCache() inside a NancyModule constructor, although that shouldn't be necessary anyway.
    /// </summary>
    public interface IRouteCacheProvider
    {
        /// <summary>
        /// Gets an instance of the route cache.
        /// </summary>
        /// <returns>An <see cref="IRouteCache"/> instance.</returns>
        IRouteCache GetCache();
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    using Nancy.Culture;

    /// <summary>
    /// Caches information about all the available routes that was discovered by the bootstrapper.
    /// </summary>
    public class RouteCache : Dictionary<Type, List<Tuple<int, RouteDescription>>>, IRouteCache
    {
        private readonly IRouteSegmentExtractor routeSegmentExtractor;
        private readonly IRouteDescriptionProvider routeDescriptionProvider;
        private readonly IEnumerable<IRouteMetadataProvider> routeMetadataProviders;

        /// <summary>
        /// Initializes a new instance of the <see cref="RouteCache"/> class.
        /// </summary>
        /// <param name="moduleCatalog">The <see cref="INancyModuleCatalog"/> that should be used by the cache.</param>
        /// <param name="contextFactory">The <see cref="INancyContextFactory"/> that should be used to create a context instance.</param>
        /// <param name="routeSegmentExtractor"> </param>
        /// <param name="cultureService"></param>
        /// <param name="routeMetadataProviders"></param>
        /// <param name="routeDescriptionProvider"></param>
        public RouteCache(
            INancyModuleCatalog moduleCatalog,
            INancyContextFactory contextFactory,
            IRouteSegmentExtractor routeSegmentExtractor,
            IRouteDescriptionProvider routeDescriptionProvider,
            ICultureService cultureService,
            IEnumerable<IRouteMetadataProvider> routeMetadataProviders)
        {
            this.routeSegmentExtractor = routeSegmentExtractor;
            this.routeDescriptionProvider = routeDescriptionProvider;
            this.routeMetadataProviders = routeMetadataProviders;

            var request = new Request("GET", "/", "http");

            using (var context = contextFactory.Create(request))
            {
                this.BuildCache(moduleCatalog.GetAllModules(context));
            }
        }

        /// <summary>
        /// Gets a boolean value that indicates of the cache is empty or not.
        /// </summary>
        /// <returns><see langword="true"/> if the cache is empty, otherwise <see langword="false"/>.</returns>
        public bool IsEmpty()
        {
            return !this.Values.SelectMany(r => r).Any();
        }

        private void BuildCache(IEnumerable<INancyModule> modules)
        {
            foreach (var module in modules)
            {
                var moduleType = module.GetType();

                var routes =
                    module.Routes.Select(r => r.Description).ToArray();

                foreach (var routeDescription in routes)
                {
                    routeDescription.Description = this.routeDescriptionProvider.GetDescription(module, routeDescription.Path);
                    routeDescription.Segments = this.routeSegmentExtractor.Extract(routeDescription.Path).ToArray();
                    routeDescription.Metadata = this.GetRouteMetadata(module, routeDescription);
                }

                this.AddRoutesToCache(routes, moduleType);
            }
        }

        private RouteMetadata GetRouteMetadata(INancyModule module, RouteDescription routeDescription)
        {
            var data = new Dictionary<Type, object>();

            foreach (var provider in this.routeMetadataProviders)
            {
                var type = provider.GetMetadataType(module, routeDescription);
                var metadata = provider.GetMetadata(module, routeDescription);

                if (type != null && metadata != null)
                {
                    data.Add(type, metadata);
                }
            }

            return new RouteMetadata(data);
        }

        private void AddRoutesToCache(IEnumerable<RouteDescription> routes, Type moduleType)
        {
            if (!this.ContainsKey(moduleType))
            {
                this[moduleType] = new List<Tuple<int, RouteDescription>>();
            }

            this[moduleType].AddRange(routes.Select((r, i) => new Tuple<int, RouteDescription>(i, r)));
        }
    }
}
namespace Nancy.Routing
{
    using System.Collections.Generic;

    /// <summary>
    /// Defined the functionality that is required by a route pattern matcher.
    /// </summary>
    /// <remarks>Implement this interface if you want to support a custom route syntax.</remarks>
    public interface IRoutePatternMatcher
    {
        /// <summary>
        /// Attempts to match a requested path with a route pattern.
        /// </summary>
        /// <param name="requestedPath">The path that was requested.</param>
        /// <param name="routePath">The route pattern that the requested path should be attempted to be matched with.</param>
        /// <param name="segments"> </param>
        /// <param name="context">The <see cref="NancyContext"/> instance for the current request.</param>
        /// <returns>An <see cref="IRoutePatternMatchResult"/> instance, containing the outcome of the match.</returns>
        IRoutePatternMatchResult Match(string requestedPath, string routePath, IEnumerable<string> segments, NancyContext context);
    }
}
namespace Nancy.Routing
{
    /// <summary>
    /// Defines the functionality that is required by a route pattern match result.
    /// </summary>
    public interface IRoutePatternMatchResult
    {
        /// <summary>
        /// Gets the <see cref="NancyContext"/> that was active when the result was produced.
        /// </summary>
        /// <value>A <see cref="NancyContext"/> instance.</value>
        NancyContext Context { get; }

        /// <summary>
        /// Gets a value indicating whether or not a match was made.
        /// </summary>
        /// <value><see langword="true"/> if a match was made; otherwise <see langword="false"/>.</value>
        bool IsMatch { get; }

        /// <summary>
        /// The parameters that could be captured in the route.
        /// </summary>
        /// <value>A <see cref="DynamicDictionary"/> instance containing the captured parameters and values.</value>
        /// <remarks>Should be empty if <see cref="IsMatch"/> is <see langword="false"/>.</remarks>
        DynamicDictionary Parameters { get; }
    }
}
namespace Nancy.Routing
{
    using System.Collections.Generic;
    using System.Threading.Tasks;

    using Nancy.Helpers;

    /// <summary>
    /// Route that is returned when the path could be matched but it was for the wrong request method.
    /// </summary>
    /// <remarks>This is equal to sending back the 405 HTTP status code.</remarks>
    public class MethodNotAllowedRoute : Route
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MethodNotAllowedRoute"/> type, for the
        /// specified <paramref name="path"/>, <paramref name="method"/> and <paramref name="allowedMethods"/>.
        /// </summary>
        /// <param name="path">The path of the route.</param>
        /// <param name="method">The HTTP method of the route.</param>
        /// <param name="allowedMethods">The HTTP methods that can be used to invoke the route.</param>
        public MethodNotAllowedRoute(string path, string method, IEnumerable<string> allowedMethods)
            : base(method, path, null, (x, c) => CreateMethodNotAllowedResponse(allowedMethods))
        {
        }

        private static Task<dynamic> CreateMethodNotAllowedResponse(IEnumerable<string> allowedMethods)
        {
            var response = new Response();
            response.Headers["Allow"] = string.Join(", ", allowedMethods);
            response.StatusCode = HttpStatusCode.MethodNotAllowed;

            return Task.FromResult<dynamic>(response);
        }
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// Represents the various parts of a route lambda.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay, nq}")]
    public sealed class RouteDescription
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteDescription"/> class.
        /// </summary>
        /// <param name="name">Route name</param>
        /// <param name="method">The request method of the route.</param>
        /// <param name="path">The path that the route will be invoked for.</param>
        /// <param name="condition">The condition that has to be fulfilled for the route to be a valid match.</param>
        public RouteDescription(string name, string method, string path, Func<NancyContext, bool> condition)
        {
            if (string.IsNullOrEmpty(method))
            {
                throw new ArgumentException("Method must be specified", "method");
            }

            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("Path must be specified", "path");
            }

            this.Name = name ?? string.Empty;
            this.Method = method;
            this.Path = path;
            this.Condition = condition;
        }

        /// <summary>
        /// The name of the route
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The condition that has to be fulfilled inorder for the route to be a valid match.
        /// </summary>
        /// <value>A function that evaluates the condition when a <see cref="NancyContext"/> instance is passed in.</value>
        public Func<NancyContext, bool> Condition { get; private set; }

        /// <summary>
        /// The description of what the route is for.
        /// </summary>
        /// <value>A <see cref="string"/> containing the description of the route.</value>
        public string Description { get; set; }

        /// <summary>
        /// Gets or sets the metadata information for a route.
        /// </summary>
        /// <value>A <see cref="RouteMetadata"/> instance.</value>
        public RouteMetadata Metadata { get; set; }

        /// <summary>
        /// Gets the method of the route.
        /// </summary>
        /// <value>A <see cref="string"/> containing the method of the route.</value>
        public string Method { get; private set; }

        /// <summary>
        /// Gets the path that the route will be invoked for.
        /// </summary>
        /// <value>A <see cref="string"/> containing the path of the route.</value>
        public string Path { get; private set; }

        /// <summary>
        /// Gets or set the segments, for the route, that was returned by the <see cref="IRouteSegmentExtractor"/>.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/>, containing the segments for the route.</value>
        public IEnumerable<string> Segments { get; set; }

        private string DebuggerDisplay
        {
            get
            {
                var builder = new StringBuilder();

                if (!string.IsNullOrEmpty(this.Name))
                {
                    builder.AppendFormat("{0} - ", this.Name);
                }

                builder.AppendFormat("{0} {1}", this.Method, this.Path);

                return builder.ToString();
            }
        }
    }
}
namespace Nancy.Routing
{
    /// <summary>
    /// The default implementation of a route pattern matching result.
    /// </summary>
    public class RoutePatternMatchResult : IRoutePatternMatchResult
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RoutePatternMatchResult"/> class.
        /// </summary>
        /// <param name="isMatch">A <see cref="bool"/> value indicating if the result was a match or not.</param>
        /// <param name="parameters">A <see cref="DynamicDictionary"/> instance containing the parameters and values that was captured in the match.</param>
        /// <param name="context">The <see cref="NancyContext"/> instance of the current request.</param>
        public RoutePatternMatchResult(bool isMatch, DynamicDictionary parameters, NancyContext context)
        {
            this.IsMatch = isMatch;
            this.Parameters = parameters;
            this.Context = context;
        }

        /// <summary>
        /// Gets the <see cref="NancyContext"/> that was active when the result was produced.
        /// </summary>
        /// <value>A <see cref="NancyContext"/> instance.</value>
        public NancyContext Context { get; private set; }

        /// <summary>
        /// Gets a value indicating whether or not a match was made.
        /// </summary>
        /// <value><see langword="true"/> if a match was made; otherwise <see langword="false"/>.</value>
        public bool IsMatch { get; private set; }

        /// <summary>
        /// The parameters that could be captured in the route.
        /// </summary>
        /// <value>A <see cref="DynamicDictionary"/> instance containing the captured parameters and values.</value>
        /// <remarks>Should be empty if <see cref="IRoutePatternMatchResult.IsMatch"/> is <see langword="false"/>.</remarks>
        public DynamicDictionary Parameters { get; private set; }
    }
}
namespace Nancy.Security
{
    using System;
    using System.Linq;
    using System.Security.Claims;

    using Nancy.Extensions;
    using Nancy.Responses;

    /// <summary>
    /// Some simple helpers give some nice authentication syntax in the modules.
    /// </summary>
    public static class ModuleSecurity
    {
        /// <summary>
        /// This module requires authentication
        /// </summary>
        /// <param name="module">Module to enable</param>
        public static void RequiresAuthentication(this INancyModule module)
        {
            module.AddBeforeHookOrExecute(SecurityHooks.RequiresAuthentication(), "Requires Authentication");
        }

        /// <summary>
        /// This module requires authentication and certain claims to be present.
        /// </summary>
        /// <param name="module">Module to enable</param>
        /// <param name="requiredClaims">Claim(s) required</param>
        public static void RequiresClaims(this INancyModule module, params Predicate<Claim>[] requiredClaims)
        {
            module.AddBeforeHookOrExecute(SecurityHooks.RequiresAuthentication(), "Requires Authentication");
            module.AddBeforeHookOrExecute(SecurityHooks.RequiresClaims(requiredClaims), "Requires Claims");
        }

        /// <summary>
        /// This module requires authentication and any one of certain claims to be present.
        /// </summary>
        /// <param name="module">Module to enable</param>
        /// <param name="requiredClaims">Claim(s) required</param>
        public static void RequiresAnyClaim(this INancyModule module, params Predicate<Claim>[] requiredClaims)
        {
            module.AddBeforeHookOrExecute(SecurityHooks.RequiresAuthentication(), "Requires Authentication");
            module.AddBeforeHookOrExecute(SecurityHooks.RequiresAnyClaim(requiredClaims), "Requires Any Claim");
        }

        /// <summary>
        /// This module requires https.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> that requires HTTPS.</param>
        public static void RequiresHttps(this INancyModule module)
        {
            module.RequiresHttps(true);
        }

        /// <summary>
        /// This module requires https.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> that requires HTTPS.</param>
        /// <param name="redirect"><see langword="true"/> if the user should be redirected to HTTPS (no port number) if the incoming request was made using HTTP, otherwise <see langword="false"/> if <see cref="HttpStatusCode.Forbidden"/> should be returned.</param>
        public static void RequiresHttps(this INancyModule module, bool redirect)
        {
            module.Before.AddItemToEndOfPipeline(SecurityHooks.RequiresHttps(redirect, null));
        }

        /// <summary>
        /// This module requires https.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> that requires HTTPS.</param>
        /// <param name="redirect"><see langword="true"/> if the user should be redirected to HTTPS if the incoming request was made using HTTP, otherwise <see langword="false"/> if <see cref="HttpStatusCode.Forbidden"/> should be returned.</param>
        /// <param name="httpsPort">The HTTPS port number to use</param>
        public static void RequiresHttps(this INancyModule module, bool redirect, int httpsPort)
        {
            module.Before.AddItemToEndOfPipeline(SecurityHooks.RequiresHttps(redirect, httpsPort));
        }
    }
}
namespace Nancy.Security
{
    using System;
    using System.Collections.Generic;
    using System.Security.Claims;

    using Nancy.Responses;

    /// <summary>
    /// Hooks to be used in a request pipeline.
    /// </summary>
    public static class SecurityHooks
    {
        /// <summary>
        /// Creates a hook to be used in a pipeline before a route handler to ensure that
        /// the request was made by an authenticated user.
        /// </summary>
        /// <returns>Hook that returns an Unauthorized response if not authenticated in,
        /// null otherwise</returns>
        public static Func<NancyContext, Response> RequiresAuthentication()
        {
            return UnauthorizedIfNot(ctx => ctx.CurrentUser.IsAuthenticated());
        }

        /// <summary>
        /// Creates a hook to be used in a pipeline before a route handler to ensure
        /// that the request was made by an authenticated user having the required claims.
        /// </summary>
        /// <param name="claims">Claims the authenticated user needs to have</param>
        /// <returns>Hook that returns an Unauthorized response if the user is not
        /// authenticated or does not have the required claims, null otherwise</returns>
        public static Func<NancyContext, Response> RequiresClaims(params Predicate<Claim>[] claims)
        {
            return ForbiddenIfNot(ctx => ctx.CurrentUser.HasClaims(claims));
        }

        /// <summary>
        /// Creates a hook to be used in a pipeline before a route handler to ensure
        /// that the request was made by an authenticated user having at least one of
        /// the required claims.
        /// </summary>
        /// <param name="claims">Claims the authenticated user needs to have at least one of</param>
        /// <returns>Hook that returns an Unauthorized response if the user is not
        /// authenticated or does not have at least one of the required claims, null
        /// otherwise</returns>
        public static Func<NancyContext, Response> RequiresAnyClaim(params Predicate<Claim>[] claims)
        {
            return ForbiddenIfNot(ctx => ctx.CurrentUser.HasAnyClaim(claims));
        }

        /// <summary>
        /// Creates a hook to be used in a pipeline before a route handler to ensure
        /// that the request was made by an authenticated user whose claims satisfy the
        /// supplied validation function.
        /// </summary>
        /// <param name="isValid">Validation function to be called with the authenticated
        /// users claims</param>
        /// <returns>Hook that returns an Unauthorized response if the user is not
        /// authenticated or does not pass the supplied validation function, null
        /// otherwise</returns>
        public static Func<NancyContext, Response> RequiresValidatedClaims(Func<IEnumerable<Claim>, bool> isValid)
        {
            return ForbiddenIfNot(ctx => ctx.CurrentUser.HasValidClaims(isValid));
        }

        /// <summary>
        /// Creates a hook to be used in a pipeline before a route handler to ensure that
        /// the request satisfies a specific test.
        /// </summary>
        /// <param name="test">Test that must return true for the request to continue</param>
        /// <returns>Hook that returns an Unauthorized response if the test fails, null otherwise</returns>
        private static Func<NancyContext, Response> UnauthorizedIfNot(Func<NancyContext, bool> test)
        {
            return HttpStatusCodeIfNot(HttpStatusCode.Unauthorized, test);
        }

        /// <summary>
        /// Creates a hook to be used in a pipeline before a route handler to ensure that
        /// the request satisfies a specific test.
        /// </summary>
        /// <param name="test">Test that must return true for the request to continue</param>
        /// <returns>Hook that returns an Forbidden response if the test fails, null otherwise</returns>
        private static Func<NancyContext, Response> ForbiddenIfNot(Func<NancyContext, bool> test)
        {
            return HttpStatusCodeIfNot(HttpStatusCode.Forbidden, test);
        }

        /// <summary>
        /// Creates a hook to be used in a pipeline before a route handler to ensure that
        /// the request satisfies a specific test.
        /// </summary>
        /// <param name="statusCode">HttpStatusCode to use for the response</param>
        /// <param name="test">Test that must return true for the request to continue</param>
        /// <returns>Hook that returns a response with a specific HttpStatusCode if the test fails, null otherwise</returns>
        private static Func<NancyContext, Response> HttpStatusCodeIfNot(HttpStatusCode statusCode, Func<NancyContext, bool> test)
        {
            return (ctx) =>
            {
                Response response = null;
                if (!test(ctx))
                {
                    response = new Response { StatusCode = statusCode };
                }

                return response;
            };
        }

        /// <summary>
        /// Creates a hook to be used in a pipeline before a route handler to ensure that
        /// the resource is served over HTTPS
        /// </summary>
        /// <param name="redirect"><see langword="true"/> if the user should be redirected to HTTPS (no port number) if the incoming request was made using HTTP, otherwise <see langword="false"/> if <see cref="HttpStatusCode.Forbidden"/> should be returned.</param>
        /// <param name="httpsPort">The HTTPS port number to use</param>
        /// <returns>Hook that returns a <see cref="RedirectResponse"/> with the Url scheme set to HTTPS,
        /// or a <see cref="Response"/> with a <see cref="HttpStatusCode.Forbidden"/> status code if <c>redirect</c> is false or the method is not GET,
        /// null otherwise</returns>
        public static Func<NancyContext, Response> RequiresHttps(bool redirect, int? httpsPort = null)
        {
            return (ctx) =>
            {
                Response response = null;
                var request = ctx.Request;
                if (!request.Url.IsSecure)
                {
                    if (redirect && request.Method.Equals("GET", StringComparison.OrdinalIgnoreCase))
                    {
                        var redirectUrl = request.Url.Clone();
                        redirectUrl.Port = httpsPort;
                        redirectUrl.Scheme = "https";
                        response = new RedirectResponse(redirectUrl.ToString());
                    }
                    else
                    {
                        response = new Response { StatusCode = HttpStatusCode.Forbidden };
                    }
                }

                return response;
            };
        }
    }
}
namespace Nancy.Security
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Security.Claims;

    /// <summary>
    /// Extension methods for working with IUserIdentity.
    /// </summary>
    public static class ClaimsPrincipalExtensions
    {
        /// <summary>
        /// Tests if the user is authenticated.
        /// </summary>
        /// <param name="user">User to be verified</param>
        /// <returns>True if the user is authenticated, false otherwise</returns>
        public static bool IsAuthenticated(this ClaimsPrincipal user)
        {
            return user != null && user.Identity != null && user.Identity.IsAuthenticated;
        }

        /// <summary>
        /// Tests if the user has all of the required claims.
        /// </summary>
        /// <param name="user">User to be verified</param>
        /// <param name="requiredClaims">Claims the user needs to have</param>
        /// <returns>True if the user has all of the required claims, false otherwise</returns>
        public static bool HasClaims(this ClaimsPrincipal user, params Predicate<Claim>[] requiredClaims)
        {
            return user != null && requiredClaims.All(user.HasClaim);
        }

        /// <summary>
        /// Tests if the user has at least one of the required claims.
        /// </summary>
        /// <param name="user">User to be verified</param>
        /// <param name="requiredClaims">Claims the user needs to have at least one of</param>
        /// <returns>True if the user has at least one of the required claims, false otherwise</returns>
        public static bool HasAnyClaim(this ClaimsPrincipal user, params Predicate<Claim>[] requiredClaims)
        {
            return user != null && requiredClaims.Any(user.HasClaim);
        }

        /// <summary>
        /// Tests if the user has claims that satisfy the supplied validation function.
        /// </summary>
        /// <param name="user">User to be verified</param>
        /// <param name="isValid">Validation function to be called with the authenticated
        /// users claims</param>
        /// <returns>True if the user does pass the supplied validation function, false otherwise</returns>
        public static bool HasValidClaims(this ClaimsPrincipal user, Func<IEnumerable<Claim>, bool> isValid)
        {
            return
                user != null
                && user.Claims != null
                && isValid(user.Claims);
        }
    }
}
namespace Nancy.Session
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    using Nancy.Bootstrapper;
    using Nancy.Cookies;
    using Nancy.Cryptography;
    using Nancy.Helpers;

    /// <summary>
    /// Cookie based session storage
    /// </summary>
    public class CookieBasedSessions : IObjectSerializerSelector
    {
        private readonly CookieBasedSessionsConfiguration currentConfiguration;

        /// <summary>
        /// Gets the cookie name that the session is stored in
        /// </summary>
        /// <value>Cookie name</value>
        public string CookieName
        {
            get
            {
                return this.currentConfiguration.CookieName;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CookieBasedSessions"/> class.
        /// </summary>
        /// <param name="encryptionProvider">The encryption provider.</param>
        /// <param name="hmacProvider">The hmac provider</param>
        /// <param name="objectSerializer">Session object serializer to use</param>
        public CookieBasedSessions(IEncryptionProvider encryptionProvider, IHmacProvider hmacProvider, IObjectSerializer objectSerializer)
        {
            this.currentConfiguration = new CookieBasedSessionsConfiguration
            {
                Serializer = objectSerializer,
                CryptographyConfiguration = new CryptographyConfiguration(encryptionProvider, hmacProvider)
            };
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CookieBasedSessions"/> class.
        /// </summary>
        /// <param name="configuration">Cookie based sessions configuration.</param>
        public CookieBasedSessions(CookieBasedSessionsConfiguration configuration)
        {
            if (configuration == null)
            {
                throw new ArgumentNullException("configuration");
            }

            if (!configuration.IsValid)
            {
                throw new ArgumentException("Configuration is invalid", "configuration");
            }
            this.currentConfiguration = configuration;
        }



        /// <summary>
        /// Initialise and add cookie based session hooks to the application pipeline
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        /// <param name="configuration">Cookie based sessions configuration.</param>
        /// <returns>Formatter selector for choosing a non-default serializer</returns>
        public static IObjectSerializerSelector Enable(IPipelines pipelines, CookieBasedSessionsConfiguration configuration)
        {
            if (pipelines == null)
            {
                throw new ArgumentNullException("pipelines");
            }

            var sessionStore = new CookieBasedSessions(configuration);

            pipelines.BeforeRequest.AddItemToStartOfPipeline(ctx => LoadSession(ctx, sessionStore));
            pipelines.AfterRequest.AddItemToEndOfPipeline(ctx => SaveSession(ctx, sessionStore));

            return sessionStore;
        }

        /// <summary>
        /// Initialise and add cookie based session hooks to the application pipeline
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        /// <param name="cryptographyConfiguration">Cryptography configuration</param>
        /// <returns>Formatter selector for choosing a non-default serializer</returns>
        public static IObjectSerializerSelector Enable(IPipelines pipelines, CryptographyConfiguration cryptographyConfiguration)
        {
            var cookieBasedSessionsConfiguration = new CookieBasedSessionsConfiguration(cryptographyConfiguration)
            {
                Serializer = new DefaultObjectSerializer()
            };
            return Enable(pipelines, cookieBasedSessionsConfiguration);
        }

        /// <summary>
        /// Initialise and add cookie based session hooks to the application pipeline with the default encryption provider.
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        /// <returns>Formatter selector for choosing a non-default serializer</returns>
        public static IObjectSerializerSelector Enable(IPipelines pipelines)
        {
            return Enable(pipelines, new CookieBasedSessionsConfiguration
            {
                Serializer = new DefaultObjectSerializer()
            });
        }

        /// <summary>
        /// Using the specified serializer
        /// </summary>
        /// <param name="newSerializer">Formatter to use</param>
        public void WithSerializer(IObjectSerializer newSerializer)
        {
            this.currentConfiguration.Serializer = newSerializer;
        }

        /// <summary>
        /// Save the session into the response
        /// </summary>
        /// <param name="session">Session to save</param>
        /// <param name="response">Response to save into</param>
        public void Save(ISession session, Response response)
        {
            if (session == null || !session.HasChanged)
            {
                return;
            }

            var sb = new StringBuilder();
            foreach (var kvp in session)
            {
                sb.Append(HttpUtility.UrlEncode(kvp.Key));
                sb.Append("=");

                var objectString = this.currentConfiguration.Serializer.Serialize(kvp.Value);

                sb.Append(HttpUtility.UrlEncode(objectString));
                sb.Append(";");
            }

            var cryptographyConfiguration = this.currentConfiguration.CryptographyConfiguration;
            var encryptedData = cryptographyConfiguration.EncryptionProvider.Encrypt(sb.ToString());
            var hmacBytes = cryptographyConfiguration.HmacProvider.GenerateHmac(encryptedData);
            var cookieData = HttpUtility.UrlEncode(String.Format("{0}{1}", Convert.ToBase64String(hmacBytes), encryptedData));

            var cookie = new NancyCookie(this.currentConfiguration.CookieName, cookieData, true)
            {
                Domain = this.currentConfiguration.Domain,
                Path = this.currentConfiguration.Path
            };
            response.WithCookie(cookie);
        }

        /// <summary>
        /// Loads the session from the request
        /// </summary>
        /// <param name="request">Request to load from</param>
        /// <returns>ISession containing the load session values</returns>
        public ISession Load(Request request)
        {
            var dictionary = new Dictionary<string, object>();

            var cookieName = this.currentConfiguration.CookieName;
            var hmacProvider = this.currentConfiguration.CryptographyConfiguration.HmacProvider;
            var encryptionProvider = this.currentConfiguration.CryptographyConfiguration.EncryptionProvider;

            if (request.Cookies.ContainsKey(cookieName))
            {
                var cookieData = HttpUtility.UrlDecode(request.Cookies[cookieName]);
                var hmacLength = Base64Helpers.GetBase64Length(hmacProvider.HmacLength);
                if (cookieData.Length < hmacLength)
                {
                    return new Session(dictionary);
                }

                var hmacString = cookieData.Substring(0, hmacLength);
                var encryptedCookie = cookieData.Substring(hmacLength);

                var hmacBytes = Convert.FromBase64String(hmacString);
                var newHmac = hmacProvider.GenerateHmac(encryptedCookie);
                var hmacValid = HmacComparer.Compare(newHmac, hmacBytes, hmacProvider.HmacLength);

                var data = encryptionProvider.Decrypt(encryptedCookie);
                var parts = data.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var part in parts.Select(part => part.Split('=')).Where(part => part.Length == 2))
                {
                    var valueObject = this.currentConfiguration.Serializer.Deserialize(HttpUtility.UrlDecode(part[1]));

                    dictionary[HttpUtility.UrlDecode(part[0])] = valueObject;
                }

                if (!hmacValid)
                {
                    dictionary.Clear();
                }
            }

            return new Session(dictionary);
        }

        /// <summary>
        /// Saves the request session into the response
        /// </summary>
        /// <param name="context">Nancy context</param>
        /// <param name="sessionStore">Session store</param>
        private static void SaveSession(NancyContext context, CookieBasedSessions sessionStore)
        {
            sessionStore.Save(context.Request.Session, context.Response);
        }

        /// <summary>
        /// Loads the request session
        /// </summary>
        /// <param name="context">Nancy context</param>
        /// <param name="sessionStore">Session store</param>
        /// <returns>Always returns null</returns>
        private static Response LoadSession(NancyContext context, CookieBasedSessions sessionStore)
        {
            if (context.Request == null)
            {
                return null;
            }

            context.Request.Session = sessionStore.Load(context.Request);

            return null;
        }
    }
}
namespace Nancy.Cryptography
{
    using System;
    using System.Security.Cryptography;
    using System.Text;

    /// <summary>
    /// Default encryption provider using Rijndael
    /// </summary>
    public class RijndaelEncryptionProvider : IEncryptionProvider
    {
        private readonly byte[] key;

        private readonly byte[] iv;

        /// <summary>
        /// Creates a new instance of the RijndaelEncryptionProvider class
        /// </summary>
        /// <param name="keyGenerator">Key generator to use to generate the key and iv</param>
        public RijndaelEncryptionProvider(IKeyGenerator keyGenerator)
        {
            this.key = keyGenerator.GetBytes(32);
            this.iv = keyGenerator.GetBytes(16);
        }

        /// <summary>
        /// Encrypt data
        /// </summary>
        /// <param name="data">Data to encrypt</param>
        /// <returns>Encrypted string</returns>
        public string Encrypt(string data)
        {
            using (var provider = new RijndaelManaged())
            using (var encryptor = provider.CreateEncryptor(this.key, this.iv))
            {
                var input = Encoding.UTF8.GetBytes(data);
                var output = encryptor.TransformFinalBlock(input, 0, input.Length);

                return Convert.ToBase64String(output);
            }
        }

        /// <summary>
        /// Decrypt string
        /// </summary>
        /// <param name="data">Data to decrypt</param>
        /// <returns>Decrypted string</returns>
        public string Decrypt(string data)
        {
            try
            {
                using (var provider = new RijndaelManaged())
                using (var decryptor = provider.CreateDecryptor(this.key, this.iv))
                {
                    var input = Convert.FromBase64String(data);
                    var output = decryptor.TransformFinalBlock(input, 0, input.Length);

                    return Encoding.UTF8.GetString(output);
                }
            }
            catch (FormatException)
            {
                return String.Empty;
            }
            catch (CryptographicException)
            {
                return String.Empty;
            }
        }
    }
}
namespace Nancy
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;

    public class DefaultObjectSerializer : IObjectSerializer
    {
        /// <summary>
        /// Serialize an object
        /// </summary>
        /// <param name="sourceObject">Source object</param>
        /// <returns>Serialised object string</returns>
        public string Serialize(object sourceObject)
        {
            if (sourceObject == null)
            {
                return String.Empty;
            }

            var formatter = new BinaryFormatter();

            using (var outputStream = new MemoryStream())
            {
                formatter.Serialize(outputStream, sourceObject);

                var outputBytes = outputStream.GetBuffer();

                return Convert.ToBase64String(outputBytes, 0, (int)outputStream.Length);
            }
        }

        /// <summary>
        /// Deserialize an object string
        /// </summary>
        /// <param name="sourceString">Source object string</param>
        /// <returns>Deserialized object</returns>
        public object Deserialize(string sourceString)
        {
            if (string.IsNullOrEmpty(sourceString))
            {
                return null;
            }

            try
            {
                var inputBytes = Convert.FromBase64String(sourceString);

                var formatter = new BinaryFormatter();

                using (var inputStream = new MemoryStream(inputBytes, false))
                {
                    return formatter.Deserialize(inputStream);
                }
            }
            catch (FormatException)
            {
                return null;
            }
            catch (SerializationException)
            {
                return null;
            }
            catch (IOException)
            {
                return null;
            }
        }
    }
}
namespace Nancy.Cryptography
{
    /// <summary>
    /// Provides symmetrical encryption support
    /// </summary>
    public interface IEncryptionProvider
    {
        /// <summary>
        /// Encrypt and base64 encode the string
        /// </summary>
        /// <param name="data">Data to encrypt</param>
        /// <returns>Encrypted string</returns>
        string Encrypt(string data);

        /// <summary>
        /// Decrypt string
        /// </summary>
        /// <param name="data">Data to decrypt</param>
        /// <returns>Decrypted string</returns>
        string Decrypt(string data);
    }
}
namespace Nancy
{
    /// <summary>
    /// Allows setting of the serializer for session object storage
    /// </summary>
    public interface IObjectSerializerSelector : IHideObjectMembers
    {
        /// <summary>
        /// Using the specified serializer
        /// </summary>
        /// <param name="newSerializer">Serializer to use</param>
        void WithSerializer(IObjectSerializer newSerializer);
    }
}
namespace Nancy.Session
{
    using System.Collections.Generic;

    /// <summary>
    /// Defines the interface for a session
    /// </summary>
    public interface ISession : IEnumerable<KeyValuePair<string, object>>
    {
        /// <summary>
        /// The number of session values
        /// </summary>
        /// <returns></returns>
        int Count { get; }

        /// <summary>
        /// Deletes the session and all associated information
        /// </summary>
        void DeleteAll();

        /// <summary>
        /// Deletes the specific key from the session
        /// </summary>
        void Delete(string key);

        /// <summary>
        /// Retrieves the value from the session
        /// </summary>
        object this[string key] { get; set; }

        bool HasChanged { get; }
    }
}
namespace Nancy
{
    /// <summary>
    /// De/Serialisation for cookie objects
    /// </summary>
    public interface IObjectSerializer
    {
        /// <summary>
        /// Serialize an object
        /// </summary>
        /// <param name="sourceObject">Source object</param>
        /// <returns>Serialised object string</returns>
        string Serialize(object sourceObject);

        /// <summary>
        /// Deserialize an object string
        /// </summary>
        /// <param name="sourceString">Source object string</param>
        /// <returns>Deserialized object</returns>
        object Deserialize(string sourceString);
    }
}
namespace Nancy.Session
{
    using System;
    using System.Collections;
    using System.Collections.Generic;

    public class NullSessionProvider : ISession
    {
        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>1</filterpriority>
        public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
        {
            throw new InvalidOperationException("Session support is not enabled.");
        }

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// The number of session values
        /// </summary>
        /// <returns></returns>
        public int Count
        {
            get
            {
                throw new InvalidOperationException("Session support is not enabled.");
            }
        }

        /// <summary>
        /// Deletes the session and all associated information
        /// </summary>
        public void DeleteAll()
        {
            throw new InvalidOperationException("Session support is not enabled.");
        }

        /// <summary>
        /// Deletes the specific key from the session
        /// </summary>
        public void Delete(string key)
        {
            throw new InvalidOperationException("Session support is not enabled.");
        }

        /// <summary>
        /// Retrieves the value from the session
        /// </summary>
        public object this[string key]
        {
            get
            {
                throw new InvalidOperationException("Session support is not enabled.");
            }

            set
            {
                throw new InvalidOperationException("Session support is not enabled.");
            }
        }

        public bool HasChanged
        {
            get
            {
                return false;
            }
        }
    }
}
namespace Nancy.Session
{
    using System;
    using System.Collections;
    using System.Collections.Generic;

    /// <summary>
    /// Session implementation
    /// </summary>
    public class Session : ISession
    {
        private readonly IDictionary<string, object> dictionary;
        private bool hasChanged;

        public Session() : this(new Dictionary<string, object>(0)) { }
        public Session(IDictionary<string, object> dictionary)
        {
            this.dictionary = dictionary;
        }

        /// <summary>
        /// Gets the number of items stored
        /// </summary>
        public int Count
        {
            get { return dictionary.Count; }
        }

        /// <summary>
        /// Deletes all items
        /// </summary>
        public void DeleteAll()
        {
            if (Count > 0)
            {
                MarkAsChanged();
            }

            dictionary.Clear();
        }

        /// <summary>
        /// Delete an item with the given key
        /// </summary>
        /// <param name="key">Key to delete</param>
        public void Delete(string key)
        {
            if (dictionary.Remove(key)) { MarkAsChanged(); }
        }

        /// <summary>
        /// Gets or sets values
        /// </summary>
        /// <param name="key">The key whos value to get or set</param>
        /// <returns>The value, or null or the key didn't exist</returns>
        public object this[string key]
        {
            get { return dictionary.ContainsKey(key) ? dictionary[key] : null; }
            set
            {
                var existingValue = this[key] ?? new Object();

                if (existingValue.Equals(value))
                {
                    return;
                }

                dictionary[key] = value;
                MarkAsChanged();
            }
        }

        /// <summary>
        /// Gets whether the session has changed
        /// </summary>
        public bool HasChanged
        {
            get { return this.hasChanged; }
        }

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>1</filterpriority>
        public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
        {
            return dictionary.GetEnumerator();
        }

        private void MarkAsChanged()
        {
            hasChanged = true;
        }
    }
}
namespace Nancy
{
    using System;
    using System.IO;

    /// <summary>
    /// A decorator stream that sits on top of an existing stream and appears as a unique stream.
    /// </summary>
    public class HttpMultipartSubStream : Stream
    {
        private readonly Stream stream;
        private long start;
        private readonly long end;
        private long position;

        /// <summary>
        /// Initializes a new instance of the <see cref="HttpMultipartSubStream"/> class.
        /// </summary>
        /// <param name="stream">The stream to create the sub-stream ontop of.</param>
        /// <param name="start">The start offset on the parent stream where the sub-stream should begin.</param>
        /// <param name="end">The end offset on the parent stream where the sub-stream should end.</param>
        public HttpMultipartSubStream(Stream stream, long start, long end)
        {
            this.stream = stream;
            this.start = start;
            this.position = start;
            this.end = end;
        }

        /// <summary>
        /// When overridden in a derived class, gets a value indicating whether the current stream supports reading.
        /// </summary>
        /// <returns><see langword="true"/> if the stream supports reading; otherwise, <see langword="false"/>.</returns>
        public override bool CanRead
        {
            get { return true; }
        }

        /// <summary>
        /// When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
        /// </summary>
        /// <returns><see langword="true"/> if the stream supports seeking; otherwise, <see langword="false"/>.</returns>
        public override bool CanSeek
        {
            get { return true; }
        }

        /// <summary>
        /// When overridden in a derived class, gets a value indicating whether the current stream supports writing.
        /// </summary>
        /// <returns><see langword="true"/> if the stream supports writing; otherwise, <see langword="false"/>.</returns>
        public override bool CanWrite
        {
            get { return false; }
        }

        /// <summary>
        /// When overridden in a derived class, gets the length in bytes of the stream.
        /// </summary>
        /// <returns>A long value representing the length of the stream in bytes.</returns>
        /// <exception cref="NotSupportedException">A class derived from Stream does not support seeking. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        public override long Length
        {
            get { return (this.end - this.start); }
        }

        /// <summary>
        /// When overridden in a derived class, gets or sets the position within the current stream.
        /// </summary>
        /// <returns>
        /// The current position within the stream.
        /// </returns>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        public override long Position
        {
            get { return this.position - this.start; }
            set { this.position = this.Seek(value, SeekOrigin.Begin); }
        }

        private long CalculateSubStreamRelativePosition(SeekOrigin origin, long offset)
        {
            var subStreamRelativePosition = 0L;

            switch (origin)
            {
                case SeekOrigin.Begin:
                    subStreamRelativePosition = this.start + offset;
                    break;

                case SeekOrigin.Current:
                    subStreamRelativePosition = this.position + offset;
                    break;

                case SeekOrigin.End:
                    subStreamRelativePosition = this.end + offset;
                    break;
            }
            return subStreamRelativePosition;
        }

        public void PositionStartAtCurrentLocation()
        {
            this.start = this.stream.Position;
        }

        /// <summary>
        /// When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
        /// </summary>
        /// <remarks>In the <see cref="HttpMultipartSubStream"/> type this method is implemented as no-op.</remarks>
        public override void Flush()
        {
        }

        /// <summary>
        /// When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
        /// </summary>
        /// <returns>The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached. </returns>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source. </param>
        /// <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream. </param>
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (count > (this.end - this.position))
            {
                count = (int)(this.end - this.position);
            }

            if (count <= 0)
            {
                return 0;
            }

            this.stream.Position = this.position;

            var bytesReadFromStream =
                this.stream.Read(buffer, offset, count);

            this.RepositionAfterRead(bytesReadFromStream);

            return bytesReadFromStream;
        }

        /// <summary>
        /// Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
        /// </summary>
        /// <returns>The unsigned byte cast to an Int32, or -1 if at the end of the stream.</returns>
        public override int ReadByte()
        {
            if (this.position >= this.end)
            {
                return -1;
            }

            this.stream.Position = this.position;

            var byteReadFromStream = this.stream.ReadByte();

            this.RepositionAfterRead(1);

            return byteReadFromStream;
        }

        private void RepositionAfterRead(int bytesReadFromStream)
        {
            if (bytesReadFromStream == -1)
            {
                this.position = this.end;
            }
            else
            {
                this.position += bytesReadFromStream;
            }
        }

        /// <summary>
        /// When overridden in a derived class, sets the position within the current stream.
        /// </summary>
        /// <returns>The new position within the current stream.</returns>
        /// <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter.</param>
        /// <param name="origin">A value of type <see cref="SeekOrigin"/> indicating the reference point used to obtain the new position.</param>
        public override long Seek(long offset, SeekOrigin origin)
        {
            var subStreamRelativePosition =
                this.CalculateSubStreamRelativePosition(origin, offset);

            this.ThrowExceptionIsPositionIsOutOfBounds(subStreamRelativePosition);

            this.position = this.stream.Seek(subStreamRelativePosition, SeekOrigin.Begin);

            return this.position;
        }

        /// <summary>
        /// When overridden in a derived class, sets the length of the current stream.
        /// </summary>
        /// <param name="value">The desired length of the current stream in bytes.</param>
        /// <remarks>This will always throw a <see cref="InvalidOperationException"/> for the <see cref="HttpMultipartSubStream"/> type.</remarks>
        public override void SetLength(long value)
        {
            throw new InvalidOperationException();
        }

        /// <summary>
        /// When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream. </param>
        /// <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream. </param>
        /// <param name="count">The number of bytes to be written to the current stream. </param>
        /// <remarks>This will always throw a <see cref="InvalidOperationException"/> for the <see cref="HttpMultipartSubStream"/> type.</remarks>
        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new InvalidOperationException();
        }

        private void ThrowExceptionIsPositionIsOutOfBounds(long subStreamRelativePosition)
        {
            if (subStreamRelativePosition < 0 || subStreamRelativePosition > this.end)
                throw new InvalidOperationException();
        }
    }
}//===============================================================================
// TinyIoC
//
// An easy to use, hassle free, Inversion of Control Container for small projects
// and beginners alike.
//
// https://github.com/grumpydev/TinyIoC
//===============================================================================
// Copyright © Steven Robbins.  All rights reserved.
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY
// OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE.
//===============================================================================

#region Preprocessor Directives
// Uncomment this line if you want the container to automatically
// register the TinyMessenger messenger/event aggregator
//#define TINYMESSENGER

// Preprocessor directives for enabling/disabling functionality
// depending on platform features. If the platform has an appropriate
// #DEFINE then these should be set automatically below.
#define EXPRESSIONS                         // Platform supports System.Linq.Expressions
#define COMPILED_EXPRESSIONS                // Platform supports compiling expressions
#define APPDOMAIN_GETASSEMBLIES             // Platform supports getting all assemblies from the AppDomain object
#define UNBOUND_GENERICS_GETCONSTRUCTORS    // Platform supports GetConstructors on unbound generic types
#define GETPARAMETERS_OPEN_GENERICS         // Platform supports GetParameters on open generics
#define RESOLVE_OPEN_GENERICS               // Platform supports resolving open generics
#define READER_WRITER_LOCK_SLIM             // Platform supports ReaderWriterLockSlim

//// NETFX_CORE
//#if NETFX_CORE
//#endif

// CompactFramework / Windows Phone 7
// By default does not support System.Linq.Expressions.
// AppDomain object does not support enumerating all assemblies in the app domain.
#if PocketPC || WINDOWS_PHONE
#undef EXPRESSIONS
#undef COMPILED_EXPRESSIONS
#undef APPDOMAIN_GETASSEMBLIES
#undef UNBOUND_GENERICS_GETCONSTRUCTORS
#endif

// PocketPC has a bizarre limitation on enumerating parameters on unbound generic methods.
// We need to use a slower workaround in that case.
#if PocketPC
#undef GETPARAMETERS_OPEN_GENERICS
#undef RESOLVE_OPEN_GENERICS
#undef READER_WRITER_LOCK_SLIM
#endif

#if SILVERLIGHT
#undef APPDOMAIN_GETASSEMBLIES
#endif

#if NETFX_CORE
#undef APPDOMAIN_GETASSEMBLIES
#undef RESOLVE_OPEN_GENERICS
#endif

#if COMPILED_EXPRESSIONS
#define USE_OBJECT_CONSTRUCTOR
#endif

#endregion
namespace Nancy.TinyIoc
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Reflection;
#if EXPRESSIONS
    using System.Linq.Expressions;
    using System.Threading;

#endif

#if NETFX_CORE
	using System.Threading.Tasks;
	using Windows.Storage.Search;
    using Windows.Storage;
	using Windows.UI.Xaml.Shapes;
#endif

    #region SafeDictionary
#if READER_WRITER_LOCK_SLIM
    public class SafeDictionary<TKey, TValue> : IDisposable
    {
        private readonly ReaderWriterLockSlim _padlock = new ReaderWriterLockSlim();
        private readonly Dictionary<TKey, TValue> _Dictionary = new Dictionary<TKey, TValue>();

        public TValue this[TKey key]
        {
            set
            {
                _padlock.EnterWriteLock();

                try
                {
                    TValue current;
                    if (_Dictionary.TryGetValue(key, out current))
                    {
                        var disposable = current as IDisposable;

                        if (disposable != null)
                            disposable.Dispose();
                    }

                    _Dictionary[key] = value;
                }
                finally
                {
                    _padlock.ExitWriteLock();
                }
            }
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            _padlock.EnterReadLock();
            try
            {
                return _Dictionary.TryGetValue(key, out value);
            }
            finally
            {
                _padlock.ExitReadLock();
            }
        }

        public bool Remove(TKey key)
        {
            _padlock.EnterWriteLock();
            try
            {
                return _Dictionary.Remove(key);
            }
            finally
            {
                _padlock.ExitWriteLock();
            }
        }

        public void Clear()
        {
            _padlock.EnterWriteLock();
            try
            {
                _Dictionary.Clear();
            }
            finally
            {
                _padlock.ExitWriteLock();
            }
        }

        public IEnumerable<TKey> Keys
        {
            get
            {
                _padlock.EnterReadLock();
                try
                {
                    return new List<TKey>(_Dictionary.Keys);
                }
                finally
                {
                    _padlock.ExitReadLock();
                }
            }
        }

        #region IDisposable Members

        public void Dispose()
        {
            _padlock.EnterWriteLock();

            try
            {
                var disposableItems = from item in _Dictionary.Values
                                      where item is IDisposable
                                      select item as IDisposable;

                foreach (var item in disposableItems)
                {
                    item.Dispose();
                }
            }
            finally
            {
                _padlock.ExitWriteLock();
            }

            GC.SuppressFinalize(this);
        }

        #endregion
    }
#else
    public class SafeDictionary<TKey, TValue> : IDisposable
    {
        private readonly object _Padlock = new object();
        private readonly Dictionary<TKey, TValue> _Dictionary = new Dictionary<TKey, TValue>();

        public TValue this[TKey key]
        {
            set
            {
                lock (_Padlock)
                {
                    TValue current;
                    if (_Dictionary.TryGetValue(key, out current))
                    {
                        var disposable = current as IDisposable;

                        if (disposable != null)
                            disposable.Dispose();
                    }

                    _Dictionary[key] = value;
                }
            }
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            lock (_Padlock)
            {
                return _Dictionary.TryGetValue(key, out value);
            }
        }

        public bool Remove(TKey key)
        {
            lock (_Padlock)
            {
                return _Dictionary.Remove(key);
            }
        }

        public void Clear()
        {
            lock (_Padlock)
            {
                _Dictionary.Clear();
            }
        }

        public IEnumerable<TKey> Keys
        {
            get
            {
                return _Dictionary.Keys;
            }
        }
    #region IDisposable Members

        public void Dispose()
        {
            lock (_Padlock)
            {
                var disposableItems = from item in _Dictionary.Values
                                      where item is IDisposable
                                      select item as IDisposable;

                foreach (var item in disposableItems)
                {
                    item.Dispose();
                }
            }

            GC.SuppressFinalize(this);
        }

    #endregion
    }
#endif
    #endregion

    #region Extensions
    public static class AssemblyExtensions
    {
        public static Type[] SafeGetTypes(this Assembly assembly)
        {
            Type[] assemblies;

            try
            {
                assemblies = assembly.GetTypes();
            }
            catch (FileNotFoundException)
            {
                assemblies = ArrayCache.Empty<Type>();
            }
            catch (NotSupportedException)
            {
                assemblies = ArrayCache.Empty<Type>();
            }
#if !NETFX_CORE
            catch (ReflectionTypeLoadException e)
            {
                assemblies = e.Types.Where(t => t != null).ToArray();
            }
#endif
            return assemblies;
        }
    }

    public static class TypeExtensions
    {
        private static SafeDictionary<GenericMethodCacheKey, MethodInfo> _genericMethodCache;

        static TypeExtensions()
        {
            _genericMethodCache = new SafeDictionary<GenericMethodCacheKey, MethodInfo>();
        }

        //#if NETFX_CORE
        //		/// <summary>
        //		/// Gets a generic method from a type given the method name, generic types and parameter types
        //		/// </summary>
        //		/// <param name="sourceType">Source type</param>
        //		/// <param name="methodName">Name of the method</param>
        //		/// <param name="genericTypes">Generic types to use to make the method generic</param>
        //		/// <param name="parameterTypes">Method parameters</param>
        //		/// <returns>MethodInfo or null if no matches found</returns>
        //		/// <exception cref="System.Reflection.AmbiguousMatchException"/>
        //		/// <exception cref="System.ArgumentException"/>
        //		public static MethodInfo GetGenericMethod(this Type sourceType, string methodName, Type[] genericTypes, Type[] parameterTypes)
        //		{
        //			MethodInfo method;
        //			var cacheKey = new GenericMethodCacheKey(sourceType, methodName, genericTypes, parameterTypes);

        //			// Shouldn't need any additional locking
        //			// we don't care if we do the method info generation
        //			// more than once before it gets cached.
        //			if (!_genericMethodCache.TryGetValue(cacheKey, out method))
        //			{
        //				method = GetMethod(sourceType, methodName, genericTypes, parameterTypes);
        //				_genericMethodCache[cacheKey] = method;
        //			}

        //			return method;
        //		}
        //#else
        /// <summary>
        /// Gets a generic method from a type given the method name, binding flags, generic types and parameter types
        /// </summary>
        /// <param name="sourceType">Source type</param>
        /// <param name="bindingFlags">Binding flags</param>
        /// <param name="methodName">Name of the method</param>
        /// <param name="genericTypes">Generic types to use to make the method generic</param>
        /// <param name="parameterTypes">Method parameters</param>
        /// <returns>MethodInfo or null if no matches found</returns>
        /// <exception cref="System.Reflection.AmbiguousMatchException"/>
        /// <exception cref="System.ArgumentException"/>
        public static MethodInfo GetGenericMethod(this Type sourceType, BindingFlags bindingFlags, string methodName, Type[] genericTypes, Type[] parameterTypes)
        {
            MethodInfo method;
            var cacheKey = new GenericMethodCacheKey(sourceType, methodName, genericTypes, parameterTypes);

            // Shouldn't need any additional locking
            // we don't care if we do the method info generation
            // more than once before it gets cached.
            if (!_genericMethodCache.TryGetValue(cacheKey, out method))
            {
                method = GetMethod(sourceType, bindingFlags, methodName, genericTypes, parameterTypes);
                _genericMethodCache[cacheKey] = method;
            }

            return method;
        }
        //#endif

#if NETFX_CORE
        private static MethodInfo GetMethod(Type sourceType, BindingFlags flags, string methodName, Type[] genericTypes, Type[] parameterTypes)
        {
            var methods =
                sourceType.GetMethods(flags).Where(
                    mi => string.Equals(methodName, mi.Name, StringComparison.Ordinal)).Where(
                        mi => mi.ContainsGenericParameters).Where(mi => mi.GetGenericArguments().Length == genericTypes.Length).
                    Where(mi => mi.GetParameters().Length == parameterTypes.Length).Select(
                        mi => mi.MakeGenericMethod(genericTypes)).Where(
                            mi => mi.GetParameters().Select(pi => pi.ParameterType).SequenceEqual(parameterTypes)).ToList();

            if (methods.Count > 1)
            {
                throw new AmbiguousMatchException();
            }

            return methods.FirstOrDefault();
        }
#else
        private static MethodInfo GetMethod(Type sourceType, BindingFlags bindingFlags, string methodName, Type[] genericTypes, Type[] parameterTypes)
        {
#if GETPARAMETERS_OPEN_GENERICS
            var methods =
                sourceType.GetMethods(bindingFlags).Where(
                    mi => string.Equals(methodName, mi.Name, StringComparison.Ordinal)).Where(
                        mi => mi.ContainsGenericParameters).Where(mi => mi.GetGenericArguments().Length == genericTypes.Length).
                    Where(mi => mi.GetParameters().Length == parameterTypes.Length).Select(
                        mi => mi.MakeGenericMethod(genericTypes)).Where(
                            mi => mi.GetParameters().Select(pi => pi.ParameterType).SequenceEqual(parameterTypes)).ToList();
#else
            var validMethods =  from method in sourceType.GetMethods(bindingFlags)
                                where method.Name == methodName
                                where method.IsGenericMethod
                                where method.GetGenericArguments().Length == genericTypes.Length
                                let genericMethod = method.MakeGenericMethod(genericTypes)
                                where genericMethod.GetParameters().Count() == parameterTypes.Length
                                where genericMethod.GetParameters().Select(pi => pi.ParameterType).SequenceEqual(parameterTypes)
                                select genericMethod;

            var methods = validMethods.ToList();
#endif
            if (methods.Count > 1)
            {
                throw new AmbiguousMatchException();
            }

            return methods.FirstOrDefault();
        }
#endif

        private sealed class GenericMethodCacheKey
        {
            private readonly Type _sourceType;

            private readonly string _methodName;

            private readonly Type[] _genericTypes;

            private readonly Type[] _parameterTypes;

            private readonly int _hashCode;

            public GenericMethodCacheKey(Type sourceType, string methodName, Type[] genericTypes, Type[] parameterTypes)
            {
                _sourceType = sourceType;
                _methodName = methodName;
                _genericTypes = genericTypes;
                _parameterTypes = parameterTypes;
                _hashCode = GenerateHashCode();
            }

            public override bool Equals(object obj)
            {
                var cacheKey = obj as GenericMethodCacheKey;
                if (cacheKey == null)
                    return false;

                if (_sourceType != cacheKey._sourceType)
                    return false;

                if (!String.Equals(_methodName, cacheKey._methodName, StringComparison.Ordinal))
                    return false;

                if (_genericTypes.Length != cacheKey._genericTypes.Length)
                    return false;

                if (_parameterTypes.Length != cacheKey._parameterTypes.Length)
                    return false;

                for (int i = 0; i < _genericTypes.Length; ++i)
                {
                    if (_genericTypes[i] != cacheKey._genericTypes[i])
                        return false;
                }

                for (int i = 0; i < _parameterTypes.Length; ++i)
                {
                    if (_parameterTypes[i] != cacheKey._parameterTypes[i])
                        return false;
                }

                return true;
            }

            public override int GetHashCode()
            {
                return _hashCode;
            }

            private int GenerateHashCode()
            {
                unchecked
                {
                    var result = _sourceType.GetHashCode();

                    result = (result * 397) ^ _methodName.GetHashCode();

                    for (int i = 0; i < _genericTypes.Length; ++i)
                    {
                        result = (result * 397) ^ _genericTypes[i].GetHashCode();
                    }

                    for (int i = 0; i < _parameterTypes.Length; ++i)
                    {
                        result = (result * 397) ^ _parameterTypes[i].GetHashCode();
                    }

                    return result;
                }
            }
        }

    }

    // @mbrit - 2012-05-22 - shim for ForEach call on List<T>...
#if NETFX_CORE
	internal static class ListExtender
	{
		internal static void ForEach<T>(this List<T> list, Action<T> callback)
		{
			foreach (T obj in list)
				callback(obj);
		}
	}
#endif

    #endregion

    #region TinyIoC Exception Types
    public class TinyIoCResolutionException : Exception
    {
        private const string ERROR_TEXT = "Unable to resolve type: {0}";

        public TinyIoCResolutionException(Type type)
            : base(String.Format(ERROR_TEXT, type.FullName))
        {
        }

        public TinyIoCResolutionException(Type type, Exception innerException)
            : base(String.Format(ERROR_TEXT, type.FullName), innerException)
        {
        }
    }

    public class TinyIoCRegistrationTypeException : Exception
    {
        private const string REGISTER_ERROR_TEXT = "Cannot register type {0} - abstract classes or interfaces are not valid implementation types for {1}.";

        public TinyIoCRegistrationTypeException(Type type, string factory)
            : base(String.Format(REGISTER_ERROR_TEXT, type.FullName, factory))
        {
        }

        public TinyIoCRegistrationTypeException(Type type, string factory, Exception innerException)
            : base(String.Format(REGISTER_ERROR_TEXT, type.FullName, factory), innerException)
        {
        }
    }

    public class TinyIoCRegistrationException : Exception
    {
        private const string CONVERT_ERROR_TEXT = "Cannot convert current registration of {0} to {1}";
        private const string GENERIC_CONSTRAINT_ERROR_TEXT = "Type {1} is not valid for a registration of type {0}";

        public TinyIoCRegistrationException(Type type, string method)
            : base(String.Format(CONVERT_ERROR_TEXT, type.FullName, method))
        {
        }

        public TinyIoCRegistrationException(Type type, string method, Exception innerException)
            : base(String.Format(CONVERT_ERROR_TEXT, type.FullName, method), innerException)
        {
        }

        public TinyIoCRegistrationException(Type registerType, Type implementationType)
            : base(String.Format(GENERIC_CONSTRAINT_ERROR_TEXT, registerType.FullName, implementationType.FullName))
        {
        }

        public TinyIoCRegistrationException(Type registerType, Type implementationType, Exception innerException)
            : base(String.Format(GENERIC_CONSTRAINT_ERROR_TEXT, registerType.FullName, implementationType.FullName), innerException)
        {
        }
    }

    public class TinyIoCWeakReferenceException : Exception
    {
        private const string ERROR_TEXT = "Unable to instantiate {0} - referenced object has been reclaimed";

        public TinyIoCWeakReferenceException(Type type)
            : base(String.Format(ERROR_TEXT, type.FullName))
        {
        }

        public TinyIoCWeakReferenceException(Type type, Exception innerException)
            : base(String.Format(ERROR_TEXT, type.FullName), innerException)
        {
        }
    }

    public class TinyIoCConstructorResolutionException : Exception
    {
        private const string ERROR_TEXT = "Unable to resolve constructor for {0} using provided Expression.";

        public TinyIoCConstructorResolutionException(Type type)
            : base(String.Format(ERROR_TEXT, type.FullName))
        {
        }

        public TinyIoCConstructorResolutionException(Type type, Exception innerException)
            : base(String.Format(ERROR_TEXT, type.FullName), innerException)
        {
        }

        public TinyIoCConstructorResolutionException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        public TinyIoCConstructorResolutionException(string message)
            : base(message)
        {
        }
    }

    public class TinyIoCAutoRegistrationException : Exception
    {
        private const string ERROR_TEXT = "Duplicate implementation of type {0} found ({1}).";

        public TinyIoCAutoRegistrationException(Type registerType, IEnumerable<Type> types)
            : base(String.Format(ERROR_TEXT, registerType, GetTypesString(types)))
        {
        }

        public TinyIoCAutoRegistrationException(Type registerType, IEnumerable<Type> types, Exception innerException)
            : base(String.Format(ERROR_TEXT, registerType, GetTypesString(types)), innerException)
        {
        }

        private static string GetTypesString(IEnumerable<Type> types)
        {
            var typeNames = from type in types
                            select type.FullName;

            return string.Join(",", typeNames.ToArray());
        }
    }
    #endregion

    #region Public Setup / Settings Classes
    /// <summary>
    /// Name/Value pairs for specifying "user" parameters when resolving
    /// </summary>
    public sealed class NamedParameterOverloads : Dictionary<string, object>
    {
        public static NamedParameterOverloads FromIDictionary(IDictionary<string, object> data)
        {
            return data as NamedParameterOverloads ?? new NamedParameterOverloads(data);
        }

        public NamedParameterOverloads()
        {
        }

        public NamedParameterOverloads(IDictionary<string, object> data)
            : base(data)
        {
        }

        private static readonly NamedParameterOverloads _Default = new NamedParameterOverloads();

        public static NamedParameterOverloads Default
        {
            get
            {
                return _Default;
            }
        }
    }

    public enum UnregisteredResolutionActions
    {
        /// <summary>
        /// Attempt to resolve type, even if the type isn't registered.
        /// 
        /// Registered types/options will always take precedence.
        /// </summary>
        AttemptResolve,

        /// <summary>
        /// Fail resolution if type not explicitly registered
        /// </summary>
        Fail,

        /// <summary>
        /// Attempt to resolve unregistered type if requested type is generic
        /// and no registration exists for the specific generic parameters used.
        /// 
        /// Registered types/options will always take precedence.
        /// </summary>
        GenericsOnly
    }

    public enum NamedResolutionFailureActions
    {
        AttemptUnnamedResolution,
        Fail
    }

    public enum DuplicateImplementationActions
    {
        RegisterSingle,
        RegisterMultiple,
        Fail
    }

    /// <summary>
    /// Resolution settings
    /// </summary>
    public sealed class ResolveOptions
    {
        private static readonly ResolveOptions _Default = new ResolveOptions();
        private static readonly ResolveOptions _FailUnregisteredAndNameNotFound = new ResolveOptions() { NamedResolutionFailureAction = NamedResolutionFailureActions.Fail, UnregisteredResolutionAction = UnregisteredResolutionActions.Fail };
        private static readonly ResolveOptions _FailUnregisteredOnly = new ResolveOptions() { NamedResolutionFailureAction = NamedResolutionFailureActions.AttemptUnnamedResolution, UnregisteredResolutionAction = UnregisteredResolutionActions.Fail };
        private static readonly ResolveOptions _FailNameNotFoundOnly = new ResolveOptions() { NamedResolutionFailureAction = NamedResolutionFailureActions.Fail, UnregisteredResolutionAction = UnregisteredResolutionActions.AttemptResolve };

        private UnregisteredResolutionActions _UnregisteredResolutionAction = UnregisteredResolutionActions.AttemptResolve;
        public UnregisteredResolutionActions UnregisteredResolutionAction
        {
            get { return _UnregisteredResolutionAction; }
            set { _UnregisteredResolutionAction = value; }
        }

        private NamedResolutionFailureActions _NamedResolutionFailureAction = NamedResolutionFailureActions.Fail;
        public NamedResolutionFailureActions NamedResolutionFailureAction
        {
            get { return _NamedResolutionFailureAction; }
            set { _NamedResolutionFailureAction = value; }
        }

        /// <summary>
        /// Gets the default options (attempt resolution of unregistered types, fail on named resolution if name not found)
        /// </summary>
        public static ResolveOptions Default
        {
            get
            {
                return _Default;
            }
        }

        /// <summary>
        /// Preconfigured option for attempting resolution of unregistered types and failing on named resolution if name not found
        /// </summary>
        public static ResolveOptions FailNameNotFoundOnly
        {
            get
            {
                return _FailNameNotFoundOnly;
            }
        }

        /// <summary>
        /// Preconfigured option for failing on resolving unregistered types and on named resolution if name not found
        /// </summary>
        public static ResolveOptions FailUnregisteredAndNameNotFound
        {
            get
            {
                return _FailUnregisteredAndNameNotFound;
            }
        }

        /// <summary>
        /// Preconfigured option for failing on resolving unregistered types, but attempting unnamed resolution if name not found
        /// </summary>
        public static ResolveOptions FailUnregisteredOnly
        {
            get
            {
                return _FailUnregisteredOnly;
            }
        }
    }
    #endregion

    public sealed partial class TinyIoCContainer : IDisposable
    {
        #region Fake NETFX_CORE Classes
#if NETFX_CORE
        private sealed class MethodAccessException : Exception
        {
        }

        private sealed class AppDomain
        {
            public static AppDomain CurrentDomain { get; private set; }

            static AppDomain()
            {
                CurrentDomain = new AppDomain();
            }

			// @mbrit - 2012-05-30 - in WinRT, this should be done async...
            public async Task<List<Assembly>> GetAssembliesAsync()
            {
                var folder = Windows.ApplicationModel.Package.Current.InstalledLocation;

                List<Assembly> assemblies = new List<Assembly>();

				var files = await folder.GetFilesAsync();

                foreach (StorageFile file in files)
                {
                    if (file.FileType == ".dll" || file.FileType == ".exe")
                    {
                        AssemblyName name = new AssemblyName() { Name = System.IO.Path.GetFileNameWithoutExtension(file.Name) };
						try
						{
							var asm = Assembly.Load(name);
							assemblies.Add(asm);
						}
						catch
						{
							// ignore exceptions here...
						}
                    }
                }

				return assemblies;
            }
        }
#endif
        #endregion

        #region "Fluent" API
        /// <summary>
        /// Registration options for "fluent" API
        /// </summary>
        public sealed class RegisterOptions
        {
            private TinyIoCContainer _Container;
            private TypeRegistration _Registration;

            public RegisterOptions(TinyIoCContainer container, TypeRegistration registration)
            {
                _Container = container;
                _Registration = registration;
            }

            /// <summary>
            /// Make registration a singleton (single instance) if possible
            /// </summary>
            /// <returns>RegisterOptions</returns>
            /// <exception cref="TinyIoCInstantiationTypeException"></exception>
            public RegisterOptions AsSingleton()
            {
                var currentFactory = _Container.GetCurrentFactory(_Registration);

                if (currentFactory == null)
                    throw new TinyIoCRegistrationException(_Registration.Type, "singleton");

                return _Container.AddUpdateRegistration(_Registration, currentFactory.SingletonVariant);
            }

            /// <summary>
            /// Make registration multi-instance if possible
            /// </summary>
            /// <returns>RegisterOptions</returns>
            /// <exception cref="TinyIoCInstantiationTypeException"></exception>
            public RegisterOptions AsMultiInstance()
            {
                var currentFactory = _Container.GetCurrentFactory(_Registration);

                if (currentFactory == null)
                    throw new TinyIoCRegistrationException(_Registration.Type, "multi-instance");

                return _Container.AddUpdateRegistration(_Registration, currentFactory.MultiInstanceVariant);
            }

            /// <summary>
            /// Make registration hold a weak reference if possible
            /// </summary>
            /// <returns>RegisterOptions</returns>
            /// <exception cref="TinyIoCInstantiationTypeException"></exception>
            public RegisterOptions WithWeakReference()
            {
                var currentFactory = _Container.GetCurrentFactory(_Registration);

                if (currentFactory == null)
                    throw new TinyIoCRegistrationException(_Registration.Type, "weak reference");

                return _Container.AddUpdateRegistration(_Registration, currentFactory.WeakReferenceVariant);
            }

            /// <summary>
            /// Make registration hold a strong reference if possible
            /// </summary>
            /// <returns>RegisterOptions</returns>
            /// <exception cref="TinyIoCInstantiationTypeException"></exception>
            public RegisterOptions WithStrongReference()
            {
                var currentFactory = _Container.GetCurrentFactory(_Registration);

                if (currentFactory == null)
                    throw new TinyIoCRegistrationException(_Registration.Type, "strong reference");

                return _Container.AddUpdateRegistration(_Registration, currentFactory.StrongReferenceVariant);
            }

#if EXPRESSIONS
            public RegisterOptions UsingConstructor<RegisterType>(Expression<Func<RegisterType>> constructor)
            {
                var lambda = constructor as LambdaExpression;
                if (lambda == null)
                    throw new TinyIoCConstructorResolutionException(typeof(RegisterType));

                var newExpression = lambda.Body as NewExpression;
                if (newExpression == null)
                    throw new TinyIoCConstructorResolutionException(typeof(RegisterType));

                var constructorInfo = newExpression.Constructor;
                if (constructorInfo == null)
                    throw new TinyIoCConstructorResolutionException(typeof(RegisterType));

                var currentFactory = _Container.GetCurrentFactory(_Registration);
                if (currentFactory == null)
                    throw new TinyIoCConstructorResolutionException(typeof(RegisterType));

                currentFactory.SetConstructor(constructorInfo);

                return this;
            }
#endif
            /// <summary>
            /// Switches to a custom lifetime manager factory if possible.
            /// 
            /// Usually used for RegisterOptions "To*" extension methods such as the ASP.Net per-request one.
            /// </summary>
            /// <param name="instance">RegisterOptions instance</param>
            /// <param name="lifetimeProvider">Custom lifetime manager</param>
            /// <param name="errorString">Error string to display if switch fails</param>
            /// <returns>RegisterOptions</returns>
            public static RegisterOptions ToCustomLifetimeManager(RegisterOptions instance, ITinyIoCObjectLifetimeProvider lifetimeProvider, string errorString)
            {
                if (instance == null)
                    throw new ArgumentNullException("instance", "instance is null.");

                if (lifetimeProvider == null)
                    throw new ArgumentNullException("lifetimeProvider", "lifetimeProvider is null.");

                if (string.IsNullOrEmpty(errorString))
                    throw new ArgumentException("errorString is null or empty.", "errorString");

                var currentFactory = instance._Container.GetCurrentFactory(instance._Registration);

                if (currentFactory == null)
                    throw new TinyIoCRegistrationException(instance._Registration.Type, errorString);

                return instance._Container.AddUpdateRegistration(instance._Registration, currentFactory.GetCustomObjectLifetimeVariant(lifetimeProvider, errorString));
            }
        }

        /// <summary>
        /// Registration options for "fluent" API when registering multiple implementations
        /// </summary>
        public sealed class MultiRegisterOptions
        {
            private IEnumerable<RegisterOptions> _RegisterOptions;

            /// <summary>
            /// Initializes a new instance of the MultiRegisterOptions class.
            /// </summary>
            /// <param name="registerOptions">Registration options</param>
            public MultiRegisterOptions(IEnumerable<RegisterOptions> registerOptions)
            {
                _RegisterOptions = registerOptions;
            }

            /// <summary>
            /// Make registration a singleton (single instance) if possible
            /// </summary>
            /// <returns>RegisterOptions</returns>
            /// <exception cref="TinyIoCInstantiationTypeException"></exception>
            public MultiRegisterOptions AsSingleton()
            {
                _RegisterOptions = ExecuteOnAllRegisterOptions(ro => ro.AsSingleton());
                return this;
            }

            /// <summary>
            /// Make registration multi-instance if possible
            /// </summary>
            /// <returns>MultiRegisterOptions</returns>
            /// <exception cref="TinyIoCInstantiationTypeException"></exception>
            public MultiRegisterOptions AsMultiInstance()
            {
                _RegisterOptions = ExecuteOnAllRegisterOptions(ro => ro.AsMultiInstance());
                return this;
            }

            /// <summary>
            /// Switches to a custom lifetime manager factory if possible.
            /// 
            /// Usually used for RegisterOptions "To*" extension methods such as the ASP.Net per-request one.
            /// </summary>
            /// <param name="instance">MultiRegisterOptions instance</param>
            /// <param name="lifetimeProvider">Custom lifetime manager</param>
            /// <param name="errorString">Error string to display if switch fails</param>
            /// <returns>MultiRegisterOptions</returns>
            public static MultiRegisterOptions ToCustomLifetimeManager(
                MultiRegisterOptions instance,
                ITinyIoCObjectLifetimeProvider lifetimeProvider,
                string errorString)
            {
                if (instance == null)
                    throw new ArgumentNullException("instance", "instance is null.");

                if (lifetimeProvider == null)
                    throw new ArgumentNullException("lifetimeProvider", "lifetimeProvider is null.");

                if (string.IsNullOrEmpty(errorString))
                    throw new ArgumentException("errorString is null or empty.", "errorString");

                instance._RegisterOptions = instance.ExecuteOnAllRegisterOptions(ro => RegisterOptions.ToCustomLifetimeManager(ro, lifetimeProvider, errorString));

                return instance;
            }

            private IEnumerable<RegisterOptions> ExecuteOnAllRegisterOptions(Func<RegisterOptions, RegisterOptions> action)
            {
                var newRegisterOptions = new List<RegisterOptions>();

                foreach (var registerOption in _RegisterOptions)
                {
                    newRegisterOptions.Add(action(registerOption));
                }

                return newRegisterOptions;
            }
        }
        #endregion

        #region Public API
        #region Child Containers
        public TinyIoCContainer GetChildContainer()
        {
            return new TinyIoCContainer(this);
        }
        #endregion

        #region Registration
        /// <summary>
        /// Attempt to automatically register all non-generic classes and interfaces in the current app domain.
        /// 
        /// If more than one class implements an interface then only one implementation will be registered
        /// although no error will be thrown.
        /// </summary>
        public void AutoRegister()
        {
#if APPDOMAIN_GETASSEMBLIES
            AutoRegisterInternal(AppDomain.CurrentDomain.GetAssemblies().Where(a => !IsIgnoredAssembly(a)), DuplicateImplementationActions.RegisterSingle, null);
#else
            AutoRegisterInternal(new Assembly[] {this.GetType().Assembly()}, true, null);
#endif
        }

        /// <summary>
        /// Attempt to automatically register all non-generic classes and interfaces in the current app domain.
        /// Types will only be registered if they pass the supplied registration predicate.
        /// 
        /// If more than one class implements an interface then only one implementation will be registered
        /// although no error will be thrown.
        /// </summary>
        /// <param name="registrationPredicate">Predicate to determine if a particular type should be registered</param>
        public void AutoRegister(Func<Type, bool> registrationPredicate)
        {
#if APPDOMAIN_GETASSEMBLIES
            AutoRegisterInternal(AppDomain.CurrentDomain.GetAssemblies().Where(a => !IsIgnoredAssembly(a)), DuplicateImplementationActions.RegisterSingle, registrationPredicate);
#else
            AutoRegisterInternal(new Assembly[] { this.GetType().Assembly()}, true, registrationPredicate);
#endif
        }

        /// <summary>
        /// Attempt to automatically register all non-generic classes and interfaces in the current app domain.
        /// </summary>
        /// <param name="duplicateAction">What action to take when encountering duplicate implementations of an interface/base class.</param>
        /// <exception cref="TinyIoCAutoRegistrationException"/>
        public void AutoRegister(DuplicateImplementationActions duplicateAction)
        {
#if APPDOMAIN_GETASSEMBLIES
            AutoRegisterInternal(AppDomain.CurrentDomain.GetAssemblies().Where(a => !IsIgnoredAssembly(a)), duplicateAction, null);
#else
            AutoRegisterInternal(new Assembly[] { this.GetType().Assembly() }, ignoreDuplicateImplementations, null);
#endif
        }

        /// <summary>
        /// Attempt to automatically register all non-generic classes and interfaces in the current app domain.
        /// Types will only be registered if they pass the supplied registration predicate.
        /// </summary>
        /// <param name="duplicateAction">What action to take when encountering duplicate implementations of an interface/base class.</param>
        /// <param name="registrationPredicate">Predicate to determine if a particular type should be registered</param>
        /// <exception cref="TinyIoCAutoRegistrationException"/>
        public void AutoRegister(DuplicateImplementationActions duplicateAction, Func<Type, bool> registrationPredicate)
        {
#if APPDOMAIN_GETASSEMBLIES
            AutoRegisterInternal(AppDomain.CurrentDomain.GetAssemblies().Where(a => !IsIgnoredAssembly(a)), duplicateAction, registrationPredicate);
#else
            AutoRegisterInternal(new Assembly[] { this.GetType().Assembly() }, ignoreDuplicateImplementations, registrationPredicate);
#endif
        }

        /// <summary>
        /// Attempt to automatically register all non-generic classes and interfaces in the specified assemblies
        /// 
        /// If more than one class implements an interface then only one implementation will be registered
        /// although no error will be thrown.
        /// </summary>
        /// <param name="assemblies">Assemblies to process</param>
        public void AutoRegister(IEnumerable<Assembly> assemblies)
        {
            AutoRegisterInternal(assemblies, DuplicateImplementationActions.RegisterSingle, null);
        }

        /// <summary>
        /// Attempt to automatically register all non-generic classes and interfaces in the specified assemblies
        /// Types will only be registered if they pass the supplied registration predicate.
        /// 
        /// If more than one class implements an interface then only one implementation will be registered
        /// although no error will be thrown.
        /// </summary>
        /// <param name="assemblies">Assemblies to process</param>
        /// <param name="registrationPredicate">Predicate to determine if a particular type should be registered</param>
        public void AutoRegister(IEnumerable<Assembly> assemblies, Func<Type, bool> registrationPredicate)
        {
            AutoRegisterInternal(assemblies, DuplicateImplementationActions.RegisterSingle, registrationPredicate);
        }

        /// <summary>
        /// Attempt to automatically register all non-generic classes and interfaces in the specified assemblies
        /// </summary>
        /// <param name="assemblies">Assemblies to process</param>
        /// <param name="duplicateAction">What action to take when encountering duplicate implementations of an interface/base class.</param>
        /// <exception cref="TinyIoCAutoRegistrationException"/>
        public void AutoRegister(IEnumerable<Assembly> assemblies, DuplicateImplementationActions duplicateAction)
        {
            AutoRegisterInternal(assemblies, duplicateAction, null);
        }

        /// <summary>
        /// Attempt to automatically register all non-generic classes and interfaces in the specified assemblies
        /// Types will only be registered if they pass the supplied registration predicate.
        /// </summary>
        /// <param name="assemblies">Assemblies to process</param>
        /// <param name="duplicateAction">What action to take when encountering duplicate implementations of an interface/base class.</param>
        /// <param name="registrationPredicate">Predicate to determine if a particular type should be registered</param>
        /// <exception cref="TinyIoCAutoRegistrationException"/>
        public void AutoRegister(IEnumerable<Assembly> assemblies, DuplicateImplementationActions duplicateAction, Func<Type, bool> registrationPredicate)
        {
            AutoRegisterInternal(assemblies, duplicateAction, registrationPredicate);
        }

        /// <summary>
        /// Creates/replaces a container class registration with default options.
        /// </summary>
        /// <param name="registerType">Type to register</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register(Type registerType)
        {
            return RegisterInternal(registerType, string.Empty, GetDefaultObjectFactory(registerType, registerType));
        }

        /// <summary>
        /// Creates/replaces a named container class registration with default options.
        /// </summary>
        /// <param name="registerType">Type to register</param>
        /// <param name="name">Name of registration</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register(Type registerType, string name)
        {
            return RegisterInternal(registerType, name, GetDefaultObjectFactory(registerType, registerType));

        }

        /// <summary>
        /// Creates/replaces a container class registration with a given implementation and default options.
        /// </summary>
        /// <param name="registerType">Type to register</param>
        /// <param name="registerImplementation">Type to instantiate that implements RegisterType</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register(Type registerType, Type registerImplementation)
        {
            return this.RegisterInternal(registerType, string.Empty, GetDefaultObjectFactory(registerType, registerImplementation));
        }

        /// <summary>
        /// Creates/replaces a named container class registration with a given implementation and default options.
        /// </summary>
        /// <param name="registerType">Type to register</param>
        /// <param name="registerImplementation">Type to instantiate that implements RegisterType</param>
        /// <param name="name">Name of registration</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register(Type registerType, Type registerImplementation, string name)
        {
            return this.RegisterInternal(registerType, name, GetDefaultObjectFactory(registerType, registerImplementation));
        }

        /// <summary>
        /// Creates/replaces a container class registration with a specific, strong referenced, instance.
        /// </summary>
        /// <param name="registerType">Type to register</param>
        /// <param name="instance">Instance of RegisterType to register</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register(Type registerType, object instance)
        {
            return RegisterInternal(registerType, string.Empty, new InstanceFactory(registerType, registerType, instance));
        }

        /// <summary>
        /// Creates/replaces a named container class registration with a specific, strong referenced, instance.
        /// </summary>
        /// <param name="registerType">Type to register</param>
        /// <param name="instance">Instance of RegisterType to register</param>
        /// <param name="name">Name of registration</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register(Type registerType, object instance, string name)
        {
            return RegisterInternal(registerType, name, new InstanceFactory(registerType, registerType, instance));
        }

        /// <summary>
        /// Creates/replaces a container class registration with a specific, strong referenced, instance.
        /// </summary>
        /// <param name="registerType">Type to register</param>
        /// <param name="registerImplementation">Type of instance to register that implements RegisterType</param>
        /// <param name="instance">Instance of RegisterImplementation to register</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register(Type registerType, Type registerImplementation, object instance)
        {
            return RegisterInternal(registerType, string.Empty, new InstanceFactory(registerType, registerImplementation, instance));
        }

        /// <summary>
        /// Creates/replaces a named container class registration with a specific, strong referenced, instance.
        /// </summary>
        /// <param name="registerType">Type to register</param>
        /// <param name="registerImplementation">Type of instance to register that implements RegisterType</param>
        /// <param name="instance">Instance of RegisterImplementation to register</param>
        /// <param name="name">Name of registration</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register(Type registerType, Type registerImplementation, object instance, string name)
        {
            return RegisterInternal(registerType, name, new InstanceFactory(registerType, registerImplementation, instance));
        }

        /// <summary>
        /// Creates/replaces a container class registration with a user specified factory
        /// </summary>
        /// <param name="registerType">Type to register</param>
        /// <param name="factory">Factory/lambda that returns an instance of RegisterType</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register(Type registerType, Func<TinyIoCContainer, NamedParameterOverloads, object> factory)
        {
            return RegisterInternal(registerType, string.Empty, new DelegateFactory(registerType, factory));
        }

        /// <summary>
        /// Creates/replaces a container class registration with a user specified factory
        /// </summary>
        /// <param name="registerType">Type to register</param>
        /// <param name="factory">Factory/lambda that returns an instance of RegisterType</param>
        /// <param name="name">Name of registation</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register(Type registerType, Func<TinyIoCContainer, NamedParameterOverloads, object> factory, string name)
        {
            return RegisterInternal(registerType, name, new DelegateFactory(registerType, factory));
        }

        /// <summary>
        /// Creates/replaces a container class registration with default options.
        /// </summary>
        /// <typeparam name="RegisterImplementation">Type to register</typeparam>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register<RegisterType>()
            where RegisterType : class
        {
            return this.Register(typeof(RegisterType));
        }

        /// <summary>
        /// Creates/replaces a named container class registration with default options.
        /// </summary>
        /// <typeparam name="RegisterImplementation">Type to register</typeparam>
        /// <param name="name">Name of registration</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register<RegisterType>(string name)
            where RegisterType : class
        {
            return this.Register(typeof(RegisterType), name);
        }

        /// <summary>
        /// Creates/replaces a container class registration with a given implementation and default options.
        /// </summary>
        /// <typeparam name="RegisterType">Type to register</typeparam>
        /// <typeparam name="RegisterImplementation">Type to instantiate that implements RegisterType</typeparam>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register<RegisterType, RegisterImplementation>()
            where RegisterType : class
            where RegisterImplementation : class, RegisterType
        {
            return this.Register(typeof(RegisterType), typeof(RegisterImplementation));
        }

        /// <summary>
        /// Creates/replaces a named container class registration with a given implementation and default options.
        /// </summary>
        /// <typeparam name="RegisterType">Type to register</typeparam>
        /// <typeparam name="RegisterImplementation">Type to instantiate that implements RegisterType</typeparam>
        /// <param name="name">Name of registration</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register<RegisterType, RegisterImplementation>(string name)
            where RegisterType : class
            where RegisterImplementation : class, RegisterType
        {
            return this.Register(typeof(RegisterType), typeof(RegisterImplementation), name);
        }

        /// <summary>
        /// Creates/replaces a container class registration with a specific, strong referenced, instance.
        /// </summary>
        /// <typeparam name="RegisterType">Type to register</typeparam>
        /// <param name="instance">Instance of RegisterType to register</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register<RegisterType>(RegisterType instance)
           where RegisterType : class
        {
            return this.Register(typeof(RegisterType), instance);
        }

        /// <summary>
        /// Creates/replaces a named container class registration with a specific, strong referenced, instance.
        /// </summary>
        /// <typeparam name="RegisterType">Type to register</typeparam>
        /// <param name="instance">Instance of RegisterType to register</param>
        /// <param name="name">Name of registration</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register<RegisterType>(RegisterType instance, string name)
            where RegisterType : class
        {
            return this.Register(typeof(RegisterType), instance, name);
        }

        /// <summary>
        /// Creates/replaces a container class registration with a specific, strong referenced, instance.
        /// </summary>
        /// <typeparam name="RegisterType">Type to register</typeparam>
        /// <typeparam name="RegisterImplementation">Type of instance to register that implements RegisterType</typeparam>
        /// <param name="instance">Instance of RegisterImplementation to register</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register<RegisterType, RegisterImplementation>(RegisterImplementation instance)
            where RegisterType : class
            where RegisterImplementation : class, RegisterType
        {
            return this.Register(typeof(RegisterType), typeof(RegisterImplementation), instance);
        }

        /// <summary>
        /// Creates/replaces a named container class registration with a specific, strong referenced, instance.
        /// </summary>
        /// <typeparam name="RegisterType">Type to register</typeparam>
        /// <typeparam name="RegisterImplementation">Type of instance to register that implements RegisterType</typeparam>
        /// <param name="instance">Instance of RegisterImplementation to register</param>
        /// <param name="name">Name of registration</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register<RegisterType, RegisterImplementation>(RegisterImplementation instance, string name)
            where RegisterType : class
            where RegisterImplementation : class, RegisterType
        {
            return this.Register(typeof(RegisterType), typeof(RegisterImplementation), instance, name);
        }

        /// <summary>
        /// Creates/replaces a container class registration with a user specified factory
        /// </summary>
        /// <typeparam name="RegisterType">Type to register</typeparam>
        /// <param name="factory">Factory/lambda that returns an instance of RegisterType</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register<RegisterType>(Func<TinyIoCContainer, NamedParameterOverloads, RegisterType> factory)
            where RegisterType : class
        {
            if (factory == null)
            {
                throw new ArgumentNullException("factory");
            }

            return this.Register(typeof(RegisterType), (c, o) => factory(c, o));
        }

        /// <summary>
        /// Creates/replaces a named container class registration with a user specified factory
        /// </summary>
        /// <typeparam name="RegisterType">Type to register</typeparam>
        /// <param name="factory">Factory/lambda that returns an instance of RegisterType</param>
        /// <param name="name">Name of registation</param>
        /// <returns>RegisterOptions for fluent API</returns>
        public RegisterOptions Register<RegisterType>(Func<TinyIoCContainer, NamedParameterOverloads, RegisterType> factory, string name)
            where RegisterType : class
        {
            if (factory == null)
            {
                throw new ArgumentNullException("factory");
            }

            return this.Register(typeof(RegisterType), (c, o) => factory(c, o), name);
        }

        /// <summary>
        /// Register multiple implementations of a type.
        /// 
        /// Internally this registers each implementation using the full name of the class as its registration name.
        /// </summary>
        /// <typeparam name="RegisterType">Type that each implementation implements</typeparam>
        /// <param name="implementationTypes">Types that implement RegisterType</param>
        /// <returns>MultiRegisterOptions for the fluent API</returns>
        public MultiRegisterOptions RegisterMultiple<RegisterType>(IEnumerable<Type> implementationTypes)
        {
            return RegisterMultiple(typeof(RegisterType), implementationTypes);
        }

        /// <summary>
        /// Register multiple implementations of a type.
        /// 
        /// Internally this registers each implementation using the full name of the class as its registration name.
        /// </summary>
        /// <param name="registrationType">Type that each implementation implements</param>
        /// <param name="implementationTypes">Types that implement RegisterType</param>
        /// <returns>MultiRegisterOptions for the fluent API</returns>
        public MultiRegisterOptions RegisterMultiple(Type registrationType, IEnumerable<Type> implementationTypes)
        {
            if (implementationTypes == null)
                throw new ArgumentNullException("types", "types is null.");

            foreach (var type in implementationTypes)
                //#if NETFX_CORE
                //				if (!registrationType.GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))
                //#else
                if (!registrationType.IsAssignableFrom(type))
                    //#endif
                    throw new ArgumentException(String.Format("types: The type {0} is not assignable from {1}", registrationType.FullName, type.FullName));

            if (implementationTypes.Count() != implementationTypes.Distinct().Count())
            {
                var queryForDuplicatedTypes = from i in implementationTypes
                                              group i by i
                                                  into j
                                              where j.Count() > 1
                                              select j.Key.FullName;

                var fullNamesOfDuplicatedTypes = string.Join(",\n", queryForDuplicatedTypes.ToArray());
                var multipleRegMessage = string.Format("types: The same implementation type cannot be specified multiple times for {0}\n\n{1}", registrationType.FullName, fullNamesOfDuplicatedTypes);
                throw new ArgumentException(multipleRegMessage);
            }

            var registerOptions = new List<RegisterOptions>();

            foreach (var type in implementationTypes)
            {
                registerOptions.Add(Register(registrationType, type, type.FullName));
            }

            return new MultiRegisterOptions(registerOptions);
        }
        #endregion

        #region Resolution
        /// <summary>
        /// Attempts to resolve a type using default options.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public object Resolve(Type resolveType)
        {
            return ResolveInternal(new TypeRegistration(resolveType), NamedParameterOverloads.Default, ResolveOptions.Default);
        }

        /// <summary>
        /// Attempts to resolve a type using specified options.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public object Resolve(Type resolveType, ResolveOptions options)
        {
            return ResolveInternal(new TypeRegistration(resolveType), NamedParameterOverloads.Default, options);
        }

        /// <summary>
        /// Attempts to resolve a type using default options and the supplied name.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public object Resolve(Type resolveType, string name)
        {
            return ResolveInternal(new TypeRegistration(resolveType, name), NamedParameterOverloads.Default, ResolveOptions.Default);
        }

        /// <summary>
        /// Attempts to resolve a type using supplied options and  name.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public object Resolve(Type resolveType, string name, ResolveOptions options)
        {
            return ResolveInternal(new TypeRegistration(resolveType, name), NamedParameterOverloads.Default, options);
        }

        /// <summary>
        /// Attempts to resolve a type using default options and the supplied constructor parameters.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public object Resolve(Type resolveType, NamedParameterOverloads parameters)
        {
            return ResolveInternal(new TypeRegistration(resolveType), parameters, ResolveOptions.Default);
        }

        /// <summary>
        /// Attempts to resolve a type using specified options and the supplied constructor parameters.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public object Resolve(Type resolveType, NamedParameterOverloads parameters, ResolveOptions options)
        {
            return ResolveInternal(new TypeRegistration(resolveType), parameters, options);
        }

        /// <summary>
        /// Attempts to resolve a type using default options and the supplied constructor parameters and name.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="name">Name of registration</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public object Resolve(Type resolveType, string name, NamedParameterOverloads parameters)
        {
            return ResolveInternal(new TypeRegistration(resolveType, name), parameters, ResolveOptions.Default);
        }

        /// <summary>
        /// Attempts to resolve a named type using specified options and the supplied constructor parameters.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public object Resolve(Type resolveType, string name, NamedParameterOverloads parameters, ResolveOptions options)
        {
            return ResolveInternal(new TypeRegistration(resolveType, name), parameters, options);
        }

        /// <summary>
        /// Attempts to resolve a type using default options.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public ResolveType Resolve<ResolveType>()
            where ResolveType : class
        {
            return (ResolveType)Resolve(typeof(ResolveType));
        }

        /// <summary>
        /// Attempts to resolve a type using specified options.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="options">Resolution options</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public ResolveType Resolve<ResolveType>(ResolveOptions options)
            where ResolveType : class
        {
            return (ResolveType)Resolve(typeof(ResolveType), options);
        }

        /// <summary>
        /// Attempts to resolve a type using default options and the supplied name.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public ResolveType Resolve<ResolveType>(string name)
            where ResolveType : class
        {
            return (ResolveType)Resolve(typeof(ResolveType), name);
        }

        /// <summary>
        /// Attempts to resolve a type using supplied options and  name.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public ResolveType Resolve<ResolveType>(string name, ResolveOptions options)
            where ResolveType : class
        {
            return (ResolveType)Resolve(typeof(ResolveType), name, options);
        }

        /// <summary>
        /// Attempts to resolve a type using default options and the supplied constructor parameters.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public ResolveType Resolve<ResolveType>(NamedParameterOverloads parameters)
            where ResolveType : class
        {
            return (ResolveType)Resolve(typeof(ResolveType), parameters);
        }

        /// <summary>
        /// Attempts to resolve a type using specified options and the supplied constructor parameters.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public ResolveType Resolve<ResolveType>(NamedParameterOverloads parameters, ResolveOptions options)
            where ResolveType : class
        {
            return (ResolveType)Resolve(typeof(ResolveType), parameters, options);
        }

        /// <summary>
        /// Attempts to resolve a type using default options and the supplied constructor parameters and name.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="name">Name of registration</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public ResolveType Resolve<ResolveType>(string name, NamedParameterOverloads parameters)
            where ResolveType : class
        {
            return (ResolveType)Resolve(typeof(ResolveType), name, parameters);
        }

        /// <summary>
        /// Attempts to resolve a named type using specified options and the supplied constructor parameters.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Instance of type</returns>
        /// <exception cref="TinyIoCResolutionException">Unable to resolve the type.</exception>
        public ResolveType Resolve<ResolveType>(string name, NamedParameterOverloads parameters, ResolveOptions options)
            where ResolveType : class
        {
            return (ResolveType)Resolve(typeof(ResolveType), name, parameters, options);
        }

        /// <summary>
        /// Attempts to predict whether a given type can be resolved with default options.
        ///
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve(Type resolveType)
        {
            return CanResolveInternal(new TypeRegistration(resolveType), NamedParameterOverloads.Default, ResolveOptions.Default);
        }

        /// <summary>
        /// Attempts to predict whether a given named type can be resolved with default options.
        ///
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        private bool CanResolve(Type resolveType, string name)
        {
            return CanResolveInternal(new TypeRegistration(resolveType, name), NamedParameterOverloads.Default, ResolveOptions.Default);
        }

        /// <summary>
        /// Attempts to predict whether a given type can be resolved with the specified options.
        ///
        /// Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve(Type resolveType, ResolveOptions options)
        {
            return CanResolveInternal(new TypeRegistration(resolveType), NamedParameterOverloads.Default, options);
        }

        /// <summary>
        /// Attempts to predict whether a given named type can be resolved with the specified options.
        ///
        /// Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve(Type resolveType, string name, ResolveOptions options)
        {
            return CanResolveInternal(new TypeRegistration(resolveType, name), NamedParameterOverloads.Default, options);
        }

        /// <summary>
        /// Attempts to predict whether a given type can be resolved with the supplied constructor parameters and default options.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// 
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="parameters">User supplied named parameter overloads</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve(Type resolveType, NamedParameterOverloads parameters)
        {
            return CanResolveInternal(new TypeRegistration(resolveType), parameters, ResolveOptions.Default);
        }

        /// <summary>
        /// Attempts to predict whether a given named type can be resolved with the supplied constructor parameters and default options.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// 
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User supplied named parameter overloads</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve(Type resolveType, string name, NamedParameterOverloads parameters)
        {
            return CanResolveInternal(new TypeRegistration(resolveType, name), parameters, ResolveOptions.Default);
        }

        /// <summary>
        /// Attempts to predict whether a given type can be resolved with the supplied constructor parameters options.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// 
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="parameters">User supplied named parameter overloads</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve(Type resolveType, NamedParameterOverloads parameters, ResolveOptions options)
        {
            return CanResolveInternal(new TypeRegistration(resolveType), parameters, options);
        }

        /// <summary>
        /// Attempts to predict whether a given named type can be resolved with the supplied constructor parameters options.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// 
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <param name="resolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User supplied named parameter overloads</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve(Type resolveType, string name, NamedParameterOverloads parameters, ResolveOptions options)
        {
            return CanResolveInternal(new TypeRegistration(resolveType, name), parameters, options);
        }

        /// <summary>
        /// Attempts to predict whether a given type can be resolved with default options.
        ///
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve<ResolveType>()
            where ResolveType : class
        {
            return CanResolve(typeof(ResolveType));
        }

        /// <summary>
        /// Attempts to predict whether a given named type can be resolved with default options.
        ///
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve<ResolveType>(string name)
            where ResolveType : class
        {
            return CanResolve(typeof(ResolveType), name);
        }

        /// <summary>
        /// Attempts to predict whether a given type can be resolved with the specified options.
        ///
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve<ResolveType>(ResolveOptions options)
            where ResolveType : class
        {
            return CanResolve(typeof(ResolveType), options);
        }

        /// <summary>
        /// Attempts to predict whether a given named type can be resolved with the specified options.
        ///
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve<ResolveType>(string name, ResolveOptions options)
            where ResolveType : class
        {
            return CanResolve(typeof(ResolveType), name, options);
        }

        /// <summary>
        /// Attempts to predict whether a given type can be resolved with the supplied constructor parameters and default options.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// 
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="parameters">User supplied named parameter overloads</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve<ResolveType>(NamedParameterOverloads parameters)
            where ResolveType : class
        {
            return CanResolve(typeof(ResolveType), parameters);
        }

        /// <summary>
        /// Attempts to predict whether a given named type can be resolved with the supplied constructor parameters and default options.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// 
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User supplied named parameter overloads</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve<ResolveType>(string name, NamedParameterOverloads parameters)
            where ResolveType : class
        {
            return CanResolve(typeof(ResolveType), name, parameters);
        }

        /// <summary>
        /// Attempts to predict whether a given type can be resolved with the supplied constructor parameters options.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// 
        /// Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="parameters">User supplied named parameter overloads</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve<ResolveType>(NamedParameterOverloads parameters, ResolveOptions options)
            where ResolveType : class
        {
            return CanResolve(typeof(ResolveType), parameters, options);
        }

        /// <summary>
        /// Attempts to predict whether a given named type can be resolved with the supplied constructor parameters options.
        ///
        /// Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
        /// All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
        /// 
        /// Note: Resolution may still fail if user defined factory registations fail to construct objects when called.
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User supplied named parameter overloads</param>
        /// <param name="options">Resolution options</param>
        /// <returns>Bool indicating whether the type can be resolved</returns>
        public bool CanResolve<ResolveType>(string name, NamedParameterOverloads parameters, ResolveOptions options)
            where ResolveType : class
        {
            return CanResolve(typeof(ResolveType), name, parameters, options);
        }

        /// <summary>
        /// Attemps to resolve a type using the default options
        /// </summary>
        /// <param name="ResolveType">Type to resolve</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved sucessfully, false otherwise</returns>
        public bool TryResolve(Type resolveType, out object resolvedType)
        {
            try
            {
                resolvedType = Resolve(resolveType);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = null;
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the given options
        /// </summary>
        /// <param name="ResolveType">Type to resolve</param>
        /// <param name="options">Resolution options</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved sucessfully, false otherwise</returns>
        public bool TryResolve(Type resolveType, ResolveOptions options, out object resolvedType)
        {
            try
            {
                resolvedType = Resolve(resolveType, options);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = null;
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the default options and given name
        /// </summary>
        /// <param name="ResolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve(Type resolveType, string name, out object resolvedType)
        {
            try
            {
                resolvedType = Resolve(resolveType, name);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = null;
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the given options and name
        /// </summary>
        /// <param name="ResolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="options">Resolution options</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved sucessfully, false otherwise</returns>
        public bool TryResolve(Type resolveType, string name, ResolveOptions options, out object resolvedType)
        {
            try
            {
                resolvedType = Resolve(resolveType, name, options);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = null;
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the default options and supplied constructor parameters
        /// </summary>
        /// <param name="ResolveType">Type to resolve</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved sucessfully, false otherwise</returns>
        public bool TryResolve(Type resolveType, NamedParameterOverloads parameters, out object resolvedType)
        {
            try
            {
                resolvedType = Resolve(resolveType, parameters);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = null;
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the default options and supplied name and constructor parameters
        /// </summary>
        /// <param name="ResolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve(Type resolveType, string name, NamedParameterOverloads parameters, out object resolvedType)
        {
            try
            {
                resolvedType = Resolve(resolveType, name, parameters);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = null;
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the supplied options and constructor parameters
        /// </summary>
        /// <param name="ResolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="options">Resolution options</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve(Type resolveType, NamedParameterOverloads parameters, ResolveOptions options, out object resolvedType)
        {
            try
            {
                resolvedType = Resolve(resolveType, parameters, options);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = null;
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the supplied name, options and constructor parameters
        /// </summary>
        /// <param name="ResolveType">Type to resolve</param>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="options">Resolution options</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve(Type resolveType, string name, NamedParameterOverloads parameters, ResolveOptions options, out object resolvedType)
        {
            try
            {
                resolvedType = Resolve(resolveType, name, parameters, options);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = null;
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the default options
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve<ResolveType>(out ResolveType resolvedType)
            where ResolveType : class
        {
            try
            {
                resolvedType = Resolve<ResolveType>();
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = default(ResolveType);
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the given options
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="options">Resolution options</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve<ResolveType>(ResolveOptions options, out ResolveType resolvedType)
            where ResolveType : class
        {
            try
            {
                resolvedType = Resolve<ResolveType>(options);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = default(ResolveType);
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the default options and given name
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve<ResolveType>(string name, out ResolveType resolvedType)
            where ResolveType : class
        {
            try
            {
                resolvedType = Resolve<ResolveType>(name);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = default(ResolveType);
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the given options and name
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="options">Resolution options</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve<ResolveType>(string name, ResolveOptions options, out ResolveType resolvedType)
            where ResolveType : class
        {
            try
            {
                resolvedType = Resolve<ResolveType>(name, options);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = default(ResolveType);
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the default options and supplied constructor parameters
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve<ResolveType>(NamedParameterOverloads parameters, out ResolveType resolvedType)
            where ResolveType : class
        {
            try
            {
                resolvedType = Resolve<ResolveType>(parameters);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = default(ResolveType);
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the default options and supplied name and constructor parameters
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve<ResolveType>(string name, NamedParameterOverloads parameters, out ResolveType resolvedType)
            where ResolveType : class
        {
            try
            {
                resolvedType = Resolve<ResolveType>(name, parameters);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = default(ResolveType);
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the supplied options and constructor parameters
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="options">Resolution options</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve<ResolveType>(NamedParameterOverloads parameters, ResolveOptions options, out ResolveType resolvedType)
            where ResolveType : class
        {
            try
            {
                resolvedType = Resolve<ResolveType>(parameters, options);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = default(ResolveType);
                return false;
            }
        }

        /// <summary>
        /// Attemps to resolve a type using the supplied name, options and constructor parameters
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolve</typeparam>
        /// <param name="name">Name of registration</param>
        /// <param name="parameters">User specified constructor parameters</param>
        /// <param name="options">Resolution options</param>
        /// <param name="resolvedType">Resolved type or default if resolve fails</param>
        /// <returns>True if resolved successfully, false otherwise</returns>
        public bool TryResolve<ResolveType>(string name, NamedParameterOverloads parameters, ResolveOptions options, out ResolveType resolvedType)
            where ResolveType : class
        {
            try
            {
                resolvedType = Resolve<ResolveType>(name, parameters, options);
                return true;
            }
            catch (TinyIoCResolutionException)
            {
                resolvedType = default(ResolveType);
                return false;
            }
        }

        /// <summary>
        /// Returns all registrations of a type
        /// </summary>
        /// <param name="ResolveType">Type to resolveAll</param>
        /// <param name="includeUnnamed">Whether to include un-named (default) registrations</param>
        /// <returns>IEnumerable</returns>
        public IEnumerable<object> ResolveAll(Type resolveType, bool includeUnnamed)
        {
            return ResolveAllInternal(resolveType, includeUnnamed);
        }

        /// <summary>
        /// Returns all registrations of a type, both named and unnamed
        /// </summary>
        /// <param name="ResolveType">Type to resolveAll</param>
        /// <returns>IEnumerable</returns>
        public IEnumerable<object> ResolveAll(Type resolveType)
        {
            return ResolveAll(resolveType, false);
        }

        /// <summary>
        /// Returns all registrations of a type
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolveAll</typeparam>
        /// <param name="includeUnnamed">Whether to include un-named (default) registrations</param>
        /// <returns>IEnumerable</returns>
        public IEnumerable<ResolveType> ResolveAll<ResolveType>(bool includeUnnamed)
            where ResolveType : class
        {
            return this.ResolveAll(typeof(ResolveType), includeUnnamed).Cast<ResolveType>();
        }

        /// <summary>
        /// Returns all registrations of a type, both named and unnamed
        /// </summary>
        /// <typeparam name="ResolveType">Type to resolveAll</typeparam>
        /// <param name="includeUnnamed">Whether to include un-named (default) registrations</param>
        /// <returns>IEnumerable</returns>
        public IEnumerable<ResolveType> ResolveAll<ResolveType>()
            where ResolveType : class
        {
            return ResolveAll<ResolveType>(true);
        }

        /// <summary>
        /// Attempts to resolve all public property dependencies on the given object.
        /// </summary>
        /// <param name="input">Object to "build up"</param>
        public void BuildUp(object input)
        {
            BuildUpInternal(input, ResolveOptions.Default);
        }

        /// <summary>
        /// Attempts to resolve all public property dependencies on the given object using the given resolve options.
        /// </summary>
        /// <param name="input">Object to "build up"</param>
        /// <param name="resolveOptions">Resolve options to use</param>
        public void BuildUp(object input, ResolveOptions resolveOptions)
        {
            BuildUpInternal(input, resolveOptions);
        }
        #endregion
        #endregion

        #region Object Factories
        /// <summary>
        /// Provides custom lifetime management for ASP.Net per-request lifetimes etc.
        /// </summary>
        public interface ITinyIoCObjectLifetimeProvider
        {
            /// <summary>
            /// Gets the stored object if it exists, or null if not
            /// </summary>
            /// <returns>Object instance or null</returns>
            object GetObject();

            /// <summary>
            /// Store the object
            /// </summary>
            /// <param name="value">Object to store</param>
            void SetObject(object value);

            /// <summary>
            /// Release the object
            /// </summary>
            void ReleaseObject();
        }

        private abstract class ObjectFactoryBase
        {
            /// <summary>
            /// Whether to assume this factory successfully constructs its objects
            /// 
            /// Generally set to true for delegate style factories as CanResolve cannot delve
            /// into the delegates they contain.
            /// </summary>
            public virtual bool AssumeConstruction { get { return false; } }

            /// <summary>
            /// The type the factory instantiates
            /// </summary>
            public abstract Type CreatesType { get; }

            /// <summary>
            /// Constructor to use, if specified
            /// </summary>
            public ConstructorInfo Constructor { get; protected set; }

            /// <summary>
            /// Create the type
            /// </summary>
            /// <param name="requestedType">Type user requested to be resolved</param>
            /// <param name="container">Container that requested the creation</param>
            /// <param name="parameters">Any user parameters passed</param>
            /// <param name="options"></param>
            /// <returns></returns>
            public abstract object GetObject(Type requestedType, TinyIoCContainer container, NamedParameterOverloads parameters, ResolveOptions options);

            public virtual ObjectFactoryBase SingletonVariant
            {
                get
                {
                    throw new TinyIoCRegistrationException(this.GetType(), "singleton");
                }
            }

            public virtual ObjectFactoryBase MultiInstanceVariant
            {
                get
                {
                    throw new TinyIoCRegistrationException(this.GetType(), "multi-instance");
                }
            }

            public virtual ObjectFactoryBase StrongReferenceVariant
            {
                get
                {
                    throw new TinyIoCRegistrationException(this.GetType(), "strong reference");
                }
            }

            public virtual ObjectFactoryBase WeakReferenceVariant
            {
                get
                {
                    throw new TinyIoCRegistrationException(this.GetType(), "weak reference");
                }
            }

            public virtual ObjectFactoryBase GetCustomObjectLifetimeVariant(ITinyIoCObjectLifetimeProvider lifetimeProvider, string errorString)
            {
                throw new TinyIoCRegistrationException(this.GetType(), errorString);
            }

            public virtual void SetConstructor(ConstructorInfo constructor)
            {
                Constructor = constructor;
            }

            public virtual ObjectFactoryBase GetFactoryForChildContainer(Type type, TinyIoCContainer parent, TinyIoCContainer child)
            {
                return this;
            }
        }

        /// <summary>
        /// IObjectFactory that creates new instances of types for each resolution
        /// </summary>
        private class MultiInstanceFactory : ObjectFactoryBase
        {
            private readonly Type registerType;
            private readonly Type registerImplementation;
            public override Type CreatesType { get { return this.registerImplementation; } }

            public MultiInstanceFactory(Type registerType, Type registerImplementation)
            {
                //#if NETFX_CORE
                //				if (registerImplementation.GetTypeInfo().IsAbstract() || registerImplementation.GetTypeInfo().IsInterface())
                //					throw new TinyIoCRegistrationTypeException(registerImplementation, "MultiInstanceFactory");
                //#else
                if (registerImplementation.IsAbstract() || registerImplementation.IsInterface())
                    throw new TinyIoCRegistrationTypeException(registerImplementation, "MultiInstanceFactory");
                //#endif
                if (!IsValidAssignment(registerType, registerImplementation))
                    throw new TinyIoCRegistrationTypeException(registerImplementation, "MultiInstanceFactory");

                this.registerType = registerType;
                this.registerImplementation = registerImplementation;
            }

            public override object GetObject(Type requestedType, TinyIoCContainer container, NamedParameterOverloads parameters, ResolveOptions options)
            {
                try
                {
                    return container.ConstructType(requestedType, this.registerImplementation, Constructor, parameters, options);
                }
                catch (TinyIoCResolutionException ex)
                {
                    throw new TinyIoCResolutionException(this.registerType, ex);
                }
            }

            public override ObjectFactoryBase SingletonVariant
            {
                get
                {
                    return new SingletonFactory(this.registerType, this.registerImplementation);
                }
            }

            public override ObjectFactoryBase GetCustomObjectLifetimeVariant(ITinyIoCObjectLifetimeProvider lifetimeProvider, string errorString)
            {
                return new CustomObjectLifetimeFactory(this.registerType, this.registerImplementation, lifetimeProvider, errorString);
            }

            public override ObjectFactoryBase MultiInstanceVariant
            {
                get
                {
                    return this;
                }
            }
        }

        /// <summary>
        /// IObjectFactory that invokes a specified delegate to construct the object
        /// </summary>
        private class DelegateFactory : ObjectFactoryBase
        {
            private readonly Type registerType;

            private Func<TinyIoCContainer, NamedParameterOverloads, object> _factory;

            public override bool AssumeConstruction { get { return true; } }

            public override Type CreatesType { get { return this.registerType; } }

            public override object GetObject(Type requestedType, TinyIoCContainer container, NamedParameterOverloads parameters, ResolveOptions options)
            {
                try
                {
                    return _factory.Invoke(container, parameters);
                }
                catch (Exception ex)
                {
                    throw new TinyIoCResolutionException(this.registerType, ex);
                }
            }

            public DelegateFactory(Type registerType, Func<TinyIoCContainer, NamedParameterOverloads, object> factory)
            {
                if (factory == null)
                    throw new ArgumentNullException("factory");

                _factory = factory;

                this.registerType = registerType;
            }

            public override ObjectFactoryBase WeakReferenceVariant
            {
                get
                {
                    return new WeakDelegateFactory(this.registerType, _factory);
                }
            }

            public override ObjectFactoryBase StrongReferenceVariant
            {
                get
                {
                    return this;
                }
            }

            public override void SetConstructor(ConstructorInfo constructor)
            {
                throw new TinyIoCConstructorResolutionException("Constructor selection is not possible for delegate factory registrations");
            }
        }

        /// <summary>
        /// IObjectFactory that invokes a specified delegate to construct the object
        /// Holds the delegate using a weak reference
        /// </summary>
        private class WeakDelegateFactory : ObjectFactoryBase
        {
            private readonly Type registerType;

            private WeakReference _factory;

            public override bool AssumeConstruction { get { return true; } }

            public override Type CreatesType { get { return this.registerType; } }

            public override object GetObject(Type requestedType, TinyIoCContainer container, NamedParameterOverloads parameters, ResolveOptions options)
            {
                var factory = _factory.Target as Func<TinyIoCContainer, NamedParameterOverloads, object>;

                if (factory == null)
                    throw new TinyIoCWeakReferenceException(this.registerType);

                try
                {
                    return factory.Invoke(container, parameters);
                }
                catch (Exception ex)
                {
                    throw new TinyIoCResolutionException(this.registerType, ex);
                }
            }

            public WeakDelegateFactory(Type registerType, Func<TinyIoCContainer, NamedParameterOverloads, object> factory)
            {
                if (factory == null)
                    throw new ArgumentNullException("factory");

                _factory = new WeakReference(factory);

                this.registerType = registerType;
            }

            public override ObjectFactoryBase StrongReferenceVariant
            {
                get
                {
                    var factory = _factory.Target as Func<TinyIoCContainer, NamedParameterOverloads, object>;

                    if (factory == null)
                        throw new TinyIoCWeakReferenceException(this.registerType);

                    return new DelegateFactory(this.registerType, factory);
                }
            }

            public override ObjectFactoryBase WeakReferenceVariant
            {
                get
                {
                    return this;
                }
            }

            public override void SetConstructor(ConstructorInfo constructor)
            {
                throw new TinyIoCConstructorResolutionException("Constructor selection is not possible for delegate factory registrations");
            }
        }

        /// <summary>
        /// Stores an particular instance to return for a type
        /// </summary>
        private class InstanceFactory : ObjectFactoryBase, IDisposable
        {
            private readonly Type registerType;
            private readonly Type registerImplementation;
            private object _instance;

            public override bool AssumeConstruction { get { return true; } }

            public InstanceFactory(Type registerType, Type registerImplementation, object instance)
            {
                if (!IsValidAssignment(registerType, registerImplementation))
                    throw new TinyIoCRegistrationTypeException(registerImplementation, "InstanceFactory");

                this.registerType = registerType;
                this.registerImplementation = registerImplementation;
                _instance = instance;
            }

            public override Type CreatesType
            {
                get { return this.registerImplementation; }
            }

            public override object GetObject(Type requestedType, TinyIoCContainer container, NamedParameterOverloads parameters, ResolveOptions options)
            {
                return _instance;
            }

            public override ObjectFactoryBase MultiInstanceVariant
            {
                get { return new MultiInstanceFactory(this.registerType, this.registerImplementation); }
            }

            public override ObjectFactoryBase WeakReferenceVariant
            {
                get
                {
                    return new WeakInstanceFactory(this.registerType, this.registerImplementation, this._instance);
                }
            }

            public override ObjectFactoryBase StrongReferenceVariant
            {
                get
                {
                    return this;
                }
            }

            public override void SetConstructor(ConstructorInfo constructor)
            {
                throw new TinyIoCConstructorResolutionException("Constructor selection is not possible for instance factory registrations");
            }

            public void Dispose()
            {
                var disposable = _instance as IDisposable;

                if (disposable != null)
                    disposable.Dispose();
            }
        }

        /// <summary>
        /// Stores an particular instance to return for a type
        /// 
        /// Stores the instance with a weak reference
        /// </summary>
        private class WeakInstanceFactory : ObjectFactoryBase, IDisposable
        {
            private readonly Type registerType;
            private readonly Type registerImplementation;
            private readonly WeakReference _instance;

            public WeakInstanceFactory(Type registerType, Type registerImplementation, object instance)
            {
                if (!IsValidAssignment(registerType, registerImplementation))
                    throw new TinyIoCRegistrationTypeException(registerImplementation, "WeakInstanceFactory");

                this.registerType = registerType;
                this.registerImplementation = registerImplementation;
                _instance = new WeakReference(instance);
            }

            public override Type CreatesType
            {
                get { return this.registerImplementation; }
            }

            public override object GetObject(Type requestedType, TinyIoCContainer container, NamedParameterOverloads parameters, ResolveOptions options)
            {
                var instance = _instance.Target;

                if (instance == null)
                    throw new TinyIoCWeakReferenceException(this.registerType);

                return instance;
            }

            public override ObjectFactoryBase MultiInstanceVariant
            {
                get
                {
                    return new MultiInstanceFactory(this.registerType, this.registerImplementation);
                }
            }

            public override ObjectFactoryBase WeakReferenceVariant
            {
                get
                {
                    return this;
                }
            }

            public override ObjectFactoryBase StrongReferenceVariant
            {
                get
                {
                    var instance = _instance.Target;

                    if (instance == null)
                        throw new TinyIoCWeakReferenceException(this.registerType);

                    return new InstanceFactory(this.registerType, this.registerImplementation, instance);
                }
            }

            public override void SetConstructor(ConstructorInfo constructor)
            {
                throw new TinyIoCConstructorResolutionException("Constructor selection is not possible for instance factory registrations");
            }

            public void Dispose()
            {
                var disposable = _instance.Target as IDisposable;

                if (disposable != null)
                    disposable.Dispose();
            }
        }

        /// <summary>
        /// A factory that lazy instantiates a type and always returns the same instance
        /// </summary>
        private class SingletonFactory : ObjectFactoryBase, IDisposable
        {
            private readonly Type registerType;
            private readonly Type registerImplementation;
            private readonly object SingletonLock = new object();
            private object _Current;

            public SingletonFactory(Type registerType, Type registerImplementation)
            {
                //#if NETFX_CORE
                //				if (registerImplementation.GetTypeInfo().IsAbstract() || registerImplementation.GetTypeInfo().IsInterface())
                //#else
                if (registerImplementation.IsAbstract() || registerImplementation.IsInterface())
                    //#endif
                    throw new TinyIoCRegistrationTypeException(registerImplementation, "SingletonFactory");

                if (!IsValidAssignment(registerType, registerImplementation))
                    throw new TinyIoCRegistrationTypeException(registerImplementation, "SingletonFactory");

                this.registerType = registerType;
                this.registerImplementation = registerImplementation;
            }

            public override Type CreatesType
            {
                get { return this.registerImplementation; }
            }

            public override object GetObject(Type requestedType, TinyIoCContainer container, NamedParameterOverloads parameters, ResolveOptions options)
            {
                if (parameters.Count != 0)
                    throw new ArgumentException("Cannot specify parameters for singleton types");

                lock (SingletonLock)
                    if (_Current == null)
                        _Current = container.ConstructType(requestedType, this.registerImplementation, Constructor, options);

                return _Current;
            }

            public override ObjectFactoryBase SingletonVariant
            {
                get
                {
                    return this;
                }
            }

            public override ObjectFactoryBase GetCustomObjectLifetimeVariant(ITinyIoCObjectLifetimeProvider lifetimeProvider, string errorString)
            {
                return new CustomObjectLifetimeFactory(this.registerType, this.registerImplementation, lifetimeProvider, errorString);
            }

            public override ObjectFactoryBase MultiInstanceVariant
            {
                get
                {
                    return new MultiInstanceFactory(this.registerType, this.registerImplementation);
                }
            }

            public override ObjectFactoryBase GetFactoryForChildContainer(Type type, TinyIoCContainer parent, TinyIoCContainer child)
            {
                // We make sure that the singleton is constructed before the child container takes the factory.
                // Otherwise the results would vary depending on whether or not the parent container had resolved
                // the type before the child container does.
                GetObject(type, parent, NamedParameterOverloads.Default, ResolveOptions.Default);
                return this;
            }

            public void Dispose()
            {
                if (this._Current == null)
                    return;

                var disposable = this._Current as IDisposable;

                if (disposable != null)
                    disposable.Dispose();
            }
        }

        /// <summary>
        /// A factory that offloads lifetime to an external lifetime provider
        /// </summary>
        private class CustomObjectLifetimeFactory : ObjectFactoryBase, IDisposable
        {
            private readonly object SingletonLock = new object();
            private readonly Type registerType;
            private readonly Type registerImplementation;
            private readonly ITinyIoCObjectLifetimeProvider _LifetimeProvider;

            public CustomObjectLifetimeFactory(Type registerType, Type registerImplementation, ITinyIoCObjectLifetimeProvider lifetimeProvider, string errorMessage)
            {
                if (lifetimeProvider == null)
                    throw new ArgumentNullException("lifetimeProvider", "lifetimeProvider is null.");

                if (!IsValidAssignment(registerType, registerImplementation))
                    throw new TinyIoCRegistrationTypeException(registerImplementation, "SingletonFactory");

                //#if NETFX_CORE
                //				if (registerImplementation.GetTypeInfo().IsAbstract() || registerImplementation.GetTypeInfo().IsInterface())
                //#else
                if (registerImplementation.IsAbstract() || registerImplementation.IsInterface())
                    //#endif
                    throw new TinyIoCRegistrationTypeException(registerImplementation, errorMessage);

                this.registerType = registerType;
                this.registerImplementation = registerImplementation;
                _LifetimeProvider = lifetimeProvider;
            }

            public override Type CreatesType
            {
                get { return this.registerImplementation; }
            }

            public override object GetObject(Type requestedType, TinyIoCContainer container, NamedParameterOverloads parameters, ResolveOptions options)
            {
                object current;

                lock (SingletonLock)
                {
                    current = _LifetimeProvider.GetObject();
                    if (current == null)
                    {
                        current = container.ConstructType(requestedType, this.registerImplementation, Constructor, options);
                        _LifetimeProvider.SetObject(current);
                    }
                }

                return current;
            }

            public override ObjectFactoryBase SingletonVariant
            {
                get
                {
                    _LifetimeProvider.ReleaseObject();
                    return new SingletonFactory(this.registerType, this.registerImplementation);
                }
            }

            public override ObjectFactoryBase MultiInstanceVariant
            {
                get
                {
                    _LifetimeProvider.ReleaseObject();
                    return new MultiInstanceFactory(this.registerType, this.registerImplementation);
                }
            }

            public override ObjectFactoryBase GetCustomObjectLifetimeVariant(ITinyIoCObjectLifetimeProvider lifetimeProvider, string errorString)
            {
                _LifetimeProvider.ReleaseObject();
                return new CustomObjectLifetimeFactory(this.registerType, this.registerImplementation, lifetimeProvider, errorString);
            }

            public override ObjectFactoryBase GetFactoryForChildContainer(Type type, TinyIoCContainer parent, TinyIoCContainer child)
            {
                // We make sure that the singleton is constructed before the child container takes the factory.
                // Otherwise the results would vary depending on whether or not the parent container had resolved
                // the type before the child container does.
                GetObject(type, parent, NamedParameterOverloads.Default, ResolveOptions.Default);
                return this;
            }

            public void Dispose()
            {
                _LifetimeProvider.ReleaseObject();
            }
        }
        #endregion

        #region Singleton Container
        private static readonly TinyIoCContainer _Current = new TinyIoCContainer();

        static TinyIoCContainer()
        {
        }

        /// <summary>
        /// Lazy created Singleton instance of the container for simple scenarios
        /// </summary>
        public static TinyIoCContainer Current
        {
            get
            {
                return _Current;
            }
        }
        #endregion

        #region Type Registrations
        public sealed class TypeRegistration
        {
            private int _hashCode;

            public Type Type { get; private set; }
            public string Name { get; private set; }

            public TypeRegistration(Type type)
                : this(type, string.Empty)
            {
            }

            public TypeRegistration(Type type, string name)
            {
                Type = type;
                Name = name;

                _hashCode = String.Concat(Type.FullName, "|", Name).GetHashCode();
            }

            public override bool Equals(object obj)
            {
                var typeRegistration = obj as TypeRegistration;

                if (typeRegistration == null)
                    return false;

                if (Type != typeRegistration.Type)
                    return false;

                if (String.Compare(Name, typeRegistration.Name, StringComparison.Ordinal) != 0)
                    return false;

                return true;
            }

            public override int GetHashCode()
            {
                return _hashCode;
            }
        }
        private readonly SafeDictionary<TypeRegistration, ObjectFactoryBase> _RegisteredTypes;
#if USE_OBJECT_CONSTRUCTOR 
        private delegate object ObjectConstructor(params object[] parameters);
        private static readonly SafeDictionary<ConstructorInfo, ObjectConstructor> _ObjectConstructorCache = new SafeDictionary<ConstructorInfo, ObjectConstructor>();
#endif
        #endregion

        #region Constructors
        public TinyIoCContainer()
        {
            _RegisteredTypes = new SafeDictionary<TypeRegistration, ObjectFactoryBase>();

            RegisterDefaultTypes();
        }

        TinyIoCContainer _Parent;
        private TinyIoCContainer(TinyIoCContainer parent)
            : this()
        {
            _Parent = parent;
        }
        #endregion

        #region Internal Methods
        private readonly object _AutoRegisterLock = new object();
        private void AutoRegisterInternal(IEnumerable<Assembly> assemblies, DuplicateImplementationActions duplicateAction, Func<Type, bool> registrationPredicate)
        {
            lock (_AutoRegisterLock)
            {
                var types = assemblies.SelectMany(a => a.SafeGetTypes()).Where(t => !IsIgnoredType(t, registrationPredicate)).ToList();

                var concreteTypes = from type in types
                                    where type.IsClass() && (type.IsAbstract() == false) && (type != this.GetType() && (type.DeclaringType != this.GetType()) && (!type.IsGenericTypeDefinition()))
                                    select type;

                foreach (var type in concreteTypes)
                {
                    try
                    {
                        RegisterInternal(type, string.Empty, GetDefaultObjectFactory(type, type));
                    }
                    catch (MethodAccessException)
                    {
                        // Ignore methods we can't access - added for Silverlight
                    }
                }

                var abstractInterfaceTypes = from type in types
                                             where ((type.IsInterface() || type.IsAbstract()) && (type.DeclaringType != this.GetType()) && (!type.IsGenericTypeDefinition()))
                                             select type;

                foreach (var type in abstractInterfaceTypes)
                {
                    var localType = type;
                    var implementations = from implementationType in concreteTypes
                                          where localType.IsAssignableFrom(implementationType)
                                          select implementationType;

                    if (implementations.Count() > 1)
                    {
                        if (duplicateAction == DuplicateImplementationActions.Fail)
                            throw new TinyIoCAutoRegistrationException(type, implementations);

                        if (duplicateAction == DuplicateImplementationActions.RegisterMultiple)
                        {
                            RegisterMultiple(type, implementations);
                        }
                    }

                    var firstImplementation = implementations.FirstOrDefault();
                    if (firstImplementation != null)
                    {
                        try
                        {
                            RegisterInternal(type, string.Empty, GetDefaultObjectFactory(type, firstImplementation));
                        }
                        catch (MethodAccessException)
                        {
                            // Ignore methods we can't access - added for Silverlight
                        }
                    }
                }
            }
        }

        private bool IsIgnoredAssembly(Assembly assembly)
        {
            // TODO - find a better way to remove "system" assemblies from the auto registration
            var ignoreChecks = new List<Func<Assembly, bool>>()
            {
                asm => asm.FullName.StartsWith("Microsoft.", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("System.", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("System,", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("CR_ExtUnitTest", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("mscorlib,", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("CR_VSTest", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("DevExpress.CodeRush", StringComparison.Ordinal),
                asm => asm.FullName.StartsWith("xunit.", StringComparison.Ordinal),
            };

            foreach (var check in ignoreChecks)
            {
                if (check(assembly))
                    return true;
            }

            return false;
        }

        private bool IsIgnoredType(Type type, Func<Type, bool> registrationPredicate)
        {
            // TODO - find a better way to remove "system" types from the auto registration
            var ignoreChecks = new List<Func<Type, bool>>()
            {
                t => t.FullName.StartsWith("System.", StringComparison.Ordinal),
                t => t.FullName.StartsWith("Microsoft.", StringComparison.Ordinal),
                t => t.IsPrimitive(),
#if !UNBOUND_GENERICS_GETCONSTRUCTORS
                t => t.IsGenericTypeDefinition(),
#endif
                t => (t.GetConstructors(BindingFlags.Instance | BindingFlags.Public).Length == 0) && !(t.IsInterface() || t.IsAbstract()),
            };

            if (registrationPredicate != null)
            {
                ignoreChecks.Add(t => !registrationPredicate(t));
            }

            foreach (var check in ignoreChecks)
            {
                if (check(type))
                    return true;
            }

            return false;
        }

        private void RegisterDefaultTypes()
        {
            Register<TinyIoCContainer>(this);

#if TINYMESSENGER
            // Only register the TinyMessenger singleton if we are the root container
            if (_Parent == null)
                Register<TinyMessenger.ITinyMessengerHub, TinyMessenger.TinyMessengerHub>();
#endif
        }

        private ObjectFactoryBase GetCurrentFactory(TypeRegistration registration)
        {
            ObjectFactoryBase current = null;

            _RegisteredTypes.TryGetValue(registration, out current);

            return current;
        }

        private RegisterOptions RegisterInternal(Type registerType, string name, ObjectFactoryBase factory)
        {
            var typeRegistration = new TypeRegistration(registerType, name);

            return AddUpdateRegistration(typeRegistration, factory);
        }

        private RegisterOptions AddUpdateRegistration(TypeRegistration typeRegistration, ObjectFactoryBase factory)
        {
            _RegisteredTypes[typeRegistration] = factory;

            return new RegisterOptions(this, typeRegistration);
        }

        private void RemoveRegistration(TypeRegistration typeRegistration)
        {
            _RegisteredTypes.Remove(typeRegistration);
        }

        private ObjectFactoryBase GetDefaultObjectFactory(Type registerType, Type registerImplementation)
        {
            //#if NETFX_CORE
            //			if (registerType.GetTypeInfo().IsInterface() || registerType.GetTypeInfo().IsAbstract())
            //#else
            if (registerType.IsInterface() || registerType.IsAbstract())
                //#endif
                return new SingletonFactory(registerType, registerImplementation);

            return new MultiInstanceFactory(registerType, registerImplementation);
        }

        private bool CanResolveInternal(TypeRegistration registration, NamedParameterOverloads parameters, ResolveOptions options)
        {
            if (parameters == null)
                throw new ArgumentNullException("parameters");

            Type checkType = registration.Type;
            string name = registration.Name;

            ObjectFactoryBase factory;
            if (_RegisteredTypes.TryGetValue(new TypeRegistration(checkType, name), out factory))
            {
                if (factory.AssumeConstruction)
                    return true;

                if (factory.Constructor == null)
                    return (GetBestConstructor(factory.CreatesType, parameters, options) != null) ? true : false;
                else
                    return CanConstruct(factory.Constructor, parameters, options);
            }

            // Fail if requesting named resolution and settings set to fail if unresolved
            // Or bubble up if we have a parent
            if (!string.IsNullOrEmpty(name) && options.NamedResolutionFailureAction == NamedResolutionFailureActions.Fail)
                return (_Parent != null) ? _Parent.CanResolveInternal(registration, parameters, options) : false;

            // Attemped unnamed fallback container resolution if relevant and requested
            if (!string.IsNullOrEmpty(name) && options.NamedResolutionFailureAction == NamedResolutionFailureActions.AttemptUnnamedResolution)
            {
                if (_RegisteredTypes.TryGetValue(new TypeRegistration(checkType), out factory))
                {
                    if (factory.AssumeConstruction)
                        return true;

                    return (GetBestConstructor(factory.CreatesType, parameters, options) != null) ? true : false;
                }
            }

            // Check if type is an automatic lazy factory request
            if (IsAutomaticLazyFactoryRequest(checkType))
                return true;

            // Check if type is an IEnumerable<ResolveType>
            if (IsIEnumerableRequest(registration.Type))
                return true;

            // Attempt unregistered construction if possible and requested
            // If we cant', bubble if we have a parent
            if ((options.UnregisteredResolutionAction == UnregisteredResolutionActions.AttemptResolve) || (checkType.IsGenericType() && options.UnregisteredResolutionAction == UnregisteredResolutionActions.GenericsOnly))
                return (GetBestConstructor(checkType, parameters, options) != null) ? true : (_Parent != null) ? _Parent.CanResolveInternal(registration, parameters, options) : false;

            // Bubble resolution up the container tree if we have a parent
            if (_Parent != null)
                return _Parent.CanResolveInternal(registration, parameters, options);

            return false;
        }

        private bool IsIEnumerableRequest(Type type)
        {
            if (!type.IsGenericType())
                return false;

            Type genericType = type.GetGenericTypeDefinition();

            if (genericType == typeof(IEnumerable<>))
                return true;

            return false;
        }

        private bool IsAutomaticLazyFactoryRequest(Type type)
        {
            if (!type.IsGenericType())
                return false;

            Type genericType = type.GetGenericTypeDefinition();

            // Just a func
            if (genericType == typeof(Func<>))
                return true;

            // 2 parameter func with string as first parameter (name)
            //#if NETFX_CORE
            //			if ((genericType == typeof(Func<,>) && type.GetTypeInfo().GenericTypeArguments[0] == typeof(string)))
            //#else
            if ((genericType == typeof(Func<,>) && type.GetGenericArguments()[0] == typeof(string)))
                //#endif
                return true;

            // 3 parameter func with string as first parameter (name) and IDictionary<string, object> as second (parameters)
            //#if NETFX_CORE
            //			if ((genericType == typeof(Func<,,>) && type.GetTypeInfo().GenericTypeArguments[0] == typeof(string) && type.GetTypeInfo().GenericTypeArguments[1] == typeof(IDictionary<String, object>)))
            //#else
            if ((genericType == typeof(Func<,,>) && type.GetGenericArguments()[0] == typeof(string) && type.GetGenericArguments()[1] == typeof(IDictionary<String, object>)))
                //#endif
                return true;

            return false;
        }

        private ObjectFactoryBase GetParentObjectFactory(TypeRegistration registration)
        {
            if (_Parent == null)
                return null;

            ObjectFactoryBase factory;
            if (_Parent._RegisteredTypes.TryGetValue(registration, out factory))
            {
                return factory.GetFactoryForChildContainer(registration.Type, _Parent, this);
            }

            return _Parent.GetParentObjectFactory(registration);
        }

        private object ResolveInternal(TypeRegistration registration, NamedParameterOverloads parameters, ResolveOptions options)
        {
            ObjectFactoryBase factory;

            // Attempt container resolution
            if (_RegisteredTypes.TryGetValue(registration, out factory))
            {
                try
                {
                    return factory.GetObject(registration.Type, this, parameters, options);
                }
                catch (TinyIoCResolutionException)
                {
                    throw;
                }
                catch (Exception ex)
                {
                    throw new TinyIoCResolutionException(registration.Type, ex);
                }
            }

#if RESOLVE_OPEN_GENERICS
            // Attempt container resolution of open generic
            if (registration.Type.IsGenericType())
            {
                var openTypeRegistration = new TypeRegistration(registration.Type.GetGenericTypeDefinition(),
                                                                registration.Name);

                if (_RegisteredTypes.TryGetValue(openTypeRegistration, out factory))
                {
                    try
                    {
                        return factory.GetObject(registration.Type, this, parameters, options);
                    }
                    catch (TinyIoCResolutionException)
                    {
                        throw;
                    }
                    catch (Exception ex)
                    {
                        throw new TinyIoCResolutionException(registration.Type, ex);
                    }
                }
            }
#endif

            // Attempt to get a factory from parent if we can
            var bubbledObjectFactory = GetParentObjectFactory(registration);
            if (bubbledObjectFactory != null)
            {
                try
                {
                    return bubbledObjectFactory.GetObject(registration.Type, this, parameters, options);
                }
                catch (TinyIoCResolutionException)
                {
                    throw;
                }
                catch (Exception ex)
                {
                    throw new TinyIoCResolutionException(registration.Type, ex);
                }
            }

            // Fail if requesting named resolution and settings set to fail if unresolved
            if (!string.IsNullOrEmpty(registration.Name) && options.NamedResolutionFailureAction == NamedResolutionFailureActions.Fail)
                throw new TinyIoCResolutionException(registration.Type);

            // Attemped unnamed fallback container resolution if relevant and requested
            if (!string.IsNullOrEmpty(registration.Name) && options.NamedResolutionFailureAction == NamedResolutionFailureActions.AttemptUnnamedResolution)
            {
                if (_RegisteredTypes.TryGetValue(new TypeRegistration(registration.Type, string.Empty), out factory))
                {
                    try
                    {
                        return factory.GetObject(registration.Type, this, parameters, options);
                    }
                    catch (TinyIoCResolutionException)
                    {
                        throw;
                    }
                    catch (Exception ex)
                    {
                        throw new TinyIoCResolutionException(registration.Type, ex);
                    }
                }
            }

#if EXPRESSIONS
            // Attempt to construct an automatic lazy factory if possible
            if (IsAutomaticLazyFactoryRequest(registration.Type))
                return GetLazyAutomaticFactoryRequest(registration.Type);
#endif
            if (IsIEnumerableRequest(registration.Type))
                return GetIEnumerableRequest(registration.Type);

            // Attempt unregistered construction if possible and requested
            if ((options.UnregisteredResolutionAction == UnregisteredResolutionActions.AttemptResolve) || (registration.Type.IsGenericType() && options.UnregisteredResolutionAction == UnregisteredResolutionActions.GenericsOnly))
            {
                if (!registration.Type.IsAbstract() && !registration.Type.IsInterface())
                    return ConstructType(null, registration.Type, parameters, options);
            }

            // Unable to resolve - throw
            throw new TinyIoCResolutionException(registration.Type);
        }

#if EXPRESSIONS
        private object GetLazyAutomaticFactoryRequest(Type type)
        {
            if (!type.IsGenericType())
                return null;

            Type genericType = type.GetGenericTypeDefinition();
            //#if NETFX_CORE
            //			Type[] genericArguments = type.GetTypeInfo().GenericTypeArguments.ToArray();
            //#else
            Type[] genericArguments = type.GetGenericArguments();
            //#endif

            // Just a func
            if (genericType == typeof(Func<>))
            {
                Type returnType = genericArguments[0];

                //#if NETFX_CORE
                //				MethodInfo resolveMethod = typeof(TinyIoCContainer).GetTypeInfo().GetDeclaredMethods("Resolve").First(mi => !mi.GetParameters().Any());
                //#else
                MethodInfo resolveMethod = typeof(TinyIoCContainer).GetMethod("Resolve", ArrayCache.Empty<Type>());
                //#endif
                resolveMethod = resolveMethod.MakeGenericMethod(returnType);

                var resolveCall = Expression.Call(Expression.Constant(this), resolveMethod);

                var resolveLambda = Expression.Lambda(resolveCall).Compile();

                return resolveLambda;
            }

            // 2 parameter func with string as first parameter (name)
            if ((genericType == typeof(Func<,>)) && (genericArguments[0] == typeof(string)))
            {
                Type returnType = genericArguments[1];

                //#if NETFX_CORE
                //				MethodInfo resolveMethod = typeof(TinyIoCContainer).GetTypeInfo().GetDeclaredMethods("Resolve").First(mi => mi.GetParameters().Length == 1 && mi.GetParameters()[0].GetType() == typeof(String));
                //#else
                MethodInfo resolveMethod = typeof(TinyIoCContainer).GetMethod("Resolve", new Type[] { typeof(String) });
                //#endif
                resolveMethod = resolveMethod.MakeGenericMethod(returnType);

                ParameterExpression[] resolveParameters = new ParameterExpression[] { Expression.Parameter(typeof(String), "name") };
                var resolveCall = Expression.Call(Expression.Constant(this), resolveMethod, resolveParameters);

                var resolveLambda = Expression.Lambda(resolveCall, resolveParameters).Compile();

                return resolveLambda;
            }

            // 3 parameter func with string as first parameter (name) and IDictionary<string, object> as second (parameters)
            //#if NETFX_CORE
            //			if ((genericType == typeof(Func<,,>) && type.GenericTypeArguments[0] == typeof(string) && type.GenericTypeArguments[1] == typeof(IDictionary<string, object>)))
            //#else
            if ((genericType == typeof(Func<,,>) && type.GetGenericArguments()[0] == typeof(string) && type.GetGenericArguments()[1] == typeof(IDictionary<string, object>)))
            //#endif
            {
                Type returnType = genericArguments[2];

                var name = Expression.Parameter(typeof(string), "name");
                var parameters = Expression.Parameter(typeof(IDictionary<string, object>), "parameters");

                //#if NETFX_CORE
                //				MethodInfo resolveMethod = typeof(TinyIoCContainer).GetTypeInfo().GetDeclaredMethods("Resolve").First(mi => mi.GetParameters().Length == 2 && mi.GetParameters()[0].GetType() == typeof(String) && mi.GetParameters()[1].GetType() == typeof(NamedParameterOverloads));
                //#else
                MethodInfo resolveMethod = typeof(TinyIoCContainer).GetMethod("Resolve", new Type[] { typeof(String), typeof(NamedParameterOverloads) });
                //#endif
                resolveMethod = resolveMethod.MakeGenericMethod(returnType);

                var resolveCall = Expression.Call(Expression.Constant(this), resolveMethod, name, Expression.Call(typeof(NamedParameterOverloads), "FromIDictionary", null, parameters));

                var resolveLambda = Expression.Lambda(resolveCall, name, parameters).Compile();

                return resolveLambda;
            }

            throw new TinyIoCResolutionException(type);
        }
#endif
        private object GetIEnumerableRequest(Type type)
        {
            //#if NETFX_CORE
            //			var genericResolveAllMethod = this.GetType().GetGenericMethod("ResolveAll", type.GenericTypeArguments, new[] { typeof(bool) });
            //#else
            var genericResolveAllMethod = this.GetType().GetGenericMethod(BindingFlags.Public | BindingFlags.Instance, "ResolveAll", type.GetGenericArguments(), new[] { typeof(bool) });
            //#endif

            return genericResolveAllMethod.Invoke(this, new object[] { false });
        }

        private bool CanConstruct(ConstructorInfo ctor, NamedParameterOverloads parameters, ResolveOptions options)
        {
            if (parameters == null)
                throw new ArgumentNullException("parameters");

            foreach (var parameter in ctor.GetParameters())
            {
                if (string.IsNullOrEmpty(parameter.Name))
                    return false;

                var isParameterOverload = parameters.ContainsKey(parameter.Name);

                //#if NETFX_CORE                
                //				if (parameter.ParameterType.GetTypeInfo().IsPrimitive && !isParameterOverload)
                //#else
                if (parameter.ParameterType.IsPrimitive() && !isParameterOverload)
                    //#endif
                    return false;

                if (!isParameterOverload && !CanResolveInternal(new TypeRegistration(parameter.ParameterType), NamedParameterOverloads.Default, options))
                    return false;
            }

            return true;
        }

        private ConstructorInfo GetBestConstructor(Type type, NamedParameterOverloads parameters, ResolveOptions options)
        {
            if (parameters == null)
                throw new ArgumentNullException("parameters");

            //#if NETFX_CORE
            //			if (type.GetTypeInfo().IsValueType)
            //#else
            if (type.IsValueType())
                //#endif
                return null;

            // Get constructors in reverse order based on the number of parameters
            // i.e. be as "greedy" as possible so we satify the most amount of dependencies possible
            var ctors = this.GetTypeConstructors(type);

            foreach (var ctor in ctors)
            {
                if (this.CanConstruct(ctor, parameters, options))
                    return ctor;
            }

            return null;
        }

        private IEnumerable<ConstructorInfo> GetTypeConstructors(Type type)
        {
            //#if NETFX_CORE
            //			return type.GetTypeInfo().DeclaredConstructors.OrderByDescending(ctor => ctor.GetParameters().Count());
            //#else
            return type.GetConstructors().OrderByDescending(ctor => ctor.GetParameters().Count());
            //#endif
        }

        private object ConstructType(Type requestedType, Type implementationType, ResolveOptions options)
        {
            return ConstructType(requestedType, implementationType, null, NamedParameterOverloads.Default, options);
        }

        private object ConstructType(Type requestedType, Type implementationType, ConstructorInfo constructor, ResolveOptions options)
        {
            return ConstructType(requestedType, implementationType, constructor, NamedParameterOverloads.Default, options);
        }

        private object ConstructType(Type requestedType, Type implementationType, NamedParameterOverloads parameters, ResolveOptions options)
        {
            return ConstructType(requestedType, implementationType, null, parameters, options);
        }

        private object ConstructType(Type requestedType, Type implementationType, ConstructorInfo constructor, NamedParameterOverloads parameters, ResolveOptions options)
        {
            var typeToConstruct = implementationType;

#if RESOLVE_OPEN_GENERICS
            if (implementationType.IsGenericTypeDefinition())
            {
                if (requestedType == null || !requestedType.IsGenericType() || !requestedType.GetGenericArguments().Any())
                    throw new TinyIoCResolutionException(typeToConstruct);

                typeToConstruct = typeToConstruct.MakeGenericType(requestedType.GetGenericArguments());
            }
#endif
            if (constructor == null)
            {
                // Try and get the best constructor that we can construct
                // if we can't construct any then get the constructor
                // with the least number of parameters so we can throw a meaningful
                // resolve exception
                constructor = GetBestConstructor(typeToConstruct, parameters, options) ?? GetTypeConstructors(typeToConstruct).LastOrDefault();
            }

            if (constructor == null)
                throw new TinyIoCResolutionException(typeToConstruct);

            var ctorParams = constructor.GetParameters();
            object[] args = new object[ctorParams.Count()];

            for (int parameterIndex = 0; parameterIndex < ctorParams.Count(); parameterIndex++)
            {
                var currentParam = ctorParams[parameterIndex];

                try
                {
                    args[parameterIndex] = parameters.ContainsKey(currentParam.Name) ?
                                            parameters[currentParam.Name] :
                                            ResolveInternal(
                                                new TypeRegistration(currentParam.ParameterType),
                                                NamedParameterOverloads.Default,
                                                options);
                }
                catch (TinyIoCResolutionException ex)
                {
                    // If a constructor parameter can't be resolved
                    // it will throw, so wrap it and throw that this can't
                    // be resolved.
                    throw new TinyIoCResolutionException(typeToConstruct, ex);
                }
                catch (Exception ex)
                {
                    throw new TinyIoCResolutionException(typeToConstruct, ex);
                }
            }

            try
            {
#if USE_OBJECT_CONSTRUCTOR
                var constructionDelegate = CreateObjectConstructionDelegateWithCache(constructor);
                return constructionDelegate.Invoke(args);
#else
                return constructor.Invoke(args);
#endif
            }
            catch (Exception ex)
            {
                throw new TinyIoCResolutionException(typeToConstruct, ex);
            }
        }

#if USE_OBJECT_CONSTRUCTOR 
        private static ObjectConstructor CreateObjectConstructionDelegateWithCache(ConstructorInfo constructor)
        {
            ObjectConstructor objectConstructor;
            if (_ObjectConstructorCache.TryGetValue(constructor, out objectConstructor))
                return objectConstructor;

            // We could lock the cache here, but there's no real side
            // effect to two threads creating the same ObjectConstructor
            // at the same time, compared to the cost of a lock for 
            // every creation.
            var constructorParams = constructor.GetParameters();
            var lambdaParams = Expression.Parameter(typeof(object[]), "parameters");
            var newParams = new Expression[constructorParams.Length];

            for (int i = 0; i < constructorParams.Length; i++)
            {
                var paramsParameter = Expression.ArrayIndex(lambdaParams, Expression.Constant(i));

                newParams[i] = Expression.Convert(paramsParameter, constructorParams[i].ParameterType);
            }

            var newExpression = Expression.New(constructor, newParams);

            var constructionLambda = Expression.Lambda(typeof(ObjectConstructor), newExpression, lambdaParams);

            objectConstructor = (ObjectConstructor)constructionLambda.Compile();

            _ObjectConstructorCache[constructor] = objectConstructor;
            return objectConstructor;
        }
#endif

        private void BuildUpInternal(object input, ResolveOptions resolveOptions)
        {
            //#if NETFX_CORE
            //			var properties = from property in input.GetType().GetTypeInfo().DeclaredProperties
            //							 where (property.GetMethod != null) && (property.SetMethod != null) && !property.PropertyType.GetTypeInfo().IsValueType
            //							 select property;
            //#else
            var properties = from property in input.GetType().GetProperties()
                             where (property.GetGetMethod() != null) && (property.GetSetMethod() != null) && !property.PropertyType.IsValueType()
                             select property;
            //#endif

            foreach (var property in properties)
            {
                if (property.GetValue(input, null) == null)
                {
                    try
                    {
                        property.SetValue(input, ResolveInternal(new TypeRegistration(property.PropertyType), NamedParameterOverloads.Default, resolveOptions), null);
                    }
                    catch (TinyIoCResolutionException)
                    {
                        // Catch any resolution errors and ignore them
                    }
                }
            }
        }

        private IEnumerable<TypeRegistration> GetParentRegistrationsForType(Type resolveType)
        {
            if (_Parent == null)
                return ArrayCache.Empty<TypeRegistration>();

            var registrations = _Parent._RegisteredTypes.Keys.Where(tr => tr.Type == resolveType);

            return registrations.Concat(_Parent.GetParentRegistrationsForType(resolveType));
        }

        private IEnumerable<object> ResolveAllInternal(Type resolveType, bool includeUnnamed)
        {
            var registrations = _RegisteredTypes.Keys.Where(tr => tr.Type == resolveType).Concat(GetParentRegistrationsForType(resolveType));

            if (!includeUnnamed)
                registrations = registrations.Where(tr => tr.Name != string.Empty);

            return registrations.Select(registration => this.ResolveInternal(registration, NamedParameterOverloads.Default, ResolveOptions.Default));
        }

        private static bool IsValidAssignment(Type registerType, Type registerImplementation)
        {
            //#if NETFX_CORE
            //			var registerTypeDef = registerType.GetTypeInfo();
            //			var registerImplementationDef = registerImplementation.GetTypeInfo();

            //			if (!registerTypeDef.IsGenericTypeDefinition)
            //			{
            //				if (!registerTypeDef.IsAssignableFrom(registerImplementationDef))
            //					return false;
            //			}
            //			else
            //			{
            //				if (registerTypeDef.IsInterface())
            //				{
            //					if (!registerImplementationDef.ImplementedInterfaces.Any(t => t.GetTypeInfo().Name == registerTypeDef.Name))
            //						return false;
            //				}
            //				else if (registerTypeDef.IsAbstract() && registerImplementationDef.BaseType() != registerType)
            //				{
            //					return false;
            //				}
            //			}
            //#else
            if (!registerType.IsGenericTypeDefinition())
            {
                if (!registerType.IsAssignableFrom(registerImplementation))
                    return false;
            }
            else
            {
                if (registerType.IsInterface())
                {
                    if (!registerImplementation.FindInterfaces((t, o) => t.Name == registerType.Name, null).Any())
                        return false;
                }
                else if (registerType.IsAbstract() && registerImplementation.BaseType() != registerType)
                {
                    return false;
                }
            }
            //#endif
            return true;
        }

        #endregion

        #region IDisposable Members
        bool disposed = false;
        public void Dispose()
        {
            if (!disposed)
            {
                disposed = true;

                _RegisteredTypes.Dispose();

                GC.SuppressFinalize(this);
            }
        }

        #endregion
    }

}

// reverse shim for WinRT SR changes...
#if !NETFX_CORE
namespace System.Reflection
{
    public static class ReverseTypeExtender
    {
        public static bool IsClass(this Type type)
        {
            return type.IsClass;
        }

        public static bool IsAbstract(this Type type)
        {
            return type.IsAbstract;
        }

        public static bool IsInterface(this Type type)
        {
            return type.IsInterface;
        }

        public static bool IsPrimitive(this Type type)
        {
            return type.IsPrimitive;
        }

        public static bool IsValueType(this Type type)
        {
            return type.IsValueType;
        }

        public static bool IsGenericType(this Type type)
        {
            return type.IsGenericType;
        }

        public static bool IsGenericParameter(this Type type)
        {
            return type.IsGenericParameter;
        }

        public static bool IsGenericTypeDefinition(this Type type)
        {
            return type.IsGenericTypeDefinition;
        }

        public static Type BaseType(this Type type)
        {
            return type.BaseType;
        }

        public static Assembly Assembly(this Type type)
        {
            return type.Assembly;
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Threading;
    using System.Threading.Tasks;
    using Nancy.Configuration;
    using Nancy.ModelBinding;
    using Nancy.Responses.Negotiation;
    using Nancy.Routing;
    using Nancy.Session;
    using Nancy.Validation;
    using Nancy.ViewEngines;

    /// <summary>
    /// Basic class containing the functionality for defining routes and actions in Nancy.
    /// </summary>
    public abstract class NancyModule : INancyModule, IHideObjectMembers
    {
        private readonly List<Route> routes;

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyModule"/> class.
        /// </summary>
        protected NancyModule()
            : this(String.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyModule"/> class.
        /// </summary>
        /// <param name="modulePath">A <see cref="string"/> containing the root relative path that all paths in the module will be a subset of.</param>
        protected NancyModule(string modulePath)
        {
            this.After = new AfterPipeline();
            this.Before = new BeforePipeline();
            this.OnError = new ErrorPipeline();

            this.ModulePath = modulePath;
            this.routes = new List<Route>();
        }

        /// <summary>
        /// Non-model specific data for rendering in the response
        /// </summary>
        public dynamic ViewBag
        {
            get
            {
                return this.Context == null ? null : this.Context.ViewBag;
            }
        }

        public dynamic Text
        {
            get { return this.Context.Text; }
        }

        /// <summary>
        /// Gets <see cref="RouteBuilder"/> for declaring actions for DELETE requests.
        /// </summary>
        /// <value>A <see cref="RouteBuilder"/> instance.</value>
        public RouteBuilder Delete
        {
            get { return new RouteBuilder("DELETE", this); }
        }

        /// <summary>
        /// Gets <see cref="RouteBuilder"/> for declaring actions for GET requests.
        /// </summary>
        /// <value>A <see cref="RouteBuilder"/> instance.</value>
        public RouteBuilder Get
        {
            get { return new RouteBuilder("GET", this); }
        }

        /// <summary>
        /// Gets <see cref="RouteBuilder"/> for declaring actions for HEAD requests.
        /// </summary>
        /// <value>A <see cref="RouteBuilder"/> instance.</value>
        public RouteBuilder Head
        {
            get { return new RouteBuilder("HEAD", this); }
        }

        /// <summary>
        /// Gets <see cref="RouteBuilder"/> for declaring actions for OPTIONS requests.
        /// </summary>
        /// <value>A <see cref="RouteBuilder"/> instance.</value>
        public RouteBuilder Options
        {
            get { return new RouteBuilder("OPTIONS", this); }
        }

        /// <summary>
        /// Gets <see cref="RouteBuilder"/> for declaring actions for PATCH requests.
        /// </summary>
        /// <value>A <see cref="RouteBuilder"/> instance.</value>
        public RouteBuilder Patch
        {
            get { return new RouteBuilder("PATCH", this); }
        }

        /// <summary>
        /// Gets <see cref="RouteBuilder"/> for declaring actions for POST requests.
        /// </summary>
        /// <value>A <see cref="RouteBuilder"/> instance.</value>
        public RouteBuilder Post
        {
            get { return new RouteBuilder("POST", this); }
        }

        /// <summary>
        /// Gets <see cref="RouteBuilder"/> for declaring actions for PUT requests.
        /// </summary>
        /// <value>A <see cref="RouteBuilder"/> instance.</value>
        public RouteBuilder Put
        {
            get { return new RouteBuilder("PUT", this); }
        }

        /// <summary>
        /// Get the root path of the routes in the current module.
        /// </summary>
        /// <value>
        /// A <see cref="T:System.String" /> containing the root path of the module or <see langword="null" />
        /// if no root path should be used.</value><remarks>All routes will be relative to this root path.
        /// </remarks>
        public string ModulePath { get; protected set; }

        /// <summary>
        /// Gets all declared routes by the module.
        /// </summary>
        /// <value>A <see cref="IEnumerable{T}"/> instance, containing all <see cref="Route"/> instances declared by the module.</value>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual IEnumerable<Route> Routes
        {
            get { return this.routes.AsReadOnly(); }
        }

        /// <summary>
        /// Gets the current session.
        /// </summary>
        public ISession Session
        {
            get { return this.Request.Session; }
        }

        /// <summary>
        /// Renders a view from inside a route handler.
        /// </summary>
        /// <value>A <see cref="ViewRenderer"/> instance that is used to determine which view that should be rendered.</value>
        public ViewRenderer View
        {
            get { return new ViewRenderer(this); }
        }

        /// <summary>
        /// Used to negotiate the content returned based on Accepts header.
        /// </summary>
        /// <value>A <see cref="Negotiator"/> instance that is used to negotiate the content returned.</value>
        public Negotiator Negotiate
        {
            get { return new Negotiator(this.Context); }
        }

        /// <summary>
        /// Gets or sets the validator locator.
        /// </summary>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public IModelValidatorLocator ValidatorLocator { get; set; }

        /// <summary>
        /// Gets or sets an <see cref="Request"/> instance that represents the current request.
        /// </summary>
        /// <value>An <see cref="Request"/> instance.</value>
        public virtual Request Request
        {
            get { return this.Context.Request; }
            set { this.Context.Request = value; }
        }

        /// <summary>
        /// The extension point for accessing the view engines in Nancy.
        /// </summary><value>An <see cref="IViewFactory" /> instance.</value>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public IViewFactory ViewFactory { get; set; }

        /// <summary><para>
        /// The post-request hook
        /// </para><para>
        /// The post-request hook is called after the response is created by the route execution.
        /// It can be used to rewrite the response or add/remove items from the context.
        /// </para>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        /// </summary>
        public AfterPipeline After { get; set; }

        /// <summary>
        /// <para>
        /// The pre-request hook
        /// </para>
        /// <para>
        /// The PreRequest hook is called prior to executing a route. If any item in the
        /// pre-request pipeline returns a response then the route is not executed and the
        /// response is returned.
        /// </para>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        /// </summary>
        public BeforePipeline Before { get; set; }

        /// <summary>
        /// <para>
        /// The error hook
        /// </para>
        /// <para>
        /// The error hook is called if an exception is thrown at any time during executing
        /// the PreRequest hook, a route and the PostRequest hook. It can be used to set
        /// the response and/or finish any ongoing tasks (close database session, etc).
        /// </para>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        /// </summary>
        public ErrorPipeline OnError { get; set; }

        /// <summary>
        /// Gets or sets the current Nancy context
        /// </summary>
        /// <value>A <see cref="NancyContext" /> instance.</value>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        public NancyContext Context { get; set; }

        /// <summary>
        /// An extension point for adding support for formatting response contents.
        /// </summary><value>This property will always return <see langword="null" /> because it acts as an extension point.</value><remarks>Extension methods to this property should always return <see cref="P:Nancy.NancyModuleBase.Response" /> or one of the types that can implicitly be types into a <see cref="P:Nancy.NancyModuleBase.Response" />.</remarks>
        public IResponseFormatter Response { get; set; }

        /// <summary>
        /// Gets or sets the model binder locator
        /// </summary>
        /// <remarks>This is automatically set by Nancy at runtime.</remarks>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public IModelBinderLocator ModelBinderLocator { get; set; }

        /// <summary>
        /// Gets or sets the model validation result
        /// </summary>
        /// <remarks>This is automatically set by Nancy at runtime when you run validation.</remarks>
        public virtual ModelValidationResult ModelValidationResult
        {
            get { return this.Context == null ? null : this.Context.ModelValidationResult; }
            set
            {
                if (this.Context != null)
                {
                    this.Context.ModelValidationResult = value;
                }
            }
        }

        /// <summary>
        /// Helper class for configuring a route handler in a module.
        /// </summary>
        public class RouteBuilder : IHideObjectMembers
        {
            private readonly string method;
            private readonly NancyModule parentModule;

            /// <summary>
            /// Initializes a new instance of the <see cref="RouteBuilder"/> class.
            /// </summary>
            /// <param name="method">The HTTP request method that the route should be available for.</param>
            /// <param name="parentModule">The <see cref="INancyModule"/> that the route is being configured for.</param>
            public RouteBuilder(string method, NancyModule parentModule)
            {
                this.method = method;
                this.parentModule = parentModule;
            }

            /// <summary>
            /// Defines an async route for the specified <paramref name="path"/>
            /// </summary>
            public Func<dynamic, CancellationToken, Task<dynamic>> this[string path]
            {
                set { this.AddRoute(string.Empty, path, null, value); }
            }

            /// <summary>
            /// Defines an async route for the specified <paramref name="path"/> and <paramref name="condition"/>.
            /// </summary>
            public Func<dynamic, CancellationToken, Task<dynamic>> this[string path, Func<NancyContext, bool> condition]
            {
                set { this.AddRoute(string.Empty, path, condition, value); }
            }

            /// <summary>
            /// Defines an async route for the specified <paramref name="path"/> and <paramref name="name"/>
            /// </summary>
            public Func<dynamic, CancellationToken, Task<dynamic>> this[string name, string path]
            {
                set { this.AddRoute(name, path, null, value); }
            }

            /// <summary>
            /// Defines an async route for the specified <paramref name="path"/>, <paramref name="condition"/> and <paramref name="name"/>
            /// </summary>
            public Func<dynamic, CancellationToken, Task<dynamic>> this[string name, string path, Func<NancyContext, bool> condition]
            {
                set { this.AddRoute(name, path, condition, value); }
            }

            protected void AddRoute(string name, string path, Func<NancyContext, bool> condition, Func<dynamic, CancellationToken, Task<dynamic>> value)
            {
                var fullPath = GetFullPath(path);

                this.parentModule.routes.Add(new Route(name, this.method, fullPath, condition, value));
            }

            private string GetFullPath(string path)
            {
                var relativePath = (path ?? string.Empty).Trim('/');
                var parentPath = (this.parentModule.ModulePath ?? string.Empty).Trim('/');

                if (string.IsNullOrEmpty(parentPath))
                {
                    return string.Concat("/", relativePath);
                }

                if (string.IsNullOrEmpty(relativePath))
                {
                    return string.Concat("/", parentPath);
                }

                return string.Concat("/", parentPath, "/", relativePath);
            }
        }
    }
}
namespace Nancy
{
    using System;
    using System.Threading;
    using System.Threading.Tasks;

    using Nancy.Bootstrapper;

    /// <summary>
    /// Defines the functionality of an engine that can handle Nancy <see cref="Request"/>s.
    /// </summary>
    public interface INancyEngine : IDisposable
    {
        /// <summary>
        /// Factory for creating an <see cref="IPipelines"/> instance for a incoming request.
        /// </summary>
        /// <value>An <see cref="IPipelines"/> instance.</value>
        Func<NancyContext, IPipelines> RequestPipelinesFactory { get; set; }

        /// <summary>
        /// Handles an incoming <see cref="Request"/> async.
        /// </summary>
        /// <param name="request">An <see cref="Request"/> instance, containing the information about the current request.</param>
        /// <param name="preRequest">Delegate to call before the request is processed</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        Task<NancyContext> HandleRequest(Request request, Func<NancyContext, NancyContext> preRequest, CancellationToken cancellationToken);
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Security.Cryptography.X509Certificates;
    using System.Text.RegularExpressions;
    using Extensions;
    using Helpers;
    using IO;
    using Session;

    /// <summary>
    /// Encapsulates HTTP-request information to an Nancy application.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay, nq}")]
    public class Request : IDisposable
    {
        private readonly List<HttpFile> files = new List<HttpFile>();
        private dynamic form = new DynamicDictionary();

        private IDictionary<string, string> cookies;

        /// <summary>
        /// Initializes a new instance of the <see cref="Request"/> class.
        /// </summary>
        /// <param name="method">The HTTP data transfer method used by the client.</param>
        /// <param name="path">The path of the requested resource, relative to the "Nancy root". This should not include the scheme, host name, or query portion of the URI.</param>
        /// <param name="scheme">The HTTP protocol that was used by the client.</param>
        public Request(string method, string path, string scheme)
            : this(method, new Url { Path = path, Scheme = scheme })
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Request"/> class.
        /// </summary>
        /// <param name="method">The HTTP data transfer method used by the client.</param>
        /// <param name="url">The <see cref="Url"/> of the requested resource</param>
        /// <param name="headers">The headers that was passed in by the client.</param>
        /// <param name="body">The <see cref="Stream"/> that represents the incoming HTTP body.</param>
        /// <param name="ip">The client's IP address</param>
        /// <param name="certificate">The client's certificate when present.</param>
        /// <param name="protocolVersion">The HTTP protocol version.</param>
        public Request(string method,
            Url url,
            RequestStream body = null,
            IDictionary<string, IEnumerable<string>> headers = null,
            string ip = null,
            byte[] certificate = null,
            string protocolVersion = null)
        {
            if (string.IsNullOrEmpty(method))
            {
                throw new ArgumentOutOfRangeException("method");
            }

            if (url == null)
            {
                throw new ArgumentNullException("url");
            }

            if (url.Path == null)
            {
                throw new ArgumentNullException("url.Path");
            }

            if (string.IsNullOrEmpty(url.Scheme))
            {
                throw new ArgumentOutOfRangeException("url.Scheme");
            }

            this.UserHostAddress = ip;

            this.Url = url;

            this.Method = method;

            this.Query = url.Query.AsQueryDictionary();

            this.Body = body ?? RequestStream.FromStream(new MemoryStream());

            this.Headers = new RequestHeaders(headers ?? new Dictionary<string, IEnumerable<string>>());

            this.Session = new NullSessionProvider();

            if (certificate != null && certificate.Length != 0)
            {
                this.ClientCertificate = new X509Certificate2(certificate);
            }

            this.ProtocolVersion = protocolVersion ?? string.Empty;

            if (string.IsNullOrEmpty(this.Url.Path))
            {
                this.Url.Path = "/";
            }

            this.ParseFormData();
            this.RewriteMethod();
        }

        /// <summary>
        /// Gets the certificate sent by the client.
        /// </summary>
        public X509Certificate ClientCertificate { get; private set; }

        /// <summary>
        /// Gets the HTTP protocol version.
        /// </summary>
        public string ProtocolVersion { get; private set; }

        /// <summary>
        /// Gets the IP address of the client
        /// </summary>
        public string UserHostAddress { get; private set; }

        /// <summary>
        /// Gets or sets the HTTP data transfer method used by the client.
        /// </summary>
        /// <value>The method.</value>
        public string Method { get; private set; }

        /// <summary>
        /// Gets the url
        /// </summary>
        public Url Url { get; private set; }

        /// <summary>
        /// Gets the request path, relative to the base path.
        /// Used for route matching etc.
        /// </summary>
        public string Path
        {
            get
            {
                return this.Url.Path;
            }
        }

        /// <summary>
        /// Gets the query string data of the requested resource.
        /// </summary>
        /// <value>A <see cref="DynamicDictionary"/>instance, containing the key/value pairs of query string data.</value>
        public dynamic Query { get; set; }

        /// <summary>
        /// Gets a <see cref="RequestStream"/> that can be used to read the incoming HTTP body
        /// </summary>
        /// <value>A <see cref="RequestStream"/> object representing the incoming HTTP body.</value>
        public RequestStream Body { get; private set; }

        /// <summary>
        /// Gets the request cookies.
        /// </summary>
        public IDictionary<string, string> Cookies
        {
            get { return this.cookies ?? (this.cookies = this.GetCookieData()); }
        }

        /// <summary>
        /// Gets the current session.
        /// </summary>
        public ISession Session { get; set; }

        /// <summary>
        /// Gets the cookie data from the request header if it exists
        /// </summary>
        /// <returns>Cookies dictionary</returns>
        private IDictionary<string, string> GetCookieData()
        {
            var cookieDictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            if (!this.Headers.Cookie.Any())
            {
                return cookieDictionary;
            }

            var values = this.Headers["cookie"].First().TrimEnd(';').Split(';');
            foreach (var parts in values.Select(c => c.Split(new[] { '=' }, 2)))
            {
                var cookieName = parts[0].Trim();
                string cookieValue;

                if (parts.Length == 1)
                {
                    //Cookie attribute
                    cookieValue = string.Empty;
                }
                else
                {
                    cookieValue = HttpUtility.UrlDecode(parts[1]);
                }

                cookieDictionary[cookieName] = cookieValue;
            }

            return cookieDictionary;
        }

        /// <summary>
        /// Gets a collection of files sent by the client-
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> instance, containing an <see cref="HttpFile"/> instance for each uploaded file.</value>
        public IEnumerable<HttpFile> Files
        {
            get { return this.files; }
        }

        /// <summary>
        /// Gets the form data of the request.
        /// </summary>
        /// <value>A <see cref="DynamicDictionary"/>instance, containing the key/value pairs of form data.</value>
        /// <remarks>Currently Nancy will only parse form data sent using the application/x-www-url-encoded mime-type.</remarks>
        public dynamic Form
        {
            get { return this.form; }
        }

        /// <summary>
        /// Gets the HTTP headers sent by the client.
        /// </summary>
        /// <value>An <see cref="IDictionary{TKey,TValue}"/> containing the name and values of the headers.</value>
        /// <remarks>The values are stored in an <see cref="IEnumerable{T}"/> of string to be compliant with multi-value headers.</remarks>
        public RequestHeaders Headers { get; private set; }

        public void Dispose()
        {
            ((IDisposable)this.Body).Dispose();
        }

        private void ParseFormData()
        {
            if (string.IsNullOrEmpty(this.Headers.ContentType))
            {
                return;
            }

            var contentType = this.Headers["content-type"].First();
            var mimeType = contentType.Split(';').First();
            if (mimeType.Equals("application/x-www-form-urlencoded", StringComparison.OrdinalIgnoreCase))
            {
                var reader = new StreamReader(this.Body);
                this.form = reader.ReadToEnd().AsQueryDictionary();
                this.Body.Position = 0;
            }

            if (!mimeType.Equals("multipart/form-data", StringComparison.OrdinalIgnoreCase))
            {
                return;
            }

            var boundary = Regex.Match(contentType, @"boundary=""?(?<token>[^\n\;\"" ]*)").Groups["token"].Value;
            var multipart = new HttpMultipart(this.Body, boundary);

            var formValues =
                new NameValueCollection(StaticConfiguration.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);

            foreach (var httpMultipartBoundary in multipart.GetBoundaries())
            {
                if (string.IsNullOrEmpty(httpMultipartBoundary.Filename))
                {
                    var reader =
                        new StreamReader(httpMultipartBoundary.Value);
                    formValues.Add(httpMultipartBoundary.Name, reader.ReadToEnd());

                }
                else
                {
                    this.files.Add(new HttpFile(httpMultipartBoundary));
                }
            }

            foreach (var key in formValues.AllKeys.Where(key => key != null))
            {
                this.form[key] = formValues[key];
            }

            this.Body.Position = 0;
        }

        private void RewriteMethod()
        {
            if (!this.Method.Equals("POST", StringComparison.OrdinalIgnoreCase))
            {
                return;
            }

            var overrides =
                new List<Tuple<string, string>>
                {
                    Tuple.Create("_method form input element", (string)this.Form["_method"]),
                    Tuple.Create("X-HTTP-Method-Override form input element", (string)this.Form["X-HTTP-Method-Override"]),
                    Tuple.Create("X-HTTP-Method-Override header", this.Headers["X-HTTP-Method-Override"].FirstOrDefault())
                };

            var providedOverride =
                overrides.Where(x => !string.IsNullOrEmpty(x.Item2))
                         .ToList();

            if (!providedOverride.Any())
            {
                return;
            }

            if (providedOverride.Count > 1)
            {
                var overrideSources =
                    string.Join(", ", providedOverride);

                var errorMessage =
                    string.Format("More than one HTTP method override was provided. The provided values where: {0}", overrideSources);

                throw new InvalidOperationException(errorMessage);
            }

            this.Method = providedOverride.Single().Item2;
        }

        private string DebuggerDisplay
        {
            get { return string.Format("{0} {1} {2}", this.Method, this.Url, this.ProtocolVersion).Trim(); }
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    using Nancy.Bootstrapper;
    using Cookies;
    using Diagnostics;
    using ErrorHandling;
    using Routing;

    using Helpers;
    using Nancy.Configuration;
    using Responses.Negotiation;

    /// <summary>
    /// Default engine for handling Nancy <see cref="Request"/>s.
    /// </summary>
    public class NancyEngine : INancyEngine
    {
        public const string ERROR_KEY = "ERROR_TRACE";
        public const string ERROR_EXCEPTION = "ERROR_EXCEPTION";

        private readonly IRequestDispatcher dispatcher;
        private readonly INancyContextFactory contextFactory;
        private readonly IRequestTracing requestTracing;
        private readonly IReadOnlyCollection<IStatusCodeHandler> statusCodeHandlers;
        private readonly IStaticContentProvider staticContentProvider;
        private readonly IResponseNegotiator negotiator;
        private readonly CancellationTokenSource engineDisposedCts;
        private readonly TraceConfiguration traceConfiguration;

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyEngine"/> class.
        /// </summary>
        /// <param name="dispatcher">An <see cref="IRouteResolver"/> instance that will be used to resolve a route, from the modules, that matches the incoming <see cref="Request"/>.</param>
        /// <param name="contextFactory">A factory for creating contexts</param>
        /// <param name="statusCodeHandlers">Error handlers</param>
        /// <param name="requestTracing">The request tracing instance.</param>
        /// <param name="staticContentProvider">The provider to use for serving static content</param>
        /// <param name="negotiator">The response negotiator.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public NancyEngine(IRequestDispatcher dispatcher,
            INancyContextFactory contextFactory,
            IEnumerable<IStatusCodeHandler> statusCodeHandlers,
            IRequestTracing requestTracing,
            IStaticContentProvider staticContentProvider,
            IResponseNegotiator negotiator,
            INancyEnvironment environment)
        {
            if (dispatcher == null)
            {
                throw new ArgumentNullException("dispatcher", "The resolver parameter cannot be null.");
            }

            if (contextFactory == null)
            {
                throw new ArgumentNullException("contextFactory");
            }

            if (statusCodeHandlers == null)
            {
                throw new ArgumentNullException("statusCodeHandlers");
            }

            if (requestTracing == null)
            {
                throw new ArgumentNullException("requestTracing");
            }

            if (staticContentProvider == null)
            {
                throw new ArgumentNullException("staticContentProvider");
            }

            if (negotiator == null)
            {
                throw new ArgumentNullException("negotiator");
            }

            this.dispatcher = dispatcher;
            this.contextFactory = contextFactory;
            this.statusCodeHandlers = statusCodeHandlers.ToArray();
            this.requestTracing = requestTracing;
            this.staticContentProvider = staticContentProvider;
            this.negotiator = negotiator;
            this.engineDisposedCts = new CancellationTokenSource();
            this.traceConfiguration = environment.GetValue<TraceConfiguration>();
        }

        /// <summary>
        /// Factory for creating an <see cref="IPipelines"/> instance for a incoming request.
        /// </summary>
        /// <value>An <see cref="IPipelines"/> instance.</value>
        public Func<NancyContext, IPipelines> RequestPipelinesFactory { get; set; }

        /// <summary>
        /// Handles an incoming <see cref="Request"/> async.
        /// </summary>
        /// <param name="request">An <see cref="Request"/> instance, containing the information about the current request.</param>
        /// <param name="preRequest">Delegate to call before the request is processed</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        public async Task<NancyContext> HandleRequest(Request request, Func<NancyContext, NancyContext> preRequest, CancellationToken cancellationToken)
        {
            using (var cts = CancellationTokenSource.CreateLinkedTokenSource(this.engineDisposedCts.Token, cancellationToken))
            {
                cts.Token.ThrowIfCancellationRequested();

                if (request == null)
                {
                    throw new ArgumentNullException("request", "The request parameter cannot be null.");
                }

                var context = this.contextFactory.Create(request);

                if (preRequest != null)
                {
                    context = preRequest(context);
                }

                var staticContentResponse = this.staticContentProvider.GetContent(context);
                if (staticContentResponse != null)
                {
                    context.Response = staticContentResponse;

                    return context;
                }

                var pipelines = this.RequestPipelinesFactory.Invoke(context);

                var nancyContext = await this.InvokeRequestLifeCycle(context, cts.Token, pipelines)
                    .ConfigureAwait(false);

                this.CheckStatusCodeHandler(nancyContext);

                this.SaveTraceInformation(nancyContext);

                return nancyContext;
            }
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public virtual void Dispose()
        {
            this.engineDisposedCts.Cancel();
        }

        private void SaveTraceInformation(NancyContext ctx)
        {
            if (!this.EnableTracing(ctx))
            {
                return;
            }

            if (ctx.Request == null || ctx.Response == null)
            {
                return;
            }

            var sessionGuid = this.GetDiagnosticsSessionGuid(ctx);

            ctx.Trace.RequestData = ctx.Request;
            ctx.Trace.ResponseData = ctx.Response;

            this.requestTracing.AddRequestDiagnosticToSession(sessionGuid, ctx);

            this.UpdateTraceCookie(ctx, sessionGuid);
        }

        private bool EnableTracing(NancyContext ctx)
        {
            return this.traceConfiguration.Enabled && !ctx.Items.ContainsKey(DiagnosticsHook.ItemsKey);
        }

        private Guid GetDiagnosticsSessionGuid(NancyContext ctx)
        {
            string sessionId;
            if (!ctx.Request.Cookies.TryGetValue("__NCTRACE", out sessionId))
            {
                return this.requestTracing.CreateSession();
            }

            Guid sessionGuid;
            if (!Guid.TryParse(sessionId, out sessionGuid))
            {
                return this.requestTracing.CreateSession();
            }

            if (!this.requestTracing.IsValidSessionId(sessionGuid))
            {
                return this.requestTracing.CreateSession();
            }

            return sessionGuid;
        }

        private void UpdateTraceCookie(NancyContext ctx, Guid sessionGuid)
        {
            var cookie = new NancyCookie("__NCTRACE", sessionGuid.ToString(), true)
            {
                Expires = DateTime.Now.AddMinutes(30)
            };

            ctx.Response = ctx.Response.WithCookie(cookie);
        }

        private void CheckStatusCodeHandler(NancyContext context)
        {
            if (context.Response == null)
            {
                return;
            }

            IStatusCodeHandler defaultHandler = null;
            IStatusCodeHandler customHandler = null;

            foreach (var statusCodeHandler in this.statusCodeHandlers)
            {
                if (!statusCodeHandler.HandlesStatusCode(context.Response.StatusCode, context))
                {
                    continue;
                }

                if (defaultHandler == null && (statusCodeHandler is DefaultStatusCodeHandler))
                {
                    defaultHandler = statusCodeHandler;
                    continue;
                }

                if (customHandler == null && !(statusCodeHandler is DefaultStatusCodeHandler))
                {
                    customHandler = statusCodeHandler;
                    continue;
                }

                if ((defaultHandler != null) && (customHandler != null))
                {
                    break;
                }
            }

            var handler = customHandler ?? defaultHandler;

            if (handler == null)
            {
                return;
            }

            handler.Handle(context.Response.StatusCode, context);
        }

        private async Task<NancyContext> InvokeRequestLifeCycle(NancyContext context, CancellationToken cancellationToken, IPipelines pipelines)
        {
            try
            {
                var response = await InvokePreRequestHook(context, cancellationToken, pipelines.BeforeRequest).ConfigureAwait(false) ??
                               await this.dispatcher.Dispatch(context, cancellationToken).ConfigureAwait(false);

                context.Response = response;

                await this.InvokePostRequestHook(context, cancellationToken, pipelines.AfterRequest).ConfigureAwait(false);

                await response.PreExecute(context).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                this.InvokeOnErrorHook(context, pipelines.OnError, ex);
            }

            return context;
        }

        private static Task<Response> InvokePreRequestHook(NancyContext context, CancellationToken cancellationToken, BeforePipeline pipeline)
        {
            return pipeline == null ? Task.FromResult<Response>(null) : pipeline.Invoke(context, cancellationToken);
        }

        private Task InvokePostRequestHook(NancyContext context, CancellationToken cancellationToken, AfterPipeline pipeline)
        {
            return pipeline == null ? TaskHelpers.CompletedTask : pipeline.Invoke(context, cancellationToken);
        }

        private void InvokeOnErrorHook(NancyContext context, ErrorPipeline pipeline, Exception ex)
        {
            try
            {
                if (pipeline == null)
                {
                    throw new RequestExecutionException(ex);
                }

                var onErrorResult = pipeline.Invoke(context, ex);

                if (onErrorResult == null)
                {
                    throw new RequestExecutionException(ex);
                }

                context.Response = this.negotiator.NegotiateResponse(onErrorResult, context);
            }
            catch (Exception e)
            {
                context.Response = new Response { StatusCode = HttpStatusCode.InternalServerError };
                context.Items[ERROR_KEY] = e.ToString();
                context.Items[ERROR_EXCEPTION] = e;
            }
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Threading.Tasks;

    using Nancy.Cookies;
    using Nancy.Helpers;
    using Nancy.Responses;

    /// <summary>
    /// Encapsulates HTTP-response information from an Nancy operation.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay, nq}")]
    public class Response : IDisposable
    {
        /// <summary>
        /// Null object representing no body
        /// </summary>
        public static Action<Stream> NoBody = s => { };

        private string contentType;

        /// <summary>
        /// Initializes a new instance of the <see cref="Response"/> class.
        /// </summary>
        public Response()
        {
            this.Contents = NoBody;
            this.ContentType = "text/html";
            this.Headers = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            this.StatusCode = HttpStatusCode.OK;
            this.Cookies = new List<INancyCookie>(2);
        }

        /// <summary>
        /// Gets or sets the type of the content.
        /// </summary>
        /// <value>The type of the content.</value>
        /// <remarks>The default value is <c>text/html</c>.</remarks>
        public string ContentType
        {
            get { return Headers.ContainsKey("content-type") ? Headers["content-type"] : this.contentType; }
            set { this.contentType = value; }
        }

        /// <summary>
        /// Gets the delegate that will render contents to the response stream.
        /// </summary>
        /// <value>An <see cref="Action{T}"/> delegate, containing the code that will render contents to the response stream.</value>
        /// <remarks>The host of Nancy will pass in the output stream after the response has been handed back to it by Nancy.</remarks>
        public Action<Stream> Contents { get; set; }

        /// <summary>
        /// Gets the collection of HTTP response headers that should be sent back to the client.
        /// </summary>
        /// <value>An <see cref="IDictionary{TKey,TValue}"/> instance, containing the key/value pair of headers.</value>
        public IDictionary<string, string> Headers { get; set; }

        /// <summary>
        /// Gets or sets the HTTP status code that should be sent back to the client.
        /// </summary>
        /// <value>A <see cref="HttpStatusCode"/> value.</value>
        public HttpStatusCode StatusCode { get; set; }

        /// <summary>
        /// Gets or sets a text description of the HTTP status code returned to the client.
        /// </summary>
        /// <value>The HTTP status code description.</value>
        public string ReasonPhrase { get; set; }

        /// <summary>
        /// Gets the <see cref="INancyCookie"/> instances that are associated with the response.
        /// </summary>
        /// <value>A <see cref="IList{T}"/> instance, containing <see cref="INancyCookie"/> instances.</value>
        public IList<INancyCookie> Cookies { get; private set; }

        /// <summary>
        /// Executes at the end of the nancy execution pipeline and before control is passed back to the hosting.
        /// Can be used to pre-render/validate views while still inside the main pipeline/error handling.
        /// </summary>
        /// <param name="context">Nancy context</param>
        /// <returns>Task for completion/erroring</returns>
        public virtual Task PreExecute(NancyContext context)
        {
            return TaskHelpers.CompletedTask;
        }

        /// <summary>
        /// Implicitly cast an <see cref="HttpStatusCode"/> value to a <see cref="Response"/> instance, with the <see cref="StatusCode"/>
        /// set to the value of the <see cref="HttpStatusCode"/>.
        /// </summary>
        /// <param name="statusCode">The <see cref="HttpStatusCode"/> value that is being cast from.</param>
        /// <returns>A <see cref="Response"/> instance.</returns>
        public static implicit operator Response(HttpStatusCode statusCode)
        {
            return new Response { StatusCode = statusCode };
        }

        /// <summary>
        /// Implicitly cast an int value to a <see cref="Response"/> instance, with the <see cref="StatusCode"/>
        /// set to the value of the int.
        /// </summary>
        /// <param name="statusCode">The int value that is being cast from.</param>
        /// <returns>A <see cref="Response"/> instance.</returns>
        public static implicit operator Response(int statusCode)
        {
            return new Response { StatusCode = (HttpStatusCode)statusCode };
        }

        /// <summary>
        /// Implicitly cast an string instance to a <see cref="Response"/> instance, with the <see cref="Contents"/>
        /// set to the value of the string.
        /// </summary>
        /// <param name="contents">The string that is being cast from.</param>
        /// <returns>A <see cref="Response"/> instance.</returns>
        public static implicit operator Response(string contents)
        {
            return new TextResponse(contents);
        }

        /// <summary>
        /// Implicitly cast an <see cref="Action{T}"/>, where T is a <see cref="Stream"/>, instance to
        /// a <see cref="Response"/> instance, with the <see cref="Contents"/> set to the value of the action.
        /// </summary>
        /// <param name="streamFactory">The <see cref="Action{T}"/> instance that is being cast from.</param>
        /// <returns>A <see cref="Response"/> instance.</returns>
        public static implicit operator Response(Action<Stream> streamFactory)
        {
            return new Response { Contents = streamFactory };
        }

        /// <summary>
        /// Implicitly cast a <see cref="DynamicDictionaryValue"/> instance to a <see cref="Response"/> instance,
        /// with the <see cref="Contents"/> set to the value of the <see cref="DynamicDictionaryValue"/>.
        /// </summary>
        /// <param name="value">The <see cref="DynamicDictionaryValue"/> instance that is being cast from.</param>
        /// <returns>A <see cref="Response"/> instance.</returns>
        public static implicit operator Response(DynamicDictionaryValue value)
        {
            return new Response { Contents = GetStringContents(value) };
        }

        /// <summary>
        /// Converts a string content value to a response action.
        /// </summary>
        /// <param name="contents">The string containing the content.</param>
        /// <returns>A response action that will write the content of the string to the response stream.</returns>
        protected static Action<Stream> GetStringContents(string contents)
        {
            return stream =>
            {
                var writer = new StreamWriter(stream) { AutoFlush = true };
                writer.Write(contents);
            };
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        /// <remarks>This method can be overridden in sub-classes to dispose of response specific resources.</remarks>
        public virtual void Dispose()
        {
        }

        private string DebuggerDisplay
        {
            get { return string.Join(" ", new string[] { this.StatusCode.ToString(), this.ReasonPhrase, this.ContentType }.Where(x => !string.IsNullOrEmpty(x)).ToArray()); }
        }
    }
}
namespace Nancy
{
    public class NotFoundResponse : Response
    {
        public NotFoundResponse()
        {
            this.ContentType = "text/html";
            this.StatusCode = HttpStatusCode.NotFound;
        }
    }
}
namespace Nancy.Routing
{
    /// <summary>
    /// Returns a route that matches the request
    /// </summary>
    public interface IRouteResolver
    {
        /// <summary>
        /// Gets the route, and the corresponding parameter dictionary from the URL
        /// </summary>
        /// <param name="context">Current context</param>
        /// <returns>A <see cref="ResolveResult"/> containing the resolved route information.</returns>
        ResolveResult Resolve(NancyContext context);
    }
}
namespace Nancy.Routing
{
    using System.Threading.Tasks;

    /// <summary>
    /// Route that is returned when the path could not be matched.
    /// </summary>
    /// <remarks>This is equal to sending back the 404 HTTP status code.</remarks>
    public class NotFoundRoute : Route
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NotFoundRoute"/> type, for the
        /// specified <paramref name="path"/> and <paramref name="method"/>.
        /// </summary>
        /// <param name="method">The HTTP method of the route.</param>
        /// <param name="path">The path of the route.</param>
        public NotFoundRoute(string method, string path)
            : base(method, path, null, (x, c) => Task.FromResult<dynamic>(new NotFoundResponse()))
        {
        }
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Diagnostics;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Stores information about a declared route in Nancy.
    /// </summary>
    [DebuggerDisplay("{Description.DebuggerDisplay, nq}")]
    public class Route
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Route"/> type, with the specified <see cref="RouteDescription"/>.
        /// </summary>
        /// <param name="description"></param>
        /// <param name="action">The action that should take place when the route is invoked.</param>
        public Route(RouteDescription description, Func<dynamic, CancellationToken, Task<dynamic>> action)
        {
            if (action == null)
            {
                throw new ArgumentNullException("action");
            }

            this.Description = description;
            this.Action = action;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Route"/> type, with the specified definition.
        /// </summary>
        /// <param name="name">Route name</param>
        /// <param name="method">The HTTP method that the route is declared for.</param>
        /// <param name="path">The path that the route is declared for.</param>
        /// <param name="condition">A condition that needs to be satisfied inorder for the route to be eligible for invocation.</param>
        /// <param name="action">The action that should take place when the route is invoked.</param>
        public Route(string name, string method, string path, Func<NancyContext, bool> condition, Func<dynamic, CancellationToken, Task<dynamic>> action)
            : this(new RouteDescription(name, method, path, condition), action)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Route"/> type, with the specified definition.
        /// </summary>
        /// <param name="method">The HTTP method that the route is declared for.</param>
        /// <param name="path">The path that the route is declared for.</param>
        /// <param name="condition">A condition that needs to be satisfied inorder for the route to be eligiable for invocation.</param>
        /// <param name="action">The action that should take place when the route is invoked.</param>
        public Route(string method, string path, Func<NancyContext, bool> condition, Func<dynamic, CancellationToken, Task<dynamic>> action)
            : this(string.Empty, method, path, condition, action)
        {
        }

        /// <summary>
        /// Gets or sets the action that should take place when the route is invoked.
        /// </summary>
        /// <value>A <see cref="Func{T,K}"/> that represents the action of the route.</value>
        public Func<dynamic, CancellationToken, Task<dynamic>> Action { get; set; }

        /// <summary>
        /// Gets the description of the route.
        /// </summary>
        /// <value>A <see cref="RouteDescription"/> instance.</value>
        public RouteDescription Description { get; private set; }

        /// <summary>
        /// Invokes the route with the provided <paramref name="parameters"/>.
        /// </summary>
        /// <param name="parameters">A <see cref="DynamicDictionary"/> that contains the parameters that should be passed to the route.</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>A (hot) task of <see cref="Response"/> instance.</returns>
        public Task<dynamic> Invoke(DynamicDictionary parameters, CancellationToken cancellationToken)
        {
            return this.Action.Invoke(parameters, cancellationToken);
        }

        /// <summary>
        /// Creates a route from a sync delegate signature
        /// </summary>
        /// <param name="description"></param>
        /// <param name="syncFunc">The action that should take place when the route is invoked.</param>
        /// <returns>A Route instance</returns>
        [Obsolete("Sync routes are deprecated (see LegacyNancyModule)")]
        public static Route FromSync(RouteDescription description, Func<dynamic, dynamic> syncFunc)
        {
            return new Route(description, Wrap(syncFunc));
        }

        /// <summary>
        /// Creates a route from a sync delegate signature
        /// </summary>
        /// <param name="method">The HTTP method that the route is declared for.</param>
        /// <param name="path">The path that the route is declared for.</param>
        /// <param name="condition">A condition that needs to be satisfied inorder for the route to be eligiable for invocation.</param>
        /// <param name="syncFunc">The action that should take place when the route is invoked.</param>
        /// <returns>A Route instance</returns>
        [Obsolete("Sync routes are deprecated (see LegacyNancyModule)")]
        public static Route FromSync(string method, string path, Func<NancyContext, bool> condition, Func<dynamic, dynamic> syncFunc)
        {
            return FromSync(string.Empty, method, path, condition, syncFunc);
        }

        /// <summary>
        /// Creates a route from a sync delegate signature
        /// </summary>
        /// <param name="name">Route name</param>
        /// <param name="method">The HTTP method that the route is declared for.</param>
        /// <param name="path">The path that the route is declared for.</param>
        /// <param name="condition">A condition that needs to be satisfied inorder for the route to be eligible for invocation.</param>
        /// <param name="syncFunc">The action that should take place when the route is invoked.</param>
        /// <returns>A Route instance</returns>
        [Obsolete("Sync routes are deprecated (see LegacyNancyModule)")]
        public static Route FromSync(string name, string method, string path, Func<NancyContext, bool> condition, Func<dynamic, dynamic> syncFunc)
        {
            return FromSync(new RouteDescription(name, method, path, condition), syncFunc);
        }

        /// <summary>
        /// Wraps a sync delegate in a delegate that returns a task
        /// </summary>
        /// <param name="syncFunc">Sync delegate</param>
        /// <returns>Task wrapped version</returns>
        private static Func<dynamic, CancellationToken, Task<dynamic>> Wrap(Func<object, object> syncFunc)
        {
            return (parameters, context) =>
            {
                var tcs = new TaskCompletionSource<dynamic>();

                try
                {
                    var result = syncFunc.Invoke(parameters);

                    tcs.SetResult(result);
                }
                catch (Exception e)
                {
                    tcs.SetException(e);
                }

                return tcs.Task;
            };
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Dynamic;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// A dictionary that supports dynamic access.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay, nq}")]
    public class DynamicDictionary : DynamicObject, IEquatable<DynamicDictionary>, IHideObjectMembers, IEnumerable<string>, IDictionary<string, object>
    {
        private readonly IDictionary<string, dynamic> dictionary =
            new Dictionary<string, dynamic>(StaticConfiguration.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);


        /// <summary>
        /// Returns an empty dynamic dictionary.
        /// </summary>
        /// <value>A <see cref="DynamicDictionary"/> instance.</value>
        public static DynamicDictionary Empty
        {
            get
            {
                return new DynamicDictionary();
            }
        }

        /// <summary>
        /// Creates a dynamic dictionary from an <see cref="IDictionary{TKey,TValue}"/> instance.
        /// </summary>
        /// <param name="values">An <see cref="IDictionary{TKey,TValue}"/> instance, that the dynamic dictionary should be created from.</param>
        /// <returns>An <see cref="DynamicDictionary"/> instance.</returns>
        public static DynamicDictionary Create(IDictionary<string, object> values)
        {
            var instance = new DynamicDictionary();

            foreach (var key in values.Keys)
            {
                instance[key] = values[key];
            }

            return instance;
        }

        /// <summary>
        /// Provides the implementation for operations that set member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations such as setting a value for a property.
        /// </summary>
        /// <returns>true if the operation is successful; otherwise, false. If this method returns false, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        /// <param name="binder">Provides information about the object that called the dynamic operation. The binder.Name property provides the name of the member to which the value is being assigned. For example, for the statement sampleObject.SampleProperty = "Test", where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, binder.Name returns "SampleProperty". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param><param name="value">The value to set to the member. For example, for sampleObject.SampleProperty = "Test", where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, the <paramref name="value"/> is "Test".</param>
        public override bool TrySetMember(SetMemberBinder binder, object value)
        {
            this[binder.Name] = value;
            return true;
        }

        /// <summary>
        /// Provides the implementation for operations that get member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations such as getting a value for a property.
        /// </summary>
        /// <returns>true if the operation is successful; otherwise, false. If this method returns false, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)</returns>
        /// <param name="binder">Provides information about the object that called the dynamic operation. The binder.Name property provides the name of the member on which the dynamic operation is performed. For example, for the Console.WriteLine(sampleObject.SampleProperty) statement, where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, binder.Name returns "SampleProperty". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param><param name="result">The result of the get operation. For example, if the method is called for a property, you can assign the property value to <paramref name="result"/>.</param>
        public override bool TryGetMember(GetMemberBinder binder, out object result)
        {
            if (!dictionary.TryGetValue(binder.Name, out result))
            {
                result = new DynamicDictionaryValue(null);
            }

            return true;
        }

        /// <summary>
        /// Returns the enumeration of all dynamic member names.
        /// </summary>
        /// <returns>A <see cref="IEnumerable{T}"/> that contains dynamic member names.</returns>
        public override IEnumerable<string> GetDynamicMemberNames()
        {
            return dictionary.Keys;
        }

        /// <summary>
        /// Returns the enumeration of all dynamic member names.
        /// </summary>
        /// <returns>A <see cref="IEnumerable{T}"/> that contains dynamic member names.</returns>
        public IEnumerator<string> GetEnumerator()
        {
            return dictionary.Keys.GetEnumerator();
        }

        /// <summary>
        /// Returns the enumeration of all dynamic member names.
        /// </summary>
        /// <returns>A <see cref="IEnumerator"/> that contains dynamic member names.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return dictionary.Keys.GetEnumerator();
        }

        /// <summary>
        /// Gets or sets the <see cref="DynamicDictionaryValue"/> with the specified name.
        /// </summary>
        /// <value>A <see cref="DynamicDictionaryValue"/> instance containing a value.</value>
        public dynamic this[string name]
        {
            get
            {
                name = GetNeutralKey(name);

                dynamic member;
                if (!dictionary.TryGetValue(name, out member))
                {
                    member = new DynamicDictionaryValue(null);
                }

                return member;
            }
            set
            {
                name = GetNeutralKey(name);

                dictionary[name] = value is DynamicDictionaryValue ? value : new DynamicDictionaryValue(value);
            }
        }

        /// <summary>
        /// Indicates whether the current <see cref="DynamicDictionary"/> is equal to another object of the same type.
        /// </summary>
        /// <returns><see langword="true"/> if the current instance is equal to the <paramref name="other"/> parameter; otherwise, <see langword="false"/>.</returns>
        /// <param name="other">An <see cref="DynamicDictionary"/> instance to compare with this instance.</param>
        public bool Equals(DynamicDictionary other)
        {
            if (ReferenceEquals(null, other))
            {
                return false;
            }

            return ReferenceEquals(this, other) || Equals(other.dictionary, this.dictionary);
        }

        /// <summary>
        /// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
        /// </summary>
        /// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
        /// <returns><see langword="true"/> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <see langword="false"/>.</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
            {
                return false;
            }

            if (ReferenceEquals(this, obj))
            {
                return true;
            }

            return obj.GetType() == typeof(DynamicDictionary) && this.Equals((DynamicDictionary)obj);
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.</returns>
        IEnumerator<KeyValuePair<string, dynamic>> IEnumerable<KeyValuePair<string, object>>.GetEnumerator()
        {
            return this.dictionary.GetEnumerator();
        }

        /// <summary>
        /// Returns a hash code for this <see cref="DynamicDictionary"/>.
        /// </summary>
        /// <returns> A hash code for this <see cref="DynamicDictionary"/>, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        public override int GetHashCode()
        {
            return (dictionary != null ? dictionary.GetHashCode() : 0);
        }

        /// <summary>
        /// Adds an element with the provided key and value to the <see cref="DynamicDictionary"/>.
        /// </summary>
        /// <param name="key">The object to use as the key of the element to add.</param>
        /// <param name="value">The object to use as the value of the element to add.</param>
        public void Add(string key, dynamic value)
        {
            this[key] = value;
        }

        /// <summary>
        /// Adds an item to the <see cref="DynamicDictionary"/>.
        /// </summary>
        /// <param name="item">The object to add to the <see cref="DynamicDictionary"/>.</param>
        public void Add(KeyValuePair<string, dynamic> item)
        {
            this[item.Key] = item.Value;
        }

        /// <summary>
        /// Determines whether the <see cref="DynamicDictionary"/> contains an element with the specified key.
        /// </summary>
        /// <returns><see langword="true" /> if the <see cref="DynamicDictionary"/> contains an element with the key; otherwise, <see langword="false" />.
        /// </returns>
        /// <param name="key">The key to locate in the <see cref="DynamicDictionary"/>.</param>
        public bool ContainsKey(string key)
        {
            key = GetNeutralKey(key);
            return this.dictionary.ContainsKey(key);
        }

        /// <summary>
        /// Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the <see cref="DynamicDictionary"/>.
        /// </summary>
        /// <returns>An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the <see cref="DynamicDictionary"/>.</returns>
        public ICollection<string> Keys
        {
            get { return this.dictionary.Keys; }
        }

        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        /// <returns><see langword="true" /> if the <see cref="DynamicDictionary"/> contains an element with the specified key; otherwise, <see langword="false" />.</returns>
        /// <param name="key">The key whose value to get.</param>
        /// <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
        public bool TryGetValue(string key, out dynamic value)
        {
            key = GetNeutralKey(key);
            return this.dictionary.TryGetValue(key, out value);
        }

        /// <summary>
        /// Removes all items from the <see cref="DynamicDictionary"/>.
        /// </summary>
        public void Clear()
        {
            this.dictionary.Clear();
        }

        /// <summary>
        /// Gets the number of elements contained in the <see cref="DynamicDictionary"/>.
        /// </summary>
        /// <returns>The number of elements contained in the <see cref="DynamicDictionary"/>.</returns>
        public int Count
        {
            get { return this.dictionary.Count; }
        }

        /// <summary>
        /// Determines whether the <see cref="DynamicDictionary"/> contains a specific value.
        /// </summary>
        /// <returns><see langword="true" /> if <paramref name="item"/> is found in the <see cref="DynamicDictionary"/>; otherwise, <see langword="false" />.
        /// </returns>
        /// <param name="item">The object to locate in the <see cref="DynamicDictionary"/>.</param>
        public bool Contains(KeyValuePair<string, dynamic> item)
        {
            var dynamicValueKeyValuePair =
                GetDynamicKeyValuePair(item);

            return this.dictionary.Contains(dynamicValueKeyValuePair);
        }

        /// <summary>
        /// Copies the elements of the <see cref="DynamicDictionary"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from the <see cref="DynamicDictionary"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        public void CopyTo(KeyValuePair<string, dynamic>[] array, int arrayIndex)
        {
            this.dictionary.CopyTo(array, arrayIndex);
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="DynamicDictionary"/> is read-only.
        /// </summary>
        /// <returns>Always returns <see langword="false" />.</returns>
        public bool IsReadOnly
        {
            get { return false; }
        }

        /// <summary>
        /// Removes the element with the specified key from the <see cref="DynamicDictionary"/>.
        /// </summary>
        /// <returns><see langword="true" /> if the element is successfully removed; otherwise, <see langword="false" />.</returns>
        /// <param name="key">The key of the element to remove.</param>
        public bool Remove(string key)
        {
            key = GetNeutralKey(key);
            return this.dictionary.Remove(key);
        }

        /// <summary>
        /// Removes the first occurrence of a specific object from the <see cref="DynamicDictionary"/>.
        /// </summary>
        /// <returns><see langword="true" /> if <paramref name="item"/> was successfully removed from the <see cref="DynamicDictionary"/>; otherwise, <see langword="false" />.</returns>
        /// <param name="item">The object to remove from the <see cref="DynamicDictionary"/>.</param>
        public bool Remove(KeyValuePair<string, dynamic> item)
        {
            var dynamicValueKeyValuePair =
                GetDynamicKeyValuePair(item);

            return this.dictionary.Remove(dynamicValueKeyValuePair);
        }

        /// <summary>
        /// Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the <see cref="DynamicDictionary"/>.
        /// </summary>
        /// <returns>An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the <see cref="DynamicDictionary"/>.</returns>
        public ICollection<dynamic> Values
        {
            get
            {
                return this.dictionary.Values;
            }
        }

        private static KeyValuePair<string, dynamic> GetDynamicKeyValuePair(KeyValuePair<string, dynamic> item)
        {
            var dynamicValueKeyValuePair =
                new KeyValuePair<string, dynamic>(item.Key, new DynamicDictionaryValue(item.Value));
            return dynamicValueKeyValuePair;
        }

        private static string GetNeutralKey(string key)
        {
            return key.Replace("-", string.Empty);
        }

        /// <summary>
        /// Gets a typed Dictionary of <see cref="T:Dictionary{String, Object}" /> from <see cref="DynamicDictionary"/>
        /// </summary>
        /// <returns>Gets a typed Dictionary of <see cref="T:Dictionary{String, Object}" /> from <see cref="DynamicDictionary"/></returns>
        public Dictionary<string, object> ToDictionary()
        {
            var data = new Dictionary<string, object>();

            foreach (var item in dictionary)
            {
                var newKey = item.Key;
                var newValue = ((DynamicDictionaryValue)item.Value).Value;

                data.Add(newKey, newValue);
            }

            return data;
        }

        private string DebuggerDisplay
        {
            get
            {
                var builder = new StringBuilder();
                var maxItems = Math.Min(this.dictionary.Count, 5);

                builder.Append("{");

                for (var i = 0; i < maxItems; i++)
                {
                    var item = this.dictionary.ElementAt(i);

                    builder.AppendFormat(" {0} = {1}{2}", item.Key, item.Value, i < maxItems - 1 ? "," : string.Empty);
                }

                if (maxItems < this.dictionary.Count)
                {
                    builder.Append("...");
                }

                builder.Append(" }");

                return builder.ToString();
            }
        }
    }
}
namespace Nancy.Routing
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Helpers;
    using Nancy.Configuration;
    using Trie;

    /// <summary>
    /// Default implementation of the <see cref="IRouteResolver"/> interface.
    /// </summary>
    public class DefaultRouteResolver : IRouteResolver
    {
        private readonly INancyModuleCatalog catalog;
        private readonly INancyModuleBuilder moduleBuilder;
        private readonly IRouteCache routeCache;
        private readonly IRouteResolverTrie trie;
        private readonly Lazy<RouteConfiguration> configuration;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultRouteResolver"/> class, using
        /// the provided <paramref name="catalog"/>, <paramref name="moduleBuilder"/>,
        /// <paramref name="routeCache"/> and <paramref name="trie"/>.
        /// </summary>
        /// <param name="catalog">An <see cref="INancyModuleCatalog"/> instance.</param>
        /// <param name="moduleBuilder">An <see cref="INancyModuleBuilder"/> instance.</param>
        /// <param name="routeCache">An <see cref="IRouteCache"/> instance.</param>
        /// <param name="trie">An <see cref="IRouteResolverTrie"/> instance.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public DefaultRouteResolver(INancyModuleCatalog catalog, INancyModuleBuilder moduleBuilder, IRouteCache routeCache, IRouteResolverTrie trie, INancyEnvironment environment)
        {
            this.catalog = catalog;
            this.moduleBuilder = moduleBuilder;
            this.routeCache = routeCache;
            this.trie = trie;
            this.configuration = new Lazy<RouteConfiguration>(environment.GetValue<RouteConfiguration>);

            this.BuildTrie();
        }

        /// <summary>
        /// Gets the route, and the corresponding parameter dictionary from the URL
        /// </summary>
        /// <param name="context">Current context</param>
        /// <returns>A <see cref="ResolveResult"/> containing the resolved route information.</returns>
        public ResolveResult Resolve(NancyContext context)
        {
            var pathDecoded =
                HttpUtility.UrlDecode(context.Request.Path);

            var results = this.trie.GetMatches(this.GetMethod(context), pathDecoded, context);

            if (!results.Any())
            {
                var allowedMethods =
                    this.trie.GetOptions(pathDecoded, context).ToArray();

                if (IsOptionsRequest(context))
                {
                    return BuildOptionsResult(allowedMethods, context);
                }

                return this.IsMethodNotAllowed(allowedMethods) ?
                    BuildMethodNotAllowedResult(context, allowedMethods) :
                    GetNotFoundResult(context);
            }

            // Sort in descending order
            Array.Sort(results, (m1, m2) => -m1.CompareTo(m2));

            for (var index = 0; index < results.Length; index++)
            {
                var matchResult = results[index];
                if (matchResult.Condition == null || matchResult.Condition.Invoke(context))
                {
                    return this.BuildResult(context, matchResult);
                }
            }

            return GetNotFoundResult(context);
        }

        private static ResolveResult BuildMethodNotAllowedResult(NancyContext context, IEnumerable<string> allowedMethods)
        {
            var route =
                new MethodNotAllowedRoute(context.Request.Path, context.Request.Method, allowedMethods);

            return new ResolveResult(route, new DynamicDictionary(), null, null, null);
        }

        private bool IsMethodNotAllowed(IEnumerable<string> allowedMethods)
        {
            return allowedMethods.Any() && !this.configuration.Value.DisableMethodNotAllowedResponses;
        }

        private static bool IsOptionsRequest(NancyContext context)
        {
            return context.Request.Method.Equals("OPTIONS", StringComparison.OrdinalIgnoreCase);
        }

        private void BuildTrie()
        {
            this.trie.BuildTrie(this.routeCache);
        }

        private static ResolveResult BuildOptionsResult(IEnumerable<string> allowedMethods, NancyContext context)
        {
            var path =
                context.Request.Path;

            var optionsResult =
                new OptionsRoute(path, allowedMethods);

            return new ResolveResult(
                optionsResult,
                new DynamicDictionary(),
                null,
                null,
                null);
        }

        private ResolveResult BuildResult(NancyContext context, MatchResult result)
        {
            var associatedModule = this.GetModuleFromMatchResult(context, result);

            context.NegotiationContext.SetModule(associatedModule);

            var route = associatedModule.Routes.ElementAt(result.RouteIndex);
            var parameters = DynamicDictionary.Create(result.Parameters);

            return new ResolveResult
            {
                Route = route,
                Parameters = parameters,
                Before = associatedModule.Before,
                After = associatedModule.After,
                OnError = associatedModule.OnError
            };
        }

        private INancyModule GetModuleFromMatchResult(NancyContext context, MatchResult result)
        {
            var module =
                this.catalog.GetModule(result.ModuleType, context);

            return this.moduleBuilder.BuildModule(module, context);
        }

        private static ResolveResult GetNotFoundResult(NancyContext context)
        {
            return new ResolveResult
            {
                Route = new NotFoundRoute(context.Request.Method, context.Request.Path),
                Parameters = DynamicDictionary.Empty,
                Before = null,
                After = null,
                OnError = null
            };
        }

        private string GetMethod(NancyContext context)
        {
            var requestedMethod =
                context.Request.Method;

            if (!this.configuration.Value.ExplicitHeadRouting)
            {
                return requestedMethod.Equals("HEAD", StringComparison.OrdinalIgnoreCase) ?
                    "GET" :
                    requestedMethod;
            }

            return requestedMethod;
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;

    /// <summary>
    /// Thrown when multiple <see cref="ViewLocationResult"/> instances describe the exact same view.
    /// </summary>
    public class AmbiguousViewsException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AmbiguousViewsException"/> class.
        /// </summary>
        public AmbiguousViewsException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AmbiguousViewsException"/> class.
        /// </summary>
        /// <param name="message">The message that should be displayed with the exception.</param>
        public AmbiguousViewsException(string message)
            : base(message)
        {
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.Collections.Generic;
    using System.Dynamic;
    using System.IO;
    using System.Linq;
    using System.Text.RegularExpressions;

    using Nancy.Conventions;

    /// <summary>
    /// The default implementation for how views are resolved and rendered by Nancy.
    /// </summary>
    public class DefaultViewFactory : IViewFactory
    {
        private readonly IViewResolver viewResolver;
        private readonly IEnumerable<IViewEngine> viewEngines;
        private readonly IRenderContextFactory renderContextFactory;
        private readonly ViewLocationConventions conventions;
        private readonly IRootPathProvider rootPathProvider;
        private static readonly Action<Stream> EmptyView = x => { };
        private readonly string[] viewEngineExtensions;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultViewFactory"/> class.
        /// </summary>
        /// <param name="viewResolver">An <see cref="IViewResolver"/> instance that should be used to resolve the location of a view.</param>
        /// <param name="viewEngines">An <see cref="IEnumerable{T}"/> instance containing the <see cref="IViewEngine"/> instances that should be able to be used to render a view</param>
        /// <param name="renderContextFactory">A <see cref="IRenderContextFactory"/> instance that should be used to create an <see cref="IRenderContext"/> when a view is rendered.</param>
        /// <param name="conventions">An <see cref="ViewLocationConventions"/> instance that should be used to resolve all possible view locations </param>
        /// <param name="rootPathProvider">An <see cref="IRootPathProvider"/> instance.</param>
        public DefaultViewFactory(IViewResolver viewResolver, IEnumerable<IViewEngine> viewEngines, IRenderContextFactory renderContextFactory, ViewLocationConventions conventions, IRootPathProvider rootPathProvider)
        {
            this.viewResolver = viewResolver;
            this.viewEngines = viewEngines;
            this.renderContextFactory = renderContextFactory;
            this.conventions = conventions;
            this.rootPathProvider = rootPathProvider;

            this.viewEngineExtensions = this.viewEngines.SelectMany(ive => ive.Extensions).ToArray();
        }

        /// <summary>
        /// Renders the view with the name and model defined by the <paramref name="viewName"/> and <paramref name="model"/> parameters.
        /// </summary>
        /// <param name="viewName">The name of the view to render.</param>
        /// <param name="model">The model that should be passed into the view.</param>
        /// <param name="viewLocationContext">A <see cref="ViewLocationContext"/> instance, containing information about the context for which the view is being rendered.</param>
        /// <returns>A delegate that can be invoked with the <see cref="Stream"/> that the view should be rendered to.</returns>
        public Response RenderView(string viewName, dynamic model, ViewLocationContext viewLocationContext)
        {
            if (viewName == null && model == null)
            {
                throw new ArgumentException("View name and model parameters cannot both be null.");
            }

            if (model == null && viewName.Length == 0)
            {
                throw new ArgumentException("The view name parameter cannot be empty when the model parameters is null.");
            }

            if (viewLocationContext == null)
            {
                throw new ArgumentNullException("viewLocationContext", "The value of the viewLocationContext parameter cannot be null.");
            }

            var actualViewName =
                viewName ?? GetViewNameFromModel(model, viewLocationContext.Context);

            viewLocationContext.Context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[DefaultViewFactory] Rendering view with name ", actualViewName)));

            return this.GetRenderedView(actualViewName, model, viewLocationContext);
        }

        private Response GetRenderedView(string viewName, dynamic model, ViewLocationContext viewLocationContext)
        {
            var viewLocationResult =
                this.viewResolver.GetViewLocation(viewName, model, viewLocationContext);

            var resolvedViewEngine =
                GetViewEngine(viewLocationResult, viewLocationContext.Context);

            if (resolvedViewEngine == null)
            {
                viewLocationContext.Context.Trace.TraceLog.WriteLog(x => x.AppendLine("[DefaultViewFactory] Unable to find view engine that could render the view."));
                throw new ViewNotFoundException(viewName, this.viewEngineExtensions, this.GetInspectedLocations(viewName, model, viewLocationContext), this.rootPathProvider);
            }

            viewLocationContext.Context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[DefaultViewFactory] Rendering view with view engine ", resolvedViewEngine.GetType().FullName)));

            return SafeInvokeViewEngine(
                resolvedViewEngine,
                viewLocationResult,
                GetSafeModel(model),
                this.renderContextFactory.GetRenderContext(viewLocationContext)
            );
        }

        private string[] GetInspectedLocations(string viewName, dynamic model, ViewLocationContext viewLocationContext)
        {
            var inspectedLocations = new List<string>();

            foreach (var convention in conventions)
            {
                try
                {
                    var location =
                        convention.Invoke(viewName, model, viewLocationContext);

                    if (!string.IsNullOrWhiteSpace(location))
                    {
                        inspectedLocations.Add(location);
                    }
                }
                catch
                {
                }
            }

            return inspectedLocations.ToArray();
        }

        private static object GetSafeModel(object model)
        {
            return (model.IsAnonymousType()) ? GetExpandoObject(model) : model;
        }

        private static ExpandoObject GetExpandoObject(object source)
        {
            var expandoObject = new ExpandoObject();
            IDictionary<string, object> results = expandoObject;

            foreach (var propertyInfo in source.GetType().GetProperties())
            {
                results[propertyInfo.Name] = propertyInfo.GetValue(source, null);
            }

            return expandoObject;
        }

        private IViewEngine GetViewEngine(ViewLocationResult viewLocationResult, NancyContext context)
        {
            if (viewLocationResult == null)
            {
                return null;
            }

            context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[DefaultViewFactory] Attempting to resolve view engine for view extension ", viewLocationResult.Extension)));

            var matchingViewEngines =
                from viewEngine in this.viewEngines
                where viewEngine.Extensions.Any(x => x.Equals(viewLocationResult.Extension, StringComparison.OrdinalIgnoreCase))
                select viewEngine;

            return matchingViewEngines.FirstOrDefault();
        }

        private static string GetViewNameFromModel(dynamic model, NancyContext context)
        {
            context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[DefaultViewFactory] Extracting view name from model of type ", model.GetType().FullName)));

            return Regex.Replace(model.GetType().Name, "Model$", string.Empty);
        }

        private static Response SafeInvokeViewEngine(IViewEngine viewEngine, ViewLocationResult locationResult, dynamic model, IRenderContext renderContext)
        {
            try
            {
                return viewEngine.RenderView(locationResult, model, renderContext);
            }
            catch (Exception)
            {
                return EmptyView;
            }
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Threading;
    using Configuration;

    /// <summary>
    /// The default implementation of <see cref="IViewLocator"/>.
    /// </summary>
    public class DefaultViewLocator : IViewLocator
    {
        private readonly List<ViewLocationResult> viewLocationResults;
        private readonly IViewLocationProvider viewLocationProvider;
        private readonly IEnumerable<IViewEngine> viewEngines;
        private readonly ReaderWriterLockSlim padlock = new ReaderWriterLockSlim();
        private readonly char[] invalidCharacters;
        private readonly ViewConfiguration configuration;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultViewLocator"/> class.
        /// </summary>
        /// <param name="viewLocationProvider">An <see cref="IViewLocationProvider"/> instance.</param>
        /// <param name="viewEngines">An <see cref="IEnumerable{T}"/> of <see cref="IViewEngine"/> instances.</param>
        /// <param name="environment">An <see cref="INancyEnvironment"/> instance.</param>
        public DefaultViewLocator(IViewLocationProvider viewLocationProvider, IEnumerable<IViewEngine> viewEngines, INancyEnvironment environment)
        {
            this.viewLocationProvider = viewLocationProvider;
            this.viewEngines = viewEngines;
            this.invalidCharacters = Path.GetInvalidFileNameChars().Where(c => c != '/').ToArray();
            this.viewLocationResults = new List<ViewLocationResult>(this.GetInititialViewLocations());
            this.configuration = environment.GetValue<ViewConfiguration>();
        }

        /// <summary>
        /// Gets the location of the view defined by the <paramref name="viewName"/> parameter.
        /// </summary>
        /// <param name="viewName">Name of the view to locate.</param>
        /// <param name="context">The <see cref="NancyContext"/> instance for the current request.</param>
        /// <returns>A <see cref="ViewLocationResult"/> instance if the view could be located; otherwise <see langword="null"/>.</returns>
        public ViewLocationResult LocateView(string viewName, NancyContext context)
        {
            if (string.IsNullOrEmpty(viewName))
            {
                return null;
            }

            if (!this.IsValidViewName(viewName))
            {
                return null;
            }

            // If we can't do runtime discovery there's no need to lock anything
            // as we can assume our cache is immutable.
            if (!this.configuration.RuntimeViewDiscovery)
            {
                return this.LocateCachedView(viewName);
            }

            this.padlock.EnterUpgradeableReadLock();
            try
            {
                var cachedResult = this.LocateCachedView(viewName);

                if (cachedResult != null)
                {
                    return cachedResult;
                }

                return !this.configuration.RuntimeViewDiscovery
                    ? null
                    : this.LocateAndCacheUncachedView(viewName);
            }
            finally
            {
                this.padlock.ExitUpgradeableReadLock();
            }
        }

        /// <summary>
        /// Gets all the views that are currently discovered
        /// Note: this is *not* the recommended way to deal with the view locator
        /// as it doesn't allow for runtime discovery of views with the
        /// <see cref="ViewConfiguration"/>.
        /// </summary>
        /// <returns>A collection of <see cref="ViewLocationResult"/> instances</returns>
        public IEnumerable<ViewLocationResult> GetAllCurrentlyDiscoveredViews()
        {
            this.padlock.EnterReadLock();

            try
            {
                // Make a copy to avoid any modification issues
                var newList = new List<ViewLocationResult>(this.viewLocationResults.Count);
                this.viewLocationResults.ForEach(newList.Add);
                return newList;
            }
            finally
            {
                this.padlock.ExitReadLock();
            }
        }

        private ViewLocationResult LocateAndCacheUncachedView(string viewName)
        {
            var uncachedResults = this.GetUncachedMatchingViews(viewName);
            if (!uncachedResults.Any())
            {
                return null;
            }

            this.padlock.EnterWriteLock();
            try
            {
                this.viewLocationResults.AddRange(uncachedResults);
            }
            finally
            {
                this.padlock.ExitWriteLock();
            }

            if (uncachedResults.Length > 1)
            {
                throw new AmbiguousViewsException(GetAmgiguousViewExceptionMessage(uncachedResults.Length, uncachedResults));
            }

            return uncachedResults.First();
        }

        private ViewLocationResult LocateCachedView(string viewName)
        {
            var cachedResults = this.GetCachedMatchingViews(viewName);
            if (cachedResults.Length == 1)
            {
                return cachedResults.Single();
            }

            if (cachedResults.Length > 1)
            {
                throw new AmbiguousViewsException(GetAmgiguousViewExceptionMessage(cachedResults.Length, cachedResults));
            }

            return null;
        }

        private ViewLocationResult[] GetUncachedMatchingViews(string viewName)
        {
            var viewExtension = GetExtensionFromViewName(viewName);

            var supportedViewExtensions = string.IsNullOrEmpty(viewExtension)
                ? this.GetSupportedViewExtensions()
                : new[] { viewExtension };

            var location = GetLocationFromViewName(viewName);
            var nameWithoutExtension = GetFilenameWithoutExtensionFromViewName(viewName);

            return this.viewLocationProvider.GetLocatedViews(supportedViewExtensions, location, nameWithoutExtension)
                                            .ToArray();
        }

        private ViewLocationResult[] GetCachedMatchingViews(string viewName)
        {
            return this.viewLocationResults.Where(x => NameMatchesView(viewName, x))
                       .Where(x => ExtensionMatchesView(viewName, x))
                       .Where(x => LocationMatchesView(viewName, x))
                       .ToArray();
        }

        private IEnumerable<ViewLocationResult> GetInititialViewLocations()
        {
            var supportedViewExtensions =
                this.GetSupportedViewExtensions();

            var viewsLocatedByProviders =
                this.viewLocationProvider.GetLocatedViews(supportedViewExtensions);

            return viewsLocatedByProviders.ToArray();
        }

        private IEnumerable<string> GetSupportedViewExtensions()
        {
            return this.viewEngines
                .SelectMany(engine => engine.Extensions)
                .Distinct();
        }

        private static string GetAmgiguousViewExceptionMessage(int count, IEnumerable<ViewLocationResult> viewsThatMatchesCritera)
        {
            return string.Format("This exception was thrown because multiple views were found. {0} view(s):\r\n\t{1}", count, string.Join("\r\n\t", viewsThatMatchesCritera.Select(GetFullLocationOfView).ToArray()));
        }

        private static string GetFullLocationOfView(ViewLocationResult viewLocationResult)
        {
            return string.Concat(viewLocationResult.Location, "/", viewLocationResult.Name, ".", viewLocationResult.Extension);
        }

        private static bool ExtensionMatchesView(string viewName, ViewLocationResult viewLocationResult)
        {
            var extension = GetExtensionFromViewName(viewName);

            return string.IsNullOrEmpty(extension) ||
                viewLocationResult.Extension.Equals(extension, StringComparison.OrdinalIgnoreCase);
        }

        private static bool LocationMatchesView(string viewName, ViewLocationResult viewLocationResult)
        {
            var location = GetLocationFromViewName(viewName);

            return viewLocationResult.Location.Equals(location, StringComparison.OrdinalIgnoreCase);
        }

        private static bool NameMatchesView(string viewName, ViewLocationResult viewLocationResult)
        {
            var name = GetFilenameWithoutExtensionFromViewName(viewName);

            return (!string.IsNullOrEmpty(name)) &&
                viewLocationResult.Name.Equals(name, StringComparison.OrdinalIgnoreCase);
        }

        private static string GetFilenameWithoutExtensionFromViewName(string viewName)
        {
            return Path.GetFileNameWithoutExtension(viewName);
        }

        private static string GetLocationFromViewName(string viewName)
        {
            var filename = Path.GetFileName(viewName);
            var index = viewName.LastIndexOf(filename, StringComparison.OrdinalIgnoreCase);
            var location = index >= 0 ? viewName.Remove(index, filename.Length) : viewName;
            location = location.TrimEnd('/');
            return location;
        }

        private static string GetExtensionFromViewName(string viewName)
        {
            var extension = Path.GetExtension(viewName);

            return !string.IsNullOrEmpty(extension) ? extension.Substring(1) : extension;
        }

        private bool IsValidViewName(string viewName)
        {
            return !this.invalidCharacters.Any(viewName.Contains);
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;

    using Nancy.Conventions;

    /// <summary>
    /// Default implementation on how views are resolved by Nancy.
    /// </summary>
    public class DefaultViewResolver : IViewResolver
    {
        private readonly ViewLocationConventions conventions;
        private readonly IViewLocator viewLocator;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultViewResolver"/> class.
        /// </summary>
        /// <param name="viewLocator">The view locator that should be used to locate views.</param>
        /// <param name="conventions">The conventions that the view resolver should use to figure out where to look for views.</param>
        public DefaultViewResolver(IViewLocator viewLocator, ViewLocationConventions conventions)
        {
            if (viewLocator == null)
            {
                throw new InvalidOperationException("Cannot create an instance of DefaultViewResolver with view locator parameter having null value.");
            }

            if (conventions == null)
            {
                throw new InvalidOperationException("Cannot create an instance of DefaultViewResolver with conventions parameter having null value.");
            }

            this.viewLocator = viewLocator;
            this.conventions = conventions;
        }

        /// <summary>
        /// Locates a view based on the provided information.
        /// </summary>
        /// <param name="viewName">The name of the view to locate.</param>
        /// <param name="model">The model that will be used with the view.</param>
        /// <param name="viewLocationContext">A <see cref="ViewLocationContext"/> instance, containing information about the context for which the view is being located.</param>
        /// <returns>A <see cref="ViewLocationResult"/> instance if the view could be found, otherwise <see langword="null"/>.</returns>
        public ViewLocationResult GetViewLocation(string viewName, dynamic model, ViewLocationContext viewLocationContext)
        {
            if (string.IsNullOrEmpty(viewName))
            {
                return null;
            }

            if (viewLocationContext == null)
            {
                return null;
            }

            viewLocationContext.Context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[DefaultViewResolver] Resolving view for '", viewName, "', using view location conventions.")));

            foreach (var convention in conventions)
            {
                var conventionBasedViewName =
                    SafeInvokeConvention(convention, viewName, model, viewLocationContext);

                if (string.IsNullOrEmpty(conventionBasedViewName))
                {
                    continue;
                }

                viewLocationContext.Context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[DefaultViewResolver] Attempting to locate view using convention '", conventionBasedViewName, "'")));

                var locatedView =
                    this.viewLocator.LocateView(conventionBasedViewName, viewLocationContext.Context);

                if (locatedView != null)
                {
                    viewLocationContext.Context.Trace.TraceLog.WriteLog(x => x.AppendLine(string.Concat("[DefaultViewResolver] View resolved at '", conventionBasedViewName, "'")));
                    return locatedView;
                }
            }

            viewLocationContext.Context.Trace.TraceLog.WriteLog(x => x.AppendLine("[DefaultViewResolver] No view could be resolved using the available view location conventions."));

            return null;
        }

        private static string SafeInvokeConvention(Func<string, object, ViewLocationContext, string> convention, string viewName, dynamic model, ViewLocationContext viewLocationContext)
        {
            try
            {
                return convention.Invoke(viewName, model, viewLocationContext);
            }
            catch
            {
                return null;
            }
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.IO;

    /// <summary>
    /// View location result for file system based views.
    /// Supports detecting if the contents have changed since it
    /// was last read.
    /// </summary>
    public class FileSystemViewLocationResult : ViewLocationResult
    {
        private readonly IFileSystemReader fileSystem;

        private readonly string fileName;

        private DateTime lastUpdated;

        private readonly Func<TextReader> fileContents;

        /// <summary>
        /// Initializes a new instance of the <see cref="ViewLocationResult"/> class.
        /// </summary>
        /// <param name="location">The location of where the view was found.</param>
        /// <param name="name">The name of the view.</param>
        /// <param name="extension">The file extension of the located view.</param>
        /// <param name="contents">A <see cref="TextReader"/> that can be used to read the contents of the located view.</param>
        /// <param name="fullFilename">Full filename of the file</param>
        /// <param name="fileSystem">An <see cref="IFileSystemReader"/> instance that should be used when retrieving view information from the file system.</param>
        public FileSystemViewLocationResult(string location, string name, string extension, Func<TextReader> contents, string fullFilename, IFileSystemReader fileSystem)
        {
            this.fileSystem = fileSystem;
            this.Location = location;
            this.Name = name;
            this.Extension = extension;
            this.fileContents = contents;
            this.Contents = this.GetContents;
            this.fileName = fullFilename;
        }

        /// <summary>
        /// Gets a value indicating whether the current item is stale
        /// </summary>
        /// <returns>True if stale, false otherwise</returns>
        public override bool IsStale()
        {
            return this.lastUpdated != this.fileSystem.GetLastModified(this.fileName);
        }

        /// <summary>
        /// Wraps the real contents delegate to set the last modified date first
        /// </summary>
        /// <returns>TextReader to read the file</returns>
        private TextReader GetContents()
        {
            this.lastUpdated = this.fileSystem.GetLastModified(this.fileName);

            return this.fileContents.Invoke();
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.Collections.Generic;
    using System.IO;

    /// <summary>
    /// Defines the functionality for retrieving information about views that are stored on the file system.
    /// </summary>
    public interface IFileSystemReader
    {
        /// <summary>
        /// Gets information about view that are stored in folders below the applications root path.
        /// </summary>
        /// <param name="path">The path of the folder where the views should be looked for.</param>
        /// <param name="supportedViewExtensions">A list of view extensions to look for.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> containing view locations and contents readers.</returns>
        IEnumerable<Tuple<string, Func<StreamReader>>> GetViewsWithSupportedExtensions(string path, IEnumerable<string> supportedViewExtensions);

        /// <summary>
        /// Gets the last modified time for the file specified
        /// </summary>
        /// <param name="filename">Filename</param>
        /// <returns>Time the file was last modified</returns>
        DateTime GetLastModified(string filename);

        /// <summary>
        /// Gets information about specific views that are stored in folders below the applications root path.
        /// </summary>
        /// <param name="path">The path of the folder where the views should be looked for.</param>
        /// <param name="viewName">Name of the view to search for</param>
        /// <param name="supportedViewExtensions">A list of view extensions to look for.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> containing view locations and contents readers.</returns>
        IEnumerable<Tuple<string, Func<StreamReader>>> GetViewsWithSupportedExtensions(string path, string viewName, IEnumerable<string> supportedViewExtensions);
    }
}
namespace Nancy.ViewEngines
{
    using System.Collections.Generic;

    using Nancy.Localization;

    /// <summary>
    /// Defines the functionality of the context that is passed into a view engine when the view is requested to be rendered.
    /// </summary>
    public interface IRenderContext
    {
        /// <summary>
        /// Gets the context of the current request.
        /// </summary>
        /// <value>A <see cref="NancyContext"/> instance.</value>
        NancyContext Context { get; }

        /// <summary>
        /// Gets the view cache that is used by Nancy.
        /// </summary>
        /// <value>An <see cref="IViewCache"/> instance.</value>
        IViewCache ViewCache { get; }

        /// <summary>
        /// Gets the text resource for localisation
        /// </summary>
        ITextResource TextResource { get; }

        /// <summary>
        /// Gets the text resource finder for localisation
        /// </summary>
        dynamic TextResourceFinder { get; }

        /// <summary>
        /// Parses a path and returns an absolute url path, taking into account
        /// base directory etc.
        /// </summary>
        /// <param name="input">Input url such as ~/styles/main.css</param>
        /// <returns>Parsed absolute url path</returns>
        string ParsePath(string input);

        /// <summary>
        /// HTML encodes a string.
        /// </summary>
        /// <param name="input">The string that should be HTML encoded.</param>
        /// <returns>A HTML encoded <see cref="string"/>.</returns>
        string HtmlEncode(string input);

        /// <summary>
        /// Locates a view that matches the provided <paramref name="viewName"/> and <paramref name="model"/>.
        /// </summary>
        /// <param name="viewName">The name of the view that should be located.</param>
        /// <param name="model">The model that should be used when locating the view.</param>
        /// <returns>A <see cref="ViewLocationResult"/> instance if the view could be located; otherwise, <see langword="null"/>.</returns>
        ViewLocationResult LocateView(string viewName, dynamic model);

        /// <summary>
        /// Gets the current Csrf token.
        /// The token should be stored in a cookie and the form as a hidden field.
        /// In both cases the name should be the key of the returned key value pair.
        /// </summary>
        /// <returns>A tuple containing the name (cookie name and form/querystring name) and value</returns>
        KeyValuePair<string, string> GetCsrfToken();
    }
}
namespace Nancy.ViewEngines
{
    /// <summary>
    /// Defines the functionality required to manufacture <see cref="IRenderContext"/> instances.
    /// </summary>
    public interface IRenderContextFactory
    {
        /// <summary>
        /// Gets a <see cref="IRenderContext"/> for the specified <see cref="ViewLocationContext"/>.
        /// </summary>
        /// <param name="viewLocationContext">The <see cref="ViewLocationContext"/> for which the context should be created.</param>
        /// <returns>A <see cref="IRenderContext"/> instance.</returns>
        IRenderContext GetRenderContext(ViewLocationContext viewLocationContext);
    }
}
namespace Nancy
{
    using System.Collections.Generic;
    using System.Reflection;

    /// <summary>
    /// Defines the functionality for retrieving which assemblies that should be used by Nancy.
    /// </summary>
    public interface IResourceAssemblyProvider
    {
        /// <summary>
        /// Gets a list of assemblies that should be scanned.
        /// </summary>
        /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="Assembly"/> instances.</returns>
        IEnumerable<Assembly> GetAssembliesToScan();
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Reflection;

    /// <summary>
    /// Defines the functionality of a reader that extracts embedded views from an assembly.
    /// </summary>
    public interface IResourceReader
    {
        /// <summary>
        /// Gets information about the resources that are embedded in the assembly.
        /// </summary>
        /// <param name="assembly">The <see cref="Assembly"/> to retrieve view information from.</param>
        /// <param name="supportedViewEngineExtensions">A list of view extensions to look for.</param>
        /// <returns>A <see cref="IList{T}"/> of resource locations and content readers.</returns>
        IList<Tuple<string, Func<StreamReader>>> GetResourceStreamMatches(Assembly assembly, IEnumerable<string> supportedViewEngineExtensions);
    }
}
namespace Nancy.Localization
{
    /// <summary>
    /// Used to return string values
    /// </summary>
    public interface ITextResource
    {
        /// <summary>
        /// Gets a translation based on the provided key.
        /// </summary>
        /// <param name="key">The key to look up the translation for.</param>
        /// <param name="context">The current <see cref="NancyContext"/> instance.</param>
        string this[string key, NancyContext context] { get; }
    }
}
namespace Nancy.ViewEngines
{
    using System;

    /// <summary>
    /// Defines the functionality of a Nancy view cache.
    /// </summary>
    public interface IViewCache
    {
        /// <summary>
        /// Gets or adds a view from the cache.
        /// </summary>
        /// <typeparam name="TCompiledView">The type of the cached view instance.</typeparam>
        /// <param name="viewLocationResult">A <see cref="ViewLocationResult"/> instance that describes the view that is being added or retrieved from the cache.</param>
        /// <param name="valueFactory">A function that produces the value that should be added to the cache in case it does not already exist.</param>
        /// <returns>An instance of the type specified by the <typeparamref name="TCompiledView"/> type.</returns>
        TCompiledView GetOrAdd<TCompiledView>(ViewLocationResult viewLocationResult, Func<ViewLocationResult, TCompiledView> valueFactory);
    }
}
namespace Nancy.ViewEngines
{
    using System.Collections.Generic;

    /// <summary>
    /// Defines the functionality that a view engine must support to be integrated into Nancy.
    /// </summary>
    public interface IViewEngine
    {
        /// <summary>
        /// Gets the extensions file extensions that are supported by the view engine.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> instance containing the extensions.</value>
        /// <remarks>The extensions should not have a leading dot in the name.</remarks>
        IEnumerable<string> Extensions { get; }

        /// <summary>
        /// Initialise the view engine (if necessary)
        /// </summary>
        /// <param name="viewEngineStartupContext">Startup context</param>
        void Initialize(ViewEngineStartupContext viewEngineStartupContext);

        /// <summary>
        /// Renders the view.
        /// </summary>
        /// <param name="viewLocationResult">A <see cref="ViewLocationResult"/> instance, containing information on how to get the view template.</param>
        /// <param name="model">The model that should be passed into the view</param>
        /// <param name="renderContext"></param>
        /// <returns>A response</returns>
        Response RenderView(ViewLocationResult viewLocationResult, dynamic model, IRenderContext renderContext);
    }
}
namespace Nancy.ViewEngines
{
    using System.Collections.Generic;

    /// <summary>
    /// Defines the functionality used by Nancy to located a view.
    /// </summary>
    public interface IViewLocationProvider
    {
        /// <summary>
        /// Returns an <see cref="ViewLocationResult"/> instance for all the views that could be located by the provider.
        /// </summary>
        /// <param name="supportedViewExtensions">An <see cref="IEnumerable{T}"/> instance, containing the view engine file extensions that is supported by the running instance of Nancy.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance, containing <see cref="ViewLocationResult"/> instances for the located views.</returns>
        /// <remarks>If no views could be located, this method should return an empty enumerable, never <see langword="null"/>.</remarks>
        IEnumerable<ViewLocationResult> GetLocatedViews(IEnumerable<string> supportedViewExtensions);

        /// <summary>
        /// Returns an <see cref="ViewLocationResult"/> instance for all the views matching the viewName that could be located by the provider.
        /// </summary>
        /// <param name="supportedViewExtensions">An <see cref="IEnumerable{T}"/> instance, containing the view engine file extensions that is supported by the running instance of Nancy.</param>
        /// <param name="location">Location of the view</param>
        /// <param name="viewName">The name of the view to try and find</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance, containing <see cref="ViewLocationResult"/> instances for the located views.</returns>
        /// <remarks>If no views could be located, this method should return an empty enumerable, never <see langword="null"/>.</remarks>
        IEnumerable<ViewLocationResult> GetLocatedViews(IEnumerable<string> supportedViewExtensions, string location, string viewName);
    }
}
namespace Nancy.ViewEngines
{
    using System.Collections.Generic;

    /// <summary>
    /// Defines the functionality for locating the requested view.
    /// </summary>
    public interface IViewLocator : IHideObjectMembers
    {
        /// <summary>
        /// Gets the location of the view defined by the <paramref name="viewName"/> parameter.
        /// </summary>
        /// <param name="viewName">Name of the view to locate.</param>
        /// <param name="context">The <see cref="NancyContext"/> instance for the current request.</param>
        /// <returns>A <see cref="ViewLocationResult"/> instance if the view could be located; otherwise <see langword="null"/>.</returns>
        ViewLocationResult LocateView(string viewName, NancyContext context);

        /// <summary>
        /// Gets all the views that are currently discovered
        /// Note: this is *not* the recommended way to deal with the view locator
        /// as it doesn't allow for runtime discovery of views with the
        /// <see cref="ViewConfiguration"/>.
        /// </summary>
        /// <returns>A collection of <see cref="ViewLocationResult"/> instances</returns>
        IEnumerable<ViewLocationResult> GetAllCurrentlyDiscoveredViews();
    }
}
namespace Nancy.ViewEngines
{
    /// <summary>
    /// Defines the functionality used by a <see cref="INancyModule"/> to render a view to the response.
    /// </summary>
    public interface IViewFactory : IHideObjectMembers
    {
        /// <summary>
        /// Renders the view with the name and model defined by the <paramref name="viewName"/> and <paramref name="model"/> parameters.
        /// </summary>
        /// <param name="viewName">The name of the view to render.</param>
        /// <param name="model">The module path of the module that is rendering the view.</param>
        /// <param name="viewLocationContext">A <see cref="ViewLocationContext"/> instance, containing information about the context for which the view is being rendered.</param>
        /// <returns>A response.</returns>
        Response RenderView(string viewName, dynamic model, ViewLocationContext viewLocationContext);
    }
}
namespace Nancy.ViewEngines
{
    /// <summary>
    /// Interface for manually rendering views to a Response object, rather
    /// than going through content negotiation.
    /// </summary>
    public interface IViewRenderer
    {
        /// <summary>
        /// Renders a view to a response object, bypassing content negotiation.
        /// </summary>
        /// <param name="context">Current Nancy context</param>
        /// <param name="viewName">View name</param>
        /// <param name="model">Model object (or null)</param>
        /// <returns>Response object containing the rendered view (if found)</returns>
        Response RenderView(NancyContext context, string viewName, object model = null);
    }
}
namespace Nancy.ViewEngines
{
    /// <summary>
    /// Defines the functionality for resolving the requested view.
    /// </summary>
    public interface IViewResolver : IHideObjectMembers
    {
        /// <summary>
        /// Locates a view based on the provided information.
        /// </summary>
        /// <param name="viewName">The name of the view to locate.</param>
        /// <param name="model">The model that will be used with the view.</param>
        /// <param name="viewLocationContext">A <see cref="ViewLocationContext"/> instance, containing information about the context for which the view is being located.</param>
        /// <returns>A <see cref="ViewLocationResult"/> instance if the view could be found, otherwise <see langword="null"/>.</returns>
        ViewLocationResult GetViewLocation(string viewName, dynamic model, ViewLocationContext viewLocationContext);
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Reflection;

    /// <summary>
    /// Contains the functionality for locating a view that has been embedded into an assembly resource.
    /// </summary>
    public class ResourceViewLocationProvider : IViewLocationProvider
    {
        private readonly IResourceReader resourceReader;
        private readonly IResourceAssemblyProvider resourceAssemblyProvider;

        /// <summary>
        /// User-configured root namespaces for assemblies.
        /// </summary>
        public static readonly IDictionary<Assembly, string> RootNamespaces = new Dictionary<Assembly, string>();

        /// <summary>
        /// A list of assemblies to ignore when scanning for embedded views.
        /// </summary>
        public static readonly IList<Assembly> Ignore = new List<Assembly>();

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceViewLocationProvider"/> class.
        /// </summary>
        /// <param name="assemblyCatalog">An <see cref="IAssemblyCatalog"/> instance.</param>
        public ResourceViewLocationProvider(IAssemblyCatalog assemblyCatalog)
            : this(new DefaultResourceReader(), new ResourceAssemblyProvider(assemblyCatalog))
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceViewLocationProvider"/> class.
        /// </summary>
        /// <param name="resourceReader">An <see cref="IResourceReader"/> instance that should be used when extracting embedded views.</param>
        /// <param name="resourceAssemblyProvider">An <see cref="IResourceAssemblyProvider"/> instance that should be used to determine which assemblies to scan for embedded views.</param>
        public ResourceViewLocationProvider(IResourceReader resourceReader, IResourceAssemblyProvider resourceAssemblyProvider)
        {
            this.resourceReader = resourceReader;
            this.resourceAssemblyProvider = resourceAssemblyProvider;
        }

        /// <summary>
        /// Returns an <see cref="ViewLocationResult"/> instance for all the views that could be located by the provider.
        /// </summary>
        /// <param name="supportedViewExtensions">An <see cref="IEnumerable{T}"/> instance, containing the view engine file extensions that is supported by the running instance of Nancy.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance, containing <see cref="ViewLocationResult"/> instances for the located views.</returns>
        /// <remarks>If no views could be located, this method should return an empty enumerable, never <see langword="null"/>.</remarks>
        public IEnumerable<ViewLocationResult> GetLocatedViews(IEnumerable<string> supportedViewExtensions)
        {
            if (supportedViewExtensions == null || !supportedViewExtensions.Any())
            {
                return Enumerable.Empty<ViewLocationResult>();
            }

            return this.resourceAssemblyProvider
                .GetAssembliesToScan()
                .Union(RootNamespaces.Keys)
                .Where(x => !Ignore.Contains(x))
                .SelectMany(x => GetViewLocations(x, supportedViewExtensions));
        }

        /// <summary>
        /// Returns an <see cref="ViewLocationResult"/> instance for all the views matching the viewName that could be located by the provider.
        /// </summary>
        /// <param name="supportedViewExtensions">An <see cref="IEnumerable{T}"/> instance, containing the view engine file extensions that is supported by the running instance of Nancy.</param>
        /// <param name="viewName">The name of the view to try and find</param>
        /// <returns>An <see cref="IEnumerable{T}"/> instance, containing <see cref="ViewLocationResult"/> instances for the located views.</returns>
        /// <remarks>If no views could be located, this method should return an empty enumerable, never <see langword="null"/>.</remarks>
        public IEnumerable<ViewLocationResult> GetLocatedViews(IEnumerable<string> supportedViewExtensions, string location, string viewName)
        {
            var allResults = this.GetLocatedViews(supportedViewExtensions);

            return allResults.Where(vlr => vlr.Location.Equals(location, StringComparison.OrdinalIgnoreCase) &&
                                           vlr.Name.Equals(viewName, StringComparison.OrdinalIgnoreCase));
        }

        private IEnumerable<ViewLocationResult> GetViewLocations(Assembly assembly, IEnumerable<string> supportedViewExtensions)
        {
            var resourceStreams =
                this.resourceReader.GetResourceStreamMatches(assembly, supportedViewExtensions);

            if (!resourceStreams.Any())
            {
                return Enumerable.Empty<ViewLocationResult>();
            }

            if (resourceStreams.Count() == 1 && !RootNamespaces.ContainsKey(assembly))
            {
                var errorMessage =
                    string.Format("Only one view was found in assembly {0}, but no rootnamespace had been registered.", assembly.FullName);

                throw new InvalidOperationException(errorMessage);
            }

            string commonNamespace;
            if (!RootNamespaces.TryGetValue(assembly, out commonNamespace))
            {
                commonNamespace = ExtractAssemblyRootNamespace(assembly);
            }

            if (string.IsNullOrWhiteSpace(commonNamespace))
            {
                return Enumerable.Empty<ViewLocationResult>();
            }

            return
                from resource in resourceStreams
                let resourceFileName = GetResourceFileName(resource.Item1)
                where !resourceFileName.Equals(string.Empty)
                select new ViewLocationResult(
                    GetResourceLocation(commonNamespace, resource.Item1, resourceFileName),
                    Path.GetFileNameWithoutExtension(resourceFileName),
                    GetResourceExtension(resource.Item1),
                    resource.Item2);
        }

        private static string GetResourceLocation(string commonNamespace, string resource, string resourceName)
        {
            return resource
                .Replace(commonNamespace, string.Empty)
                .Replace(resourceName, string.Empty)
                .Trim(new[] { '.' })
                .Replace(".", "/");
        }

        private static string ExtractCommonResourceNamespace(IEnumerable<string> resources)
        {
            if (resources.Count() == 1)
            {
                var resource = resources.First();

                return resource
                    .Replace(GetResourceFileName(resource), string.Empty)
                    .TrimEnd(new[] { '.' });
            }

            var commonPathSegments = resources.Select(s => new { parts = s.Split('.') })
                .Aggregate((previous, current) => new { parts = current.parts.TakeWhile((step, index) => step == previous.parts.ElementAtOrDefault(index)).ToArray() });

            var commonResourceNamespace =
                string.Join(".", commonPathSegments.parts);

            return commonResourceNamespace;
        }

        private static string ExtractAssemblyRootNamespace(Assembly assembly)
        {
            var resources = assembly
                .GetTypes()
                .Where(x => !x.IsAnonymousType())
                .Select(x => x.FullName)
                .ToList();

            return ExtractCommonResourceNamespace(resources);
        }

        private static string GetResourceFileName(string resourceName)
        {
            var nameSegments =
                resourceName.Split(new[] { "." }, StringSplitOptions.RemoveEmptyEntries);

            var segmentCount =
                nameSegments.Count();

            return (segmentCount < 2) ?
                string.Empty :
                string.Concat(nameSegments[segmentCount - 2], ".", nameSegments[segmentCount - 1]);
        }

        private static string GetResourceExtension(string resourceName)
        {
            var extension = Path.GetExtension(resourceName);
            return extension != null ? extension.Substring(1) : string.Empty;
        }
    }
}
namespace Nancy.ViewEngines.SuperSimpleViewEngine
{
    /// <summary>
    /// Matches and modifies the content of a rendered SuperSimpleViewEngine view.
    /// </summary>
    public interface ISuperSimpleViewEngineMatcher
    {
        /// <summary>
        /// Invokes the matcher on the content of the rendered view.
        /// </summary>
        /// <param name="content">The content of the rendered view.</param>
        /// <param name="model">The model that was passed to the view.</param>
        /// <param name="host">The <see cref="IViewEngineHost"/> host.</param>
        /// <returns>The modified version of the view.</returns>
        string Invoke(string content, dynamic model, IViewEngineHost host);
    }
}
namespace Nancy.ViewEngines.SuperSimpleViewEngine
{
    /// <summary>
    /// Provides the view engine with utility functions for
    /// encoding, locating partial view templates etc.
    /// </summary>
    public interface IViewEngineHost
    {
        /// <summary>
        /// Context object of the host application.
        /// </summary>
        /// <value>An instance of the context object from the host.</value>
        object Context { get; }

        /// <summary>
        /// Html "safe" encode a string
        /// </summary>
        /// <param name="input">Input string</param>
        /// <returns>Encoded string</returns>
        string HtmlEncode(string input);

        /// <summary>
        /// Get the contents of a template
        /// </summary>
        /// <param name="templateName">Name/location of the template</param>
        /// <param name="model">Model to use to locate the template via conventions</param>
        /// <returns>Contents of the template, or null if not found</returns>
        string GetTemplate(string templateName, object model);

        /// <summary>
        /// Gets a uri string for a named route
        /// </summary>
        /// <param name="name">Named route name</param>
        /// <param name="parameters">Parameters to use to expand the uri string</param>
        /// <returns>Expanded uri string, or null if not found</returns>
        string GetUriString(string name, params string[] parameters);

        /// <summary>
        /// Expands a path to include any base paths
        /// </summary>
        /// <param name="path">Path to expand</param>
        /// <returns>Expanded path</returns>
        string ExpandPath(string path);

        /// <summary>
        /// Get the anti forgery token form element
        /// </summary>
        /// <returns>String containing the form element</returns>
        string AntiForgeryToken();
    }
}
namespace Nancy.ViewEngines.SuperSimpleViewEngine
{
    using System;

    public class NancyViewEngineHost : IViewEngineHost
    {
        private IRenderContext renderContext;

        /// <summary>
        /// Initializes a new instance of the <see cref="NancyViewEngineHost"/> class.
        /// </summary>
        /// <param name="renderContext">
        /// The render context.
        /// </param>
        public NancyViewEngineHost(IRenderContext renderContext)
        {
            this.renderContext = renderContext;
            this.Context = this.renderContext.Context;
        }

        /// <summary>
        /// Context object of the host application.
        /// </summary>
        /// <value>An instance of the context object from the host.</value>
        public object Context { get; private set; }

        /// <summary>
        /// Html "safe" encode a string
        /// </summary>
        /// <param name="input">Input string</param>
        /// <returns>Encoded string</returns>
        public string HtmlEncode(string input)
        {
            return this.renderContext.HtmlEncode(input);
        }

        /// <summary>
        /// Get the contents of a template
        /// </summary>
        /// <param name="templateName">Name/location of the template</param>
        /// <param name="model">Model to use to locate the template via conventions</param>
        /// <returns>Contents of the template, or null if not found</returns>
        public string GetTemplate(string templateName, object model)
        {
            var viewLocationResult = this.renderContext.LocateView(templateName, model);

            if (viewLocationResult == null)
            {
                return "[ERR!]";
            }

            using (var reader = viewLocationResult.Contents.Invoke())
                return reader.ReadToEnd();
        }

        /// <summary>
        /// Gets a uri string for a named route
        /// </summary>
        /// <param name="name">Named route name</param>
        /// <param name="parameters">Parameters to use to expand the uri string</param>
        /// <returns>Expanded uri string, or null if not found</returns>
        public string GetUriString(string name, params string[] parameters)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Expands a path to include any base paths
        /// </summary>
        /// <param name="path">Path to expand</param>
        /// <returns>Expanded path</returns>
        public string ExpandPath(string path)
        {
            return this.renderContext.ParsePath(path);
        }

        /// <summary>
        /// Get the anti forgery token form element
        /// </summary>
        /// <returns>String containing the form element</returns>
        public string AntiForgeryToken()
        {
            var tokenKeyValue = this.renderContext.GetCsrfToken();

            return string.Format("<input type=\"hidden\" name=\"{0}\" value=\"{1}\" />", tokenKeyValue.Key, tokenKeyValue.Value);
        }
    }
}
namespace Nancy.ViewEngines.SuperSimpleViewEngine
{
    using Microsoft.CSharp.RuntimeBinder;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Dynamic;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Text;

    /// <summary>
    /// A super-simple view engine
    /// </summary>
    public class SuperSimpleViewEngine
    {
        /// <summary>
        /// Compiled Regex for viewbag substitutions
        /// </summary>
        private static readonly Regex ViewBagSubstitutionsRegEx = new Regex(@"@(?<Encode>!)?ViewBag(?:\.(?<ParameterName>[a-zA-Z0-9-_]+))*;?", RegexOptions.Compiled);

        /// <summary>
        /// Compiled Regex for single substitutions
        /// </summary>
        private static readonly Regex SingleSubstitutionsRegEx = new Regex(@"@(?<Encode>!)?Model(?:\.(?<ParameterName>[a-zA-Z0-9-_]+))*;?", RegexOptions.Compiled);

        /// <summary>
        /// Compiled Regex for context subsituations
        /// </summary>
        private static readonly Regex ContextSubstitutionsRegEx = new Regex(@"@(?<Encode>!)?Context(?:\.(?<ParameterName>[a-zA-Z0-9-_]+))*;?", RegexOptions.Compiled);

        /// <summary>
        /// Compiled Regex for each blocks
        /// </summary>
        private static readonly Regex EachSubstitutionRegEx = new Regex(@"@Each(?:\.(?<ModelSource>(Model|Context)+))?(?:\.(?<ParameterName>[a-zA-Z0-9-_]+))*;?(?<Contents>.*?)@EndEach;?", RegexOptions.Compiled | RegexOptions.Singleline);

        /// <summary>
        /// Compiled Regex for each block current substitutions
        /// </summary>
        private static readonly Regex EachItemSubstitutionRegEx = new Regex(@"@(?<Encode>!)?Current(?:\.(?<ParameterName>[a-zA-Z0-9-_]+))*;?", RegexOptions.Compiled);

        /// <summary>
        /// Compiled Regex for if blocks
        /// </summary>
        private const string ConditionalOpenSyntaxPattern = @"@If(?<Not>Not)?(?<Null>Null)?(?:\.(?<ModelSource>(Model|Context)+))?(?:\.(?<ParameterName>[a-zA-Z0-9-_]+))+;?";
        private const string ConditionalOpenInnerSyntaxPattern = @"@If(?:Not)?(?:Null)?(?:\.(?:(Model|Context)+))?(?:\.(?:[a-zA-Z0-9-_]+))+;?";
        private const string ConditionalCloseStynaxPattern = @"@EndIf;?";

        private static readonly string ConditionalSubstituionPattern =
            string.Format(@"{0}(?<Contents>:[.*]|(?>{2}(?<DEPTH>)|{1}(?<-DEPTH>)|.)*(?(DEPTH)(?!))){1}",
                            ConditionalOpenSyntaxPattern,
                            ConditionalCloseStynaxPattern,
                            ConditionalOpenInnerSyntaxPattern);

        private static readonly Regex ConditionalSubstitutionRegEx = new Regex(ConditionalSubstituionPattern, RegexOptions.Compiled | RegexOptions.Singleline);

        /// <summary>
        /// Compiled regex for partial blocks
        /// </summary>
        private static readonly Regex PartialSubstitutionRegEx = new Regex(@"@Partial\['(?<ViewName>[^\]]+)'(?:.[ ]?@?(?<Model>(Model|Current)(?:\.(?<ParameterName>[a-zA-Z0-9-_]+))*))?\];?", RegexOptions.Compiled);

        /// <summary>
        /// Compiled RegEx for section block declarations
        /// </summary>
        private static readonly Regex SectionDeclarationRegEx = new Regex(@"@Section\[\'(?<SectionName>.+?)\'\];?", RegexOptions.Compiled);

        /// <summary>
        /// Compiled RegEx for section block contents
        /// </summary>
        private static readonly Regex SectionContentsRegEx = new Regex(@"(?:@Section\[\'(?<SectionName>.+?)\'\];?(?<SectionContents>.*?)@EndSection;?)", RegexOptions.Compiled | RegexOptions.Singleline);

        /// <summary>
        /// Compiled RegEx for master page declaration
        /// </summary>
        private static readonly Regex MasterPageHeaderRegEx = new Regex(@"^(?:@Master\[\'(?<MasterPage>.+?)\'\]);?", RegexOptions.Compiled);

        /// <summary>
        /// Compiled RegEx for path expansion
        /// </summary>
        private static readonly Regex PathExpansionRegEx = new Regex(@"(?:@Path\[\'(?<Path>.+?)\'\]);?", RegexOptions.Compiled);

        /// <summary>
        /// Compiled RegEx for path expansion in attribute values
        /// </summary>
        private static readonly Regex AttributeValuePathExpansionRegEx = new Regex(@"(?<Attribute>[a-zA-Z]+)=(?<Quote>[""'])(?<Path>~.+?)\k<Quote>", RegexOptions.Compiled);

        /// <summary>
        /// Compiled RegEx for the CSRF anti forgery token
        /// </summary>
        private static readonly Regex AntiForgeryTokenRegEx = new Regex(@"@AntiForgeryToken;?", RegexOptions.Compiled);

        /// <summary>
        /// View engine transform processors
        /// </summary>
        private readonly List<Func<string, object, IViewEngineHost, string>> processors;

        /// <summary>
        /// View engine extensions
        /// </summary>
        private readonly IEnumerable<ISuperSimpleViewEngineMatcher> matchers;

        /// <summary>
        /// Initializes a new instance of the <see cref="SuperSimpleViewEngine"/> class.
        /// </summary>
        public SuperSimpleViewEngine()
            : this(Enumerable.Empty<ISuperSimpleViewEngineMatcher>())
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SuperSimpleViewEngine"/> class, using
        /// the provided <see cref="ISuperSimpleViewEngineMatcher"/> extensions.
        /// </summary>
        /// <param name="matchers">The matchers to use with the engine.</param>
        public SuperSimpleViewEngine(IEnumerable<ISuperSimpleViewEngineMatcher> matchers)
        {
            this.matchers = matchers ?? Enumerable.Empty<ISuperSimpleViewEngineMatcher>();

            this.processors = new List<Func<string, object, IViewEngineHost, string>>
            {
                PerformViewBagSubstitutions,
                PerformSingleSubstitutions,
                PerformContextSubstitutions,
                PerformEachSubstitutions,
                PerformConditionalSubstitutions,
                PerformPathSubstitutions,
                PerformAntiForgeryTokenSubstitutions,
                this.PerformPartialSubstitutions,
                this.PerformMasterPageSubstitutions,
            };
        }

        /// <summary>
        /// Renders a template
        /// </summary>
        /// <param name="template">The template to render.</param>
        /// <param name="model">The model to user for rendering.</param>
        /// <param name="host">The view engine host</param>
        /// <returns>A string containing the expanded template.</returns>
        public string Render(string template, dynamic model, IViewEngineHost host)
        {
            var output =
                this.processors.Aggregate(template, (current, processor) => processor(current, model ?? new object(), host));

            return this.matchers.Aggregate(output, (current, extension) => extension.Invoke(current, model, host));
        }

        /// <summary>
        /// <para>
        /// Gets a property value from the given model.
        /// </para>
        /// <para>
        /// Anonymous types, standard types and ExpandoObject are supported.
        /// Arbitrary dynamics (implementing IDynamicMetaObjectProvider) are not, unless
        /// they also implement IDictionary string, object for accessing properties.
        /// </para>
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="propertyName">The property name to evaluate.</param>
        /// <returns>Tuple - Item1 being a bool for whether the evaluation was successful, Item2 being the value.</returns>
        /// <exception cref="ArgumentException">Model type is not supported.</exception>
        private static Tuple<bool, object> GetPropertyValue(object model, string propertyName)
        {
            if (model == null || string.IsNullOrEmpty(propertyName))
            {
                return new Tuple<bool, object>(false, null);
            }

            if (model is IDictionary<string, object>)
            {
                return DynamicDictionaryPropertyEvaluator(model, propertyName);
            }

            if (!(model is IDynamicMetaObjectProvider))
            {
                return StandardTypePropertyEvaluator(model, propertyName);
            }

            if (model is DynamicDictionaryValue)
            {
                var dynamicModel = model as DynamicDictionaryValue;

                return GetPropertyValue(dynamicModel.Value, propertyName);
            }

            if (model is DynamicObject)
            {
                return GetDynamicMember(model, propertyName);
            }

            throw new ArgumentException("model must be a standard type or implement IDictionary<string, object>", "model");
        }

        private static Tuple<bool, object> GetDynamicMember(object obj, string memberName)
        {
            var binder = Microsoft.CSharp.RuntimeBinder.Binder.GetMember(CSharpBinderFlags.None, memberName, obj.GetType(),
                new[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) });

            var callsite = CallSite<Func<CallSite, object, object>>.Create(binder);

            var result = callsite.Target(callsite, obj);

            return result == null ? new Tuple<bool, object>(false, null) : new Tuple<bool, object>(true, result);
        }

        /// <summary>
        /// A property extractor for standard types.
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="propertyName">The property name.</param>
        /// <returns>Tuple - Item1 being a bool for whether the evaluation was successful, Item2 being the value.</returns>
        private static Tuple<bool, object> StandardTypePropertyEvaluator(object model, string propertyName)
        {
            var type = model.GetType();
            var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);

            var property =
                properties.Where(p => string.Equals(p.Name, propertyName, StringComparison.Ordinal)).
                FirstOrDefault();

            if (property != null)
            {
                return new Tuple<bool, object>(true, property.GetValue(model, null));
            }

            var fields = type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);

            var field =
                fields.Where(p => string.Equals(p.Name, propertyName, StringComparison.Ordinal)).
                FirstOrDefault();

            return field == null ? new Tuple<bool, object>(false, null) : new Tuple<bool, object>(true, field.GetValue(model));
        }

        /// <summary>
        /// A property extractor designed for ExpandoObject, but also for any
        /// type that implements IDictionary string object for accessing its
        /// properties.
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="propertyName">The property name.</param>
        /// <returns>Tuple - Item1 being a bool for whether the evaluation was successful, Item2 being the value.</returns>
        private static Tuple<bool, object> DynamicDictionaryPropertyEvaluator(object model, string propertyName)
        {
            var dictionaryModel = (IDictionary<string, object>)model;

            object output;
            return !dictionaryModel.TryGetValue(propertyName, out output) ? new Tuple<bool, object>(false, null) : new Tuple<bool, object>(true, output);
        }

        /// <summary>
        /// Gets an IEnumerable of capture group values
        /// </summary>
        /// <param name="m">The match to use.</param>
        /// <param name="groupName">Group name containing the capture group.</param>
        /// <returns>IEnumerable of capture group values as strings.</returns>
        private static IEnumerable<string> GetCaptureGroupValues(Match m, string groupName)
        {
            return m.Groups[groupName].Captures.Cast<Capture>().Select(c => c.Value);
        }

        /// <summary>
        /// Gets a property value from a collection of nested parameter names
        /// </summary>
        /// <param name="model">The model containing properties.</param>
        /// <param name="parameters">A collection of nested parameters (e.g. User, Name</param>
        /// <returns>Tuple - Item1 being a bool for whether the evaluation was successful, Item2 being the value.</returns>
        private static Tuple<bool, object> GetPropertyValueFromParameterCollection(object model, IEnumerable<string> parameters)
        {
            if (parameters == null)
            {
                return new Tuple<bool, object>(true, model);
            }

            var currentObject = model;

            foreach (var parameter in parameters)
            {
                var currentResult = GetPropertyValue(currentObject, parameter);

                if (currentResult.Item1 == false)
                {
                    return new Tuple<bool, object>(false, null);
                }

                currentObject = currentResult.Item2;
            }

            return new Tuple<bool, object>(true, currentObject);
        }

        /// <summary>
        /// Gets the predicate result for an If or IfNot block
        /// </summary>
        /// <param name="item">The item to evaluate</param>
        /// <param name="properties">Property list to evaluate</param>
        /// <param name="nullCheck">Whether to check for null, rather than straight boolean</param>
        /// <returns>Bool representing the predicate result</returns>
        private static bool GetPredicateResult(object item, IEnumerable<string> properties, bool nullCheck)
        {
            var substitutionObject = GetPropertyValueFromParameterCollection(item, properties);

            if (substitutionObject.Item1 == false && properties.Last().StartsWith("Has"))
            {
                var newProperties =
                    properties.Take(properties.Count() - 1).Concat(new[] { properties.Last().Substring(3) });

                substitutionObject = GetPropertyValueFromParameterCollection(item, newProperties);

                return GetHasPredicateResultFromSubstitutionObject(substitutionObject.Item2);
            }

            return GetPredicateResultFromSubstitutionObject(substitutionObject.Item2, nullCheck);
        }

        /// <summary>
        /// Returns the predicate result if the substitionObject is a valid bool
        /// </summary>
        /// <param name="substitutionObject">The substitution object.</param>
        /// <param name="nullCheck"></param>
        /// <returns>Bool value of the substitutionObject, or false if unable to cast.</returns>
        private static bool GetPredicateResultFromSubstitutionObject(object substitutionObject, bool nullCheck)
        {
            if (nullCheck)
            {
                return substitutionObject == null;
            }

            if (substitutionObject != null && substitutionObject.GetType().GetProperty("Value") != null)
            {
                object value = ((dynamic)substitutionObject).Value;

                if (value is bool?)
                {
                    substitutionObject = value;
                }
            }

            var predicateResult = false;
            var substitutionBool = substitutionObject as bool?;
            if (substitutionBool != null)
            {
                predicateResult = substitutionBool.Value;
            }

            return predicateResult;
        }

        /// <summary>
        /// Returns the predicate result if the substitionObject is a valid ICollection
        /// </summary>
        /// <param name="substitutionObject">The substitution object.</param>
        /// <returns>Bool value of the whether the ICollection has items, or false if unable to cast.</returns>
        private static bool GetHasPredicateResultFromSubstitutionObject(object substitutionObject)
        {
            var predicateResult = false;

            var substitutionCollection = substitutionObject as ICollection;
            if (substitutionCollection != null)
            {
                predicateResult = substitutionCollection.Count != 0;
            }

            return predicateResult;
        }

        /// <summary>
        /// Performs single @ViewBag.PropertyName substitutions.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="model">This parameter is not used, the model is based on the "host.Context.ViewBag".</param>
        /// <param name="host">View engine host</param>
        /// <returns>Template with @ViewBag.PropertyName blocks expanded.</returns>
        private static string PerformViewBagSubstitutions(string template, object model, IViewEngineHost host)
        {
            return ViewBagSubstitutionsRegEx.Replace(
                template,
                m =>
                {
                    var properties = GetCaptureGroupValues(m, "ParameterName");

                    var substitution = GetPropertyValueFromParameterCollection(((dynamic)host.Context).ViewBag, properties);

                    if (!substitution.Item1)
                    {
                        return "[ERR!]";
                    }

                    if (substitution.Item2 == null)
                    {
                        return string.Empty;
                    }

                    return m.Groups["Encode"].Success ? host.HtmlEncode(substitution.Item2.ToString()) : substitution.Item2.ToString();
                });
        }

        /// <summary>
        /// Performs single @Model.PropertyName substitutions.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="model">The model.</param>
        /// <param name="host">View engine host</param>
        /// <returns>Template with @Model.PropertyName blocks expanded.</returns>
        private static string PerformSingleSubstitutions(string template, object model, IViewEngineHost host)
        {
            return SingleSubstitutionsRegEx.Replace(
                template,
                m =>
                {
                    var properties = GetCaptureGroupValues(m, "ParameterName");

                    var substitution = GetPropertyValueFromParameterCollection(model, properties);

                    if (!substitution.Item1)
                    {
                        return "[ERR!]";
                    }

                    if (substitution.Item2 == null)
                    {
                        return string.Empty;
                    }

                    return m.Groups["Encode"].Success ? host.HtmlEncode(substitution.Item2.ToString()) : substitution.Item2.ToString();
                });
        }

        /// <summary>
        /// Performs single @Context.PropertyName substitutions.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="model">The model.</param>
        /// <param name="host">View engine host</param>
        /// <returns>Template with @Context.PropertyName blocks expanded.</returns>
        private static string PerformContextSubstitutions(string template, object model, IViewEngineHost host)
        {
            return ContextSubstitutionsRegEx.Replace(
                template,
                m =>
                {
                    var properties = GetCaptureGroupValues(m, "ParameterName");

                    var substitution = GetPropertyValueFromParameterCollection(host.Context, properties);

                    if (!substitution.Item1)
                    {
                        return "[ERR!]";
                    }

                    if (substitution.Item2 == null)
                    {
                        return string.Empty;
                    }

                    return m.Groups["Encode"].Success ? host.HtmlEncode(substitution.Item2.ToString()) : substitution.Item2.ToString();
                });
        }

        /// <summary>
        /// Performs @Each.PropertyName substitutions
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="model">The model.</param>
        /// <param name="host">View engine host</param>
        /// <returns>Template with @Each.PropertyName blocks expanded.</returns>
        private string PerformEachSubstitutions(string template, object model, IViewEngineHost host)
        {
            return EachSubstitutionRegEx.Replace(
                template,
                m =>
                {
                    var properties = GetCaptureGroupValues(m, "ParameterName");

                    var modelSource = GetCaptureGroupValues(m, "ModelSource").SingleOrDefault();

                    if (modelSource != null && modelSource.Equals("Context", StringComparison.OrdinalIgnoreCase))
                    {
                        model = host.Context;
                    }

                    var substitutionObject = GetPropertyValueFromParameterCollection(model, properties);

                    if (substitutionObject.Item1 == false)
                    {
                        return "[ERR!]";
                    }

                    if (substitutionObject.Item2 == null)
                    {
                        return string.Empty;
                    }

                    var substitutionEnumerable = substitutionObject.Item2 as IEnumerable;
                    if (substitutionEnumerable == null)
                    {
                        return "[ERR!]";
                    }

                    var contents = m.Groups["Contents"].Value;

                    var result = new StringBuilder();
                    foreach (var item in substitutionEnumerable)
                    {
                        var modifiedContent = PerformPartialSubstitutions(contents, item, host);
                        modifiedContent = PerformConditionalSubstitutions(modifiedContent, item, host);
                        result.Append(ReplaceCurrentMatch(modifiedContent, item, host));
                    }

                    return result.ToString();
                });
        }

        /// <summary>
        /// Expand a @Current match inside an @Each iterator
        /// </summary>
        /// <param name="contents">Contents of the @Each block</param>
        /// <param name="item">Current item from the @Each enumerable</param>
        /// <param name="host">View engine host</param>
        /// <returns>String result of the expansion of the @Each.</returns>
        private static string ReplaceCurrentMatch(string contents, object item, IViewEngineHost host)
        {
            return EachItemSubstitutionRegEx.Replace(
                contents,
                eachMatch =>
                {
                    if (string.IsNullOrEmpty(eachMatch.Groups["ParameterName"].Value))
                    {
                        return eachMatch.Groups["Encode"].Success ? host.HtmlEncode(item.ToString()) : item.ToString();
                    }

                    var properties = GetCaptureGroupValues(eachMatch, "ParameterName");

                    var substitution = GetPropertyValueFromParameterCollection(item, properties);

                    if (!substitution.Item1)
                    {
                        return "[ERR!]";
                    }

                    if (substitution.Item2 == null)
                    {
                        return string.Empty;
                    }

                    return eachMatch.Groups["Encode"].Success ? host.HtmlEncode(substitution.Item2.ToString()) : substitution.Item2.ToString();
                });
        }

        /// <summary>
        /// Performs @If.PropertyName and @IfNot.PropertyName substitutions
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="model">The model.</param>
        /// <param name="host">View engine host</param>
        /// <returns>Template with @If.PropertyName @IfNot.PropertyName blocks removed/expanded.</returns>
        private static string PerformConditionalSubstitutions(string template, object model, IViewEngineHost host)
        {
            var result = template;

            result = ConditionalSubstitutionRegEx.Replace(
                result,
                m =>
                {
                    var properties = GetCaptureGroupValues(m, "ParameterName");

                    var modelSource = GetCaptureGroupValues(m, "ModelSource").SingleOrDefault();

                    if (modelSource != null && modelSource.Equals("Context", StringComparison.OrdinalIgnoreCase))
                    {
                        model = host.Context;
                    }

                    var predicateResult = GetPredicateResult(model, properties, m.Groups["Null"].Value == "Null");

                    if (m.Groups["Not"].Value == "Not")
                    {
                        predicateResult = !predicateResult;
                    }

                    return predicateResult ? PerformConditionalSubstitutions(m.Groups["Contents"].Value, model, host) : string.Empty;
                });

            return result;
        }

        /// <summary>
        /// Perform path expansion substitutions
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="model">The model.</param>
        /// <param name="host">View engine host</param>
        /// <returns>Template with paths expanded</returns>
        private static string PerformPathSubstitutions(string template, object model, IViewEngineHost host)
        {
            var result = template;

            result = PathExpansionRegEx.Replace(
                result,
                m =>
                {
                    var path = m.Groups["Path"].Value;

                    return host.ExpandPath(path);
                });

            result = AttributeValuePathExpansionRegEx.Replace(
                result,
                m =>
                {
                    var attribute = m.Groups["Attribute"];
                    var quote = m.Groups["Quote"].Value;
                    var path = m.Groups["Path"].Value;

                    var expandedPath = host.ExpandPath(path);

                    return string.Format("{0}={1}{2}{1}", attribute, quote, expandedPath);
                });

            return result;
        }

        /// <summary>
        /// Perform CSRF anti forgery token expansions
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="model">The model.</param>
        /// <param name="host">View engine host</param>
        /// <returns>Template with anti forgery tokens expanded</returns>
        private static string PerformAntiForgeryTokenSubstitutions(string template, object model, IViewEngineHost host)
        {
            return AntiForgeryTokenRegEx.Replace(template, x => host.AntiForgeryToken());
        }

        /// <summary>
        /// Perform @Partial partial view expansion
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="model">The model.</param>
        /// <param name="host">View engine host</param>
        /// <returns>Template with partials expanded</returns>
        private string PerformPartialSubstitutions(string template, dynamic model, IViewEngineHost host)
        {
            var result = template;

            result = PartialSubstitutionRegEx.Replace(
                result,
                m =>
                {
                    var partialViewName = m.Groups["ViewName"].Value;
                    var partialModel = model;
                    var properties = GetCaptureGroupValues(m, "ParameterName");

                    if (m.Groups["Model"].Length > 0)
                    {
                        var modelValue = GetPropertyValueFromParameterCollection(partialModel, properties);

                        if (modelValue.Item1 != true)
                        {
                            return "[ERR!]";
                        }

                        partialModel = modelValue.Item2;
                    }

                    var partialTemplate = host.GetTemplate(partialViewName, partialModel);

                    return this.Render(partialTemplate, partialModel, host);
                });

            return result;
        }

        /// <summary>
        /// Invokes the master page rendering with current sections if necessary
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="model">The model.</param>
        /// <param name="host">View engine host</param>
        /// <returns>Template with master page applied and sections substituted</returns>
        private string PerformMasterPageSubstitutions(string template, object model, IViewEngineHost host)
        {
            var masterPageName = GetMasterPageName(template);

            if (string.IsNullOrWhiteSpace(masterPageName))
            {
                return template;
            }

            var masterTemplate = host.GetTemplate(masterPageName, model);
            var sectionMatches = SectionContentsRegEx.Matches(template);
            var sections = sectionMatches.Cast<Match>().ToDictionary(sectionMatch => sectionMatch.Groups["SectionName"].Value, sectionMatch => sectionMatch.Groups["SectionContents"].Value);

            return this.RenderMasterPage(masterTemplate, sections, model, host);
        }

        /// <summary>
        /// Renders a master page - does a normal render then replaces any section tags with sections passed in
        /// </summary>
        /// <param name="masterTemplate">The master page template</param>
        /// <param name="sections">Dictionary of section contents</param>
        /// <param name="model">The model.</param>
        /// <param name="host">View engine host</param>
        /// <returns>Template with the master page applied and sections substituted</returns>
        private string RenderMasterPage(string masterTemplate, IDictionary<string, string> sections, object model, IViewEngineHost host)
        {
            var result = this.Render(masterTemplate, model, host);

            result = SectionDeclarationRegEx.Replace(
                result,
                m =>
                {
                    var sectionName = m.Groups["SectionName"].Value;

                    return sections.ContainsKey(sectionName) ? sections[sectionName] : string.Empty;
                });

            return result;
        }

        /// <summary>
        /// Gets the master page name, if one is specified
        /// </summary>
        /// <param name="template">The template</param>
        /// <returns>Master page name or String.Empty</returns>
        private static string GetMasterPageName(string template)
        {
            using (var stringReader = new StringReader(template))
            {
                var firstLine = stringReader.ReadLine();

                if (firstLine == null)
                {
                    return string.Empty;
                }

                var masterPageMatch = MasterPageHeaderRegEx.Match(firstLine);

                return masterPageMatch.Success ? masterPageMatch.Groups["MasterPage"].Value : string.Empty;
            }
        }
    }
}
namespace Nancy.ViewEngines.SuperSimpleViewEngine
{
    using System.Collections.Generic;

    using Nancy.Bootstrapper;

    /// <summary>
    /// Performs application registrations for the SuperSimpleViewEngine.
    /// </summary>
    public class SuperSimpleViewEngineRegistrations : IRegistrations
    {
        private readonly ITypeCatalog typeCatalog;

        /// <summary>
        /// Initializes a new instance of the
        /// <see cref="Nancy.ViewEngines.SuperSimpleViewEngine.SuperSimpleViewEngineRegistrations"/> class.
        /// </summary>
        /// <param name="typeCatalog">Type catalog.</param>
        public SuperSimpleViewEngineRegistrations(ITypeCatalog typeCatalog)
        {
            this.typeCatalog = typeCatalog;
        }

        /// <summary>
        /// Gets the type registrations to register for this startup task
        /// </summary>
        public IEnumerable<TypeRegistration> TypeRegistrations
        {
            get { return null; }
        }

        /// <summary>
        /// Gets the collection registrations to register for this startup task
        /// </summary>
        public IEnumerable<CollectionTypeRegistration> CollectionTypeRegistrations
        {
            get
            {
                return new[] {
                    new CollectionTypeRegistration(typeof(ISuperSimpleViewEngineMatcher), this.typeCatalog.GetTypesAssignableTo<ISuperSimpleViewEngineMatcher>())
                };
            }
        }

        /// <summary>
        /// Gets the instance registrations to register for this startup task
        /// </summary>
        public IEnumerable<InstanceRegistration> InstanceRegistrations
        {
            get { return null; }
        }
    }
}
namespace Nancy.ViewEngines.SuperSimpleViewEngine
{
    using System.Collections.Generic;
    using System.IO;

    using Nancy.Responses;

    /// <summary>
    /// Nancy IViewEngine wrapper for the super simple view engine
    /// </summary>
    public class SuperSimpleViewEngineWrapper : IViewEngine
    {
        /// <summary>
        /// Extensions that the view engine supports
        /// </summary>
        private readonly string[] extensions = new[] { "sshtml", "html", "htm" };

        /// <summary>
        /// The engine itself
        /// </summary>
        private readonly SuperSimpleViewEngine viewEngine;

        /// <summary>
        /// Gets the extensions file extensions that are supported by the view engine.
        /// </summary>
        /// <value>An <see cref="IEnumerable{T}"/> instance containing the extensions.</value>
        /// <remarks>The extensions should not have a leading dot in the name.</remarks>
        public IEnumerable<string> Extensions
        {
            get { return this.extensions; }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SuperSimpleViewEngineWrapper"/> class, using
        /// the provided <see cref="ISuperSimpleViewEngineMatcher"/> extensions.
        /// </summary>
        /// <param name="matchers">The matchers to use with the engine.</param>
        public SuperSimpleViewEngineWrapper(IEnumerable<ISuperSimpleViewEngineMatcher> matchers)
        {
            this.viewEngine = new SuperSimpleViewEngine(matchers);
        }

        /// <summary>
        /// Initialise the view engine (if necessary)
        /// </summary>
        /// <param name="viewEngineStartupContext">Startup context</param>
        public void Initialize(ViewEngineStartupContext viewEngineStartupContext)
        {
        }

        /// <summary>
        /// Renders the view.
        /// </summary>
        /// <param name="viewLocationResult">A <see cref="ViewLocationResult"/> instance, containing information on how to get the view template.</param>
        /// <param name="model">The model that should be passed into the view</param>
        /// <param name="renderContext">An <see cref="IRenderContext"/> instance.</param>
        /// <returns>A response</returns>
        public Response RenderView(ViewLocationResult viewLocationResult, dynamic model, IRenderContext renderContext)
        {
            return new HtmlResponse(contents: s =>
            {
                var writer = new StreamWriter(s);
                var templateContents = renderContext.ViewCache.GetOrAdd(viewLocationResult, vr =>
                {
                    using (var reader = vr.Contents.Invoke())
                        return reader.ReadToEnd();
                });

                writer.Write(this.viewEngine.Render(templateContents, model, new NancyViewEngineHost(renderContext)));
                writer.Flush();
            });
        }
    }
}
namespace Nancy.ViewEngines
{
    using System.Collections.Generic;

    using Nancy.Bootstrapper;

    /// <summary>
    /// Calls the initialize method on all <see cref="IViewEngine"/> implementations, at application startup.
    /// </summary>
    public class ViewEngineApplicationStartup : IApplicationStartup
    {
        private readonly IEnumerable<IViewEngine> viewEngines;
        private readonly IViewCache viewCache;
        private readonly IViewLocator viewLocator;

        /// <summary>
        /// Initializes a new instance of the <see cref="ViewEngineApplicationStartup"/> class, with the
        /// provided <paramref name="viewEngines"/>, <paramref name="viewCache"/> and <paramref name="viewLocator"/>.
        /// </summary>
        /// <param name="viewEngines">The available view engines.</param>
        /// <param name="viewCache">The view cache.</param>
        /// <param name="viewLocator">The view locator.</param>
        public ViewEngineApplicationStartup(IEnumerable<IViewEngine> viewEngines, IViewCache viewCache, IViewLocator viewLocator)
        {
            this.viewEngines = viewEngines;
            this.viewCache = viewCache;
            this.viewLocator = viewLocator;
        }

        /// <summary>
        /// Perform any initialisation tasks
        /// </summary>
        /// <param name="pipelines">Application pipelines</param>
        public void Initialize(IPipelines pipelines)
        {
            foreach (var viewEngine in viewEngines)
            {
                viewEngine.Initialize(CreateViewEngineStartupContext(viewEngine));
            }
        }

        private ViewEngineStartupContext CreateViewEngineStartupContext(IViewEngine viewEngine)
        {
            return new ViewEngineStartupContext(
                this.viewCache,
                this.viewLocator);
        }
    }
}
namespace Nancy.ViewEngines
{
    /// <summary>
    /// Context passed to each view engine on startup
    /// </summary>
    public class ViewEngineStartupContext
    {
        public ViewEngineStartupContext(IViewCache viewCache, IViewLocator viewLocator)
        {
            this.ViewLocator = viewLocator;
            this.ViewCache = viewCache;
        }

        /// <summary>
        /// Gets the Nancy view cache - can be used to precompile views at startup
        /// if necessary.
        /// </summary>
        public IViewCache ViewCache { get; private set; }

        /// <summary>
        /// Gets the Nancy view locator
        /// </summary>
        public IViewLocator ViewLocator { get; private set; }
    }
}
namespace Nancy.ViewEngines
{
    /// <summary>
    /// The context for which a view is being located.
    /// </summary>
    public class ViewLocationContext
    {
        /// <summary>
        /// The module path of the <see cref="INancyModule"/> that is locating a view.
        /// </summary>
        /// <value>A <see cref="string"/> containing the module path.</value>
        public string ModulePath { get; set; }

        /// <summary>
        /// The name of the <see cref="INancyModule"/> that is locating a view.
        /// </summary>
        /// <value>A <see cref="string"/> containing the name of the module.</value>
        public string ModuleName { get; set; }

        /// <summary>
        /// The request/response context
        /// </summary>
        public NancyContext Context { get; set; }
    }
}
namespace Nancy.ViewEngines
{
    using System;
    using System.IO;

    /// <summary>
    /// Contains the result of an attempt to locate a view.
    /// </summary>
    public class ViewLocationResult : IEquatable<ViewLocationResult>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ViewLocationResult"/> class.
        /// </summary>
        protected ViewLocationResult()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ViewLocationResult"/> class.
        /// </summary>
        /// <param name="location">The location of where the view was found.</param>
        /// <param name="name">The name of the view.</param>
        /// <param name="extension">The file extension of the located view.</param>
        /// <param name="contents">A <see cref="TextReader"/> that can be used to read the contents of the located view.</param>
        public ViewLocationResult(string location, string name, string extension, Func<TextReader> contents)
        {
            this.Location = location;
            this.Name = name;
            this.Extension = extension;
            this.Contents = contents;
        }

        /// <summary>
        /// Gets a function that produces a reader for retrieving the contents of the view.
        /// </summary>
        /// <value>A <see cref="Func{T}"/> instance that can be used to produce a reader for retrieving the contents of the view.</value>
        public Func<TextReader> Contents { get; protected set; }

        /// <summary>
        /// Gets the extension of the view that was located.
        /// </summary>
        /// <value>A <see cref="string"/> containing the extension of the view that was located.</value>
        /// <remarks>The extension should not contain a leading dot.</remarks>
        public string Extension { get; protected set; }

        /// <summary>
        /// Gets the location of where the view was found.
        /// </summary>
        /// <value>A <see cref="string"/> containing the location of the view.</value>
        public string Location { get; protected set; }

        /// <summary>
        /// Gets the full name of the view that was found
        /// </summary>
        /// <value>A <see cref="string"/> containing the name of the view.</value>
        public string Name { get; protected set; }

        /// <summary>
        /// Gets a value indicating whether the current item is stale
        /// </summary>
        /// <returns>True if stale, false otherwise</returns>
        public virtual bool IsStale()
        {
            return false;
        }

        /// <summary>
        /// Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <returns><see langword="true"/> if the current object is equal to the <paramref name="other"/> parameter; otherwise, <see langword="false"/>.</returns>
        /// <param name="other">An <see cref="ViewLocationResult"/> to compare with this instance.</param>
        public bool Equals(ViewLocationResult other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;
            return Equals(other.Extension, Extension) && Equals(other.Location, Location) && Equals(other.Name, Name);
        }

        /// <summary>
        /// Determines whether the specified <see cref="object"/> is equal to the current <see cref="object"/>.
        /// </summary>
        /// <returns><see langword="true"/> if the specified <see cref="object"/> is equal to the current <see cref="object"/>; otherwise, <see langword="false"/>.</returns>
        /// <param name="obj">The <see cref="object"/> to compare with the current <see cref="object"/>.</param>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == typeof(ViewLocationResult) && Equals((ViewLocationResult)obj);
        }

        /// <summary>
        /// Serves as a hash function for a particular type.
        /// </summary>
        /// <returns>A hash code for the current <see cref="ViewLocationResult"/>.</returns>
        public override int GetHashCode()
        {
            unchecked
            {
                var result = Extension.GetHashCode();
                result = (result * 397) ^ Location.GetHashCode();
                result = (result * 397) ^ Name.GetHashCode();
                return result;
            }
        }

        public static bool operator ==(ViewLocationResult left, ViewLocationResult right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(ViewLocationResult left, ViewLocationResult right)
        {
            return !Equals(left, right);
        }
    }
}
namespace Nancy.ViewEngines
{
    using System;

    /// <summary>
    /// Exception that is thrown when a view could not be located.
    /// </summary>
    public class ViewNotFoundException : Exception
    {
        private readonly IRootPathProvider rootPathProvider;
        public string ViewName { get; private set; }

        public string[] AvailableViewEngineExtensions { get; private set; }
        public string[] InspectedLocations { get; private set; }

        private string message;

        /// <summary>
        /// Initializes a new instance of the <see cref="ViewNotFoundException"/>.
        /// </summary>
        /// <param name="viewName">The name of the view that was being located.</param>
        /// <param name="availableViewEngineExtensions">List of available view extensions that can be rendered by the available view engines.</param>
        /// <param name="inspectedLocations">The locations that were inspected for the view.</param>
        /// <param name="rootPathProvider">An <see cref="IRootPathProvider"/> instance.</param>
        public ViewNotFoundException(string viewName, string[] availableViewEngineExtensions, string[] inspectedLocations, IRootPathProvider rootPathProvider)
        {
            this.rootPathProvider = rootPathProvider;
            this.ViewName = viewName;
            this.AvailableViewEngineExtensions = availableViewEngineExtensions;
            this.InspectedLocations = inspectedLocations;

            this.message = String.Format(
                    "Unable to locate view '{0}'{4}Currently available view engine extensions: {1}{4}Locations inspected: {2}{4}Root path: {3}{4}" +
                    "If you were expecting raw data back, make sure you set the 'Accept'-header of the request to correct format, for example 'application/json'",
                    this.ViewName,
                    string.Join(",", this.AvailableViewEngineExtensions),
                    string.Join(",", this.InspectedLocations),
                    this.rootPathProvider.GetRootPath(),
                    Environment.NewLine);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ViewNotFoundException"/>.
        /// </summary>
        /// <param name="viewName">The name of the view that was being located.</param>
        /// <param name="availableViewEngineExtensions">List of available view extensions that can be rendered by the available view engines.</param>
        public ViewNotFoundException(string viewName, string[] availableViewEngineExtensions)
        {
            this.ViewName = viewName;
            this.AvailableViewEngineExtensions = availableViewEngineExtensions;

            this.message = String.Format(
                    "Unable to locate view '{0}'{2}Currently available view engine extensions: {1}{2}",
                    this.ViewName,
                    string.Join(",", this.AvailableViewEngineExtensions),
                    Environment.NewLine);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ViewNotFoundException"/>
        /// </summary>
        /// <param name="msg">A message describing the problem</param>
        public ViewNotFoundException(string msg)
        {
            this.message = msg;
        }

        /// <summary>
        /// Gets a message that describes the current exception.
        /// </summary>
        /// <returns>The error message that explains the reason for the exception, or an empty string("").</returns>
        public override string Message
        {
            get { return message; }
        }
    }
}
namespace Nancy.ViewEngines.Razor
{
    using System;

    /// <summary>
    /// An exception that indicates the view could not be rendered
    /// </summary>
    public class ViewRenderException : Exception
    {
        /// <summary>
        /// Create an instance of <see cref="ViewRenderException"/>
        /// </summary>
        /// <param name="msg">A description of the rendering problem</param>
        public ViewRenderException(string msg) : base(msg)
        {
        }

        /// <summary>
        /// Create an instance of <see cref="ViewRenderException"/>
        /// </summary>
        /// <param name="msg">A description of the rendering problem</param>
        /// <param name="innerException">The exception that is the cause of the current exception.</param>
        public ViewRenderException(string msg, Exception innerException) : base(msg, innerException)
        {
        }
    }
}
namespace Nancy
{
    using System.IO;

    using Nancy.Responses.Negotiation;

    /// <summary>
    /// Helper class for rendering a view from a route handler.
    /// </summary>
    public class ViewRenderer : IHideObjectMembers
    {
        private readonly INancyModule module;

        /// <summary>
        /// Initializes a new instance of the <see cref="ViewRenderer"/> class.
        /// </summary>
        /// <param name="module">The <see cref="INancyModule"/> instance that is rendering the view.</param>
        public ViewRenderer(INancyModule module)
        {
            this.module = module;
        }

        /// <summary>
        /// Renders the view with its name resolved from the model type, and model defined by the <paramref name="model"/> parameter.
        /// </summary>
        /// <param name="model">The model that should be passed into the view.</param>
        /// <returns>A delegate that can be invoked with the <see cref="Stream"/> that the view should be rendered to.</returns>
        /// <remarks>The view name is model.GetType().Name with any Model suffix removed.</remarks>
        public Negotiator this[dynamic model]
        {
            get { return this.GetNegotiator(null, model); }
        }

        /// <summary>
        /// Renders the view with the name defined by the <paramref name="viewName"/> parameter.
        /// </summary>
        /// <param name="viewName">The name of the view to render.</param>
        /// <returns>A delegate that can be invoked with the <see cref="Stream"/> that the view should be rendered to.</returns>
        /// <remarks>The extension in the view name is optional. If it is omitted, then Nancy will try to resolve which of the available engines that should be used to render the view.</remarks>
        public Negotiator this[string viewName]
        {
            get { return this.GetNegotiator(viewName, null); }
        }

        /// <summary>
        /// Renders the view with the name and model defined by the <paramref name="viewName"/> and <paramref name="model"/> parameters.
        /// </summary>
        /// <param name="viewName">The name of the view to render.</param>
        /// <param name="model">The model that should be passed into the view.</param>
        /// <returns>A delegate that can be invoked with the <see cref="Stream"/> that the view should be rendered to.</returns>
        /// <remarks>The extension in the view name is optional. If it is omitted, then Nancy will try to resolve which of the available engines that should be used to render the view.</remarks>
        public Negotiator this[string viewName, dynamic model]
        {
            get { return this.GetNegotiator(viewName, model); }
        }

        private Negotiator GetNegotiator(string viewName, object model)
        {
            var negotiationContext = this.module.Context.NegotiationContext;

            negotiationContext.ViewName = viewName;
            negotiationContext.DefaultModel = model;
            negotiationContext.PermissableMediaRanges.Clear();
            negotiationContext.PermissableMediaRanges.Add("text/html");

            return new Negotiator(this.module.Context);
        }
    }
}
namespace Nancy.Xml
{
    using System.Text;
    using Nancy.Configuration;

    /// <summary>
    /// Contains <see cref="XmlConfiguration"/> configuration extensions for <see cref="INancyEnvironment"/>.
    /// </summary>
    public static class XmlConfigurationExtensions
    {
        /// <summary>
        /// Configures <see cref="XmlConfiguration"/>.
        /// </summary>
        /// <param name="environment"><see cref="INancyEnvironment"/> that should be configured.</param>
        /// <param name="enableEncoding"><see langword="true"/> if encoding should be enabled, otherwise <see langword="false"/>.</param>
        /// <param name="defaultEncoding">The default <see cref="Encoding"/>.</param>
        public static void Xml(this INancyEnvironment environment, bool enableEncoding, Encoding defaultEncoding = null)
        {
            environment.AddValue(new XmlConfiguration(
                enableEncoding,
                defaultEncoding));
        }
    }
}
namespace Nancy.Xml
{
    using System.Text;

    /// <summary>
    /// Configuration for XML serialization.
    /// </summary>
    public class XmlConfiguration
    {
        /// <summary>
        /// A default instance of the <see cref="XmlConfiguration"/> class.
        /// </summary>
        public static readonly XmlConfiguration Default = new XmlConfiguration
        {
            EncodingEnabled = false,
            DefaultEncoding = Encoding.UTF8
        };

        private XmlConfiguration()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="XmlConfiguration"/> class.
        /// </summary>
        /// <param name="encodingEnabled"><see langword="true" /> if encoding should be enabled, otherwise <see langword="false" />.</param>
        /// <param name="defaultEncoding">The <see cref="Encoding"/> that should be used.</param>
        public XmlConfiguration(bool encodingEnabled, Encoding defaultEncoding)
        {
            this.EncodingEnabled = encodingEnabled;
            this.DefaultEncoding = defaultEncoding ?? Default.DefaultEncoding;
        }

        /// <summary>
        /// Gets whether character encoding should be enabled, or not, for XML responses.
        /// </summary>
        /// <value><see langword="true" /> if encoding is enabled, otherwise <see langword="false" />.</value>
        /// <remarks>The default value is <see langword="false" />.</remarks>
        public bool EncodingEnabled { get; private set; }

        /// <summary>
        /// Gets the default encoding for XML responses.
        /// </summary>
        /// <value>The <see cref="Encoding"/> used by default.</value>
        /// <remarks>The default value is <see langword="Encoding.UTF8" />.</remarks>
        public Encoding DefaultEncoding { get; private set; }
    }
}
namespace Nancy.Xml
{
    using Nancy.Configuration;

    /// <summary>
    /// Provides the default configuration for <see cref="XmlConfiguration"/>.
    /// </summary>
    public class DefaultXmlConfigurationProvider : NancyDefaultConfigurationProvider<XmlConfiguration>
    {
        /// <summary>
        /// Gets the default configuration instance to register in the <see cref="INancyEnvironment"/>.
        /// </summary>
        /// <returns>The configuration instance</returns>
        /// <remarks>Will return <see cref="XmlConfiguration.Default"/>.</remarks>
        public override XmlConfiguration GetDefaultConfiguration()
        {
            return XmlConfiguration.Default;
        }
    }
}
namespace Nancy
{
    using Nancy.Configuration;

    /// <summary>
    /// Provides the default <see cref="StaticContentConfiguration"/>. 
    /// </summary>
    public class DefaultStaticContentConfigurationProvider : NancyDefaultConfigurationProvider<StaticContentConfiguration>
    {
        private readonly IRootPathProvider rootPathProvider;

        /// <summary>
        /// Creates and instance of <see cref="DefaultStaticContentConfigurationProvider" />. 
        /// </summary>
        /// <param name="rootPathProvider">Use <see cref="IRootPathProvider"/> to get the root path of the application</param>
        public DefaultStaticContentConfigurationProvider(IRootPathProvider rootPathProvider)
        {
            this.rootPathProvider = rootPathProvider;
        }

        /// <summary>
        /// Gets the default <see cref="StaticContentConfiguration"/> configuration instance to register in the <see cref="INancyEnvironment"/> .
        /// </summary>
        /// <returns>The configuration instance.</returns>
        public override StaticContentConfiguration GetDefaultConfiguration()
        {
            return new StaticContentConfiguration(safePaths: new[] { this.rootPathProvider.GetRootPath() });
        }
    }
}
namespace Nancy
{
    using System.Collections.Generic;

    /// <summary>
    /// Static content configuration.
    /// </summary>
    public class StaticContentConfiguration
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StaticContentConfiguration"/> class.
        /// </summary>
        /// <param name="safePaths">A set of safe paths to retrieve static content from</param>
        public StaticContentConfiguration(IEnumerable<string> safePaths)
        {
            this.SafePaths = safePaths;
        }

        /// <summary>
        /// Gets the safe paths to retrieve static content from.
        /// </summary>
        /// <value>Safe paths to retrieve static content from</value>
        public IEnumerable<string> SafePaths { get; private set; }
    }
}
namespace Nancy
{
    using System.Collections.Generic;
    using Nancy.Configuration;

    /// <summary>
    /// Contains <see cref="StaticContentConfiguration"/> configuration extensions for <see cref="INancyEnvironment"/>.  
    /// </summary>
    public static class StaticContentConfigurationExtensions
    {
        /// <summary>
        /// Configures <see cref="StaticContentConfiguration"/> 
        /// </summary>
        /// <param name="environment">An <see cref="INancyEnvironment"/> that should be configured.</param>
        /// <param name="safepaths">Paths that the application consider safe to return static content from</param>
        public static void StaticContent(this INancyEnvironment environment, params string[] safepaths)
        {
            environment.AddValue(new StaticContentConfiguration(
               safePaths: safepaths));
        }
    }
}
namespace Nancy
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;

    /// <summary>
    /// Globalization configuration
    /// </summary>
    public class GlobalizationConfiguration
    {
        /// <summary>
        /// A default instance of the <see cref="GlobalizationConfiguration"/> class
        /// </summary>
        public static readonly GlobalizationConfiguration Default = new GlobalizationConfiguration(supportedCultureNames: new[] { CultureInfo.CurrentCulture.Name }, defaultCulture: CultureInfo.CurrentCulture.Name);

        /// <summary>
        /// Initializes a new instance of the <see cref="GlobalizationConfiguration"/> class
        /// </summary>
        /// <param name="supportedCultureNames">An array of supported cultures</param>
        /// <param name="defaultCulture">The default culture of the application</param>
        public GlobalizationConfiguration(IEnumerable<string> supportedCultureNames, string defaultCulture = null)
        {
            if (supportedCultureNames == null)
            {
                throw new ConfigurationException("Invalid Globalization configuration. You must support at least one culture");
            }

            supportedCultureNames = supportedCultureNames.Where(cultureName => !string.IsNullOrEmpty(cultureName));

            if (!supportedCultureNames.Any())
            {
                throw new ConfigurationException("Invalid Globalization configuration. You must support at least one culture");
            }

            if (string.IsNullOrEmpty(defaultCulture))
            {
                defaultCulture = supportedCultureNames.First();
            }

            if (!supportedCultureNames.Contains(defaultCulture, StringComparer.OrdinalIgnoreCase))
            {
                throw new ConfigurationException("Invalid Globalization configuration. " + defaultCulture + " does not exist in the supported culture names");
            }

            this.SupportedCultureNames = supportedCultureNames;
            this.DefaultCulture = defaultCulture;
        }

        /// <summary>
        /// A set of supported cultures
        /// </summary>
        public IEnumerable<string> SupportedCultureNames { get; private set; }

        /// <summary>
        /// The default culture for the application
        /// </summary>
        public string DefaultCulture { get; private set; }
    }
}
namespace Nancy
{
    using System.Collections.Generic;
    using Nancy.Configuration;

    /// <summary>
    /// Contains <see cref="GlobalizationConfiguration"/> configuration extensions for <see cref="INancyEnvironment"/>.
    /// </summary>
    public static class GlobalizationConfigurationExtensions
    {
        /// <summary>
        /// Configures <see cref="GlobalizationConfiguration"/>
        /// </summary>
        /// <param name="environment">An <see cref="INancyEnvironment"/> that should be configured.</param>
        /// <param name="supportedCultureNames">Cultures that the application can accept</param>
        /// <param name="defaultCulture">Used to set a default culture for the application</param>
        /// <remarks>If defaultCulture not specified the first supported culture is used</remarks>
        public static void Cultures(this INancyEnvironment environment, IEnumerable<string> supportedCultureNames, string defaultCulture = null)
        {
            environment.AddValue(new GlobalizationConfiguration(
                supportedCultureNames: supportedCultureNames,
                defaultCulture: defaultCulture));
        }
    }
}
namespace Nancy
{
    using Nancy.Configuration;

    /// <summary>
    /// Provides the default <see cref="GlobalizationConfiguration"/>.
    /// </summary>
    public class DefaultGlobalizationConfigurationProvider : NancyDefaultConfigurationProvider<GlobalizationConfiguration>
    {
        /// <summary>
        /// Gets the default <see cref="GlobalizationConfiguration"/> configuration instance to register in the <see cref="INancyEnvironment"/> .
        /// </summary>
        /// <returns>The configuration instance</returns>
        public override GlobalizationConfiguration GetDefaultConfiguration()
        {
            return GlobalizationConfiguration.Default;
        }
    }
}
namespace Nancy
{
    using System;
    using Nancy.Configuration;

    /// <summary>
    /// An exception related to an invalid configuration created within <see cref="INancyEnvironment"/>
    /// </summary>
    public class ConfigurationException : Exception
    {
        /// <summary>
        /// Create an instance of <see cref="ConfigurationException"/>
        /// </summary>
        /// <param name="message">A message to be passed into the exception</param>
        public ConfigurationException(string message)
            : base(message)
        {

        }

        /// <summary>
        /// Create an instance of <see cref="ConfigurationException"/>
        /// </summary>
        /// <param name="message">A message to be passed into the exception</param>
        /// <param name = "exception">An inner exception to buble up</param>
        public ConfigurationException(string message, Exception exception)
            : base(message, exception)
        {

        }
    }
}
